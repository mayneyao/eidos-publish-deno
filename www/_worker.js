import { EventEmitter } from 'node:events';
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value2) {
    __privateSet(obj, member, value2, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});

// node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js
var require_moo = __commonJS({
  "node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.moo = factory();
      }
    })(exports, function() {
      "use strict";
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var toString = Object.prototype.toString;
      var hasSticky = typeof new RegExp().sticky === "boolean";
      function isRegExp(o) {
        return o && toString.call(o) === "[object RegExp]";
      }
      function isObject(o) {
        return o && typeof o === "object" && !isRegExp(o) && !Array.isArray(o);
      }
      function reEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      function reGroups(s) {
        var re = new RegExp("|" + s);
        return re.exec("").length - 1;
      }
      function reCapture(s) {
        return "(" + s + ")";
      }
      function reUnion(regexps) {
        if (!regexps.length) return "(?!)";
        var source = regexps.map(function(s) {
          return "(?:" + s + ")";
        }).join("|");
        return "(?:" + source + ")";
      }
      function regexpOrLiteral(obj) {
        if (typeof obj === "string") {
          return "(?:" + reEscape(obj) + ")";
        } else if (isRegExp(obj)) {
          if (obj.ignoreCase) throw new Error("RegExp /i flag not allowed");
          if (obj.global) throw new Error("RegExp /g flag is implied");
          if (obj.sticky) throw new Error("RegExp /y flag is implied");
          if (obj.multiline) throw new Error("RegExp /m flag is implied");
          return obj.source;
        } else {
          throw new Error("Not a pattern: " + obj);
        }
      }
      function pad(s, length) {
        if (s.length > length) {
          return s;
        }
        return Array(length - s.length + 1).join(" ") + s;
      }
      function lastNLines(string3, numLines) {
        var position = string3.length;
        var lineBreaks = 0;
        while (true) {
          var idx = string3.lastIndexOf("\n", position - 1);
          if (idx === -1) {
            break;
          } else {
            lineBreaks++;
          }
          position = idx;
          if (lineBreaks === numLines) {
            break;
          }
          if (position === 0) {
            break;
          }
        }
        var startPosition = lineBreaks < numLines ? 0 : position + 1;
        return string3.substring(startPosition).split("\n");
      }
      function objectToRules(object2) {
        var keys = Object.getOwnPropertyNames(object2);
        var result = [];
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var thing = object2[key];
          var rules = [].concat(thing);
          if (key === "include") {
            for (var j = 0; j < rules.length; j++) {
              result.push({ include: rules[j] });
            }
            continue;
          }
          var match = [];
          rules.forEach(function(rule) {
            if (isObject(rule)) {
              if (match.length) result.push(ruleOptions(key, match));
              result.push(ruleOptions(key, rule));
              match = [];
            } else {
              match.push(rule);
            }
          });
          if (match.length) result.push(ruleOptions(key, match));
        }
        return result;
      }
      function arrayToRules(array2) {
        var result = [];
        for (var i = 0; i < array2.length; i++) {
          var obj = array2[i];
          if (obj.include) {
            var include = [].concat(obj.include);
            for (var j = 0; j < include.length; j++) {
              result.push({ include: include[j] });
            }
            continue;
          }
          if (!obj.type) {
            throw new Error("Rule has no type: " + JSON.stringify(obj));
          }
          result.push(ruleOptions(obj.type, obj));
        }
        return result;
      }
      function ruleOptions(type, obj) {
        if (!isObject(obj)) {
          obj = { match: obj };
        }
        if (obj.include) {
          throw new Error("Matching rules cannot also include states");
        }
        var options = {
          defaultType: type,
          lineBreaks: !!obj.error || !!obj.fallback,
          pop: false,
          next: null,
          push: null,
          error: false,
          fallback: false,
          value: null,
          type: null,
          shouldThrow: false
        };
        for (var key in obj) {
          if (hasOwnProperty.call(obj, key)) {
            options[key] = obj[key];
          }
        }
        if (typeof options.type === "string" && type !== options.type) {
          throw new Error("Type transform cannot be a string (type '" + options.type + "' for token '" + type + "')");
        }
        var match = options.match;
        options.match = Array.isArray(match) ? match : match ? [match] : [];
        options.match.sort(function(a, b) {
          return isRegExp(a) && isRegExp(b) ? 0 : isRegExp(b) ? -1 : isRegExp(a) ? 1 : b.length - a.length;
        });
        return options;
      }
      function toRules(spec) {
        return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);
      }
      var defaultErrorRule = ruleOptions("error", { lineBreaks: true, shouldThrow: true });
      function compileRules(rules, hasStates) {
        var errorRule = null;
        var fast = /* @__PURE__ */ Object.create(null);
        var fastAllowed = true;
        var unicodeFlag = null;
        var groups = [];
        var parts = [];
        for (var i = 0; i < rules.length; i++) {
          if (rules[i].fallback) {
            fastAllowed = false;
          }
        }
        for (var i = 0; i < rules.length; i++) {
          var options = rules[i];
          if (options.include) {
            throw new Error("Inheritance is not allowed in stateless lexers");
          }
          if (options.error || options.fallback) {
            if (errorRule) {
              if (!options.fallback === !errorRule.fallback) {
                throw new Error("Multiple " + (options.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options.defaultType + "')");
              } else {
                throw new Error("fallback and error are mutually exclusive (for token '" + options.defaultType + "')");
              }
            }
            errorRule = options;
          }
          var match = options.match.slice();
          if (fastAllowed) {
            while (match.length && typeof match[0] === "string" && match[0].length === 1) {
              var word2 = match.shift();
              fast[word2.charCodeAt(0)] = options;
            }
          }
          if (options.pop || options.push || options.next) {
            if (!hasStates) {
              throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.defaultType + "')");
            }
            if (options.fallback) {
              throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options.defaultType + "')");
            }
          }
          if (match.length === 0) {
            continue;
          }
          fastAllowed = false;
          groups.push(options);
          for (var j = 0; j < match.length; j++) {
            var obj = match[j];
            if (!isRegExp(obj)) {
              continue;
            }
            if (unicodeFlag === null) {
              unicodeFlag = obj.unicode;
            } else if (unicodeFlag !== obj.unicode && options.fallback === false) {
              throw new Error("If one rule is /u then all must be");
            }
          }
          var pat = reUnion(match.map(regexpOrLiteral));
          var regexp = new RegExp(pat);
          if (regexp.test("")) {
            throw new Error("RegExp matches empty string: " + regexp);
          }
          var groupCount = reGroups(pat);
          if (groupCount > 0) {
            throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: \u2026 ) instead");
          }
          if (!options.lineBreaks && regexp.test("\n")) {
            throw new Error("Rule should declare lineBreaks: " + regexp);
          }
          parts.push(reCapture(pat));
        }
        var fallbackRule = errorRule && errorRule.fallback;
        var flags = hasSticky && !fallbackRule ? "ym" : "gm";
        var suffix = hasSticky || fallbackRule ? "" : "|";
        if (unicodeFlag === true) flags += "u";
        var combined = new RegExp(reUnion(parts) + suffix, flags);
        return { regexp: combined, groups, fast, error: errorRule || defaultErrorRule };
      }
      function compile(rules) {
        var result = compileRules(toRules(rules));
        return new Lexer({ start: result }, "start");
      }
      function checkStateGroup(g, name2, map) {
        var state = g && (g.push || g.next);
        if (state && !map[state]) {
          throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name2 + "')");
        }
        if (g && g.pop && +g.pop !== 1) {
          throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name2 + "')");
        }
      }
      function compileStates(states, start) {
        var all = states.$all ? toRules(states.$all) : [];
        delete states.$all;
        var keys = Object.getOwnPropertyNames(states);
        if (!start) start = keys[0];
        var ruleMap = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          ruleMap[key] = toRules(states[key]).concat(all);
        }
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var rules = ruleMap[key];
          var included = /* @__PURE__ */ Object.create(null);
          for (var j = 0; j < rules.length; j++) {
            var rule = rules[j];
            if (!rule.include) continue;
            var splice = [j, 1];
            if (rule.include !== key && !included[rule.include]) {
              included[rule.include] = true;
              var newRules = ruleMap[rule.include];
              if (!newRules) {
                throw new Error("Cannot include nonexistent state '" + rule.include + "' (in state '" + key + "')");
              }
              for (var k = 0; k < newRules.length; k++) {
                var newRule = newRules[k];
                if (rules.indexOf(newRule) !== -1) continue;
                splice.push(newRule);
              }
            }
            rules.splice.apply(rules, splice);
            j--;
          }
        }
        var map = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          map[key] = compileRules(ruleMap[key], true);
        }
        for (var i = 0; i < keys.length; i++) {
          var name2 = keys[i];
          var state = map[name2];
          var groups = state.groups;
          for (var j = 0; j < groups.length; j++) {
            checkStateGroup(groups[j], name2, map);
          }
          var fastKeys = Object.getOwnPropertyNames(state.fast);
          for (var j = 0; j < fastKeys.length; j++) {
            checkStateGroup(state.fast[fastKeys[j]], name2, map);
          }
        }
        return new Lexer(map, start);
      }
      function keywordTransform(map) {
        var isMap = typeof Map !== "undefined";
        var reverseMap = isMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
        var types2 = Object.getOwnPropertyNames(map);
        for (var i = 0; i < types2.length; i++) {
          var tokenType = types2[i];
          var item = map[tokenType];
          var keywordList = Array.isArray(item) ? item : [item];
          keywordList.forEach(function(keyword) {
            if (typeof keyword !== "string") {
              throw new Error("keyword must be string (in keyword '" + tokenType + "')");
            }
            if (isMap) {
              reverseMap.set(keyword, tokenType);
            } else {
              reverseMap[keyword] = tokenType;
            }
          });
        }
        return function(k) {
          return isMap ? reverseMap.get(k) : reverseMap[k];
        };
      }
      var Lexer = function(states, state) {
        this.startState = state;
        this.states = states;
        this.buffer = "";
        this.stack = [];
        this.reset();
      };
      Lexer.prototype.reset = function(data, info) {
        this.buffer = data || "";
        this.index = 0;
        this.line = info ? info.line : 1;
        this.col = info ? info.col : 1;
        this.queuedToken = info ? info.queuedToken : null;
        this.queuedText = info ? info.queuedText : "";
        this.queuedThrow = info ? info.queuedThrow : null;
        this.setState(info ? info.state : this.startState);
        this.stack = info && info.stack ? info.stack.slice() : [];
        return this;
      };
      Lexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.col,
          state: this.state,
          stack: this.stack.slice(),
          queuedToken: this.queuedToken,
          queuedText: this.queuedText,
          queuedThrow: this.queuedThrow
        };
      };
      Lexer.prototype.setState = function(state) {
        if (!state || this.state === state) return;
        this.state = state;
        var info = this.states[state];
        this.groups = info.groups;
        this.error = info.error;
        this.re = info.regexp;
        this.fast = info.fast;
      };
      Lexer.prototype.popState = function() {
        this.setState(this.stack.pop());
      };
      Lexer.prototype.pushState = function(state) {
        this.stack.push(this.state);
        this.setState(state);
      };
      var eat = hasSticky ? function(re, buffer) {
        return re.exec(buffer);
      } : function(re, buffer) {
        var match = re.exec(buffer);
        if (match[0].length === 0) {
          return null;
        }
        return match;
      };
      Lexer.prototype._getGroup = function(match) {
        var groupCount = this.groups.length;
        for (var i = 0; i < groupCount; i++) {
          if (match[i + 1] !== void 0) {
            return this.groups[i];
          }
        }
        throw new Error("Cannot find token type for matched text");
      };
      function tokenToString() {
        return this.value;
      }
      Lexer.prototype.next = function() {
        var index = this.index;
        if (this.queuedGroup) {
          var token = this._token(this.queuedGroup, this.queuedText, index);
          this.queuedGroup = null;
          this.queuedText = "";
          return token;
        }
        var buffer = this.buffer;
        if (index === buffer.length) {
          return;
        }
        var group = this.fast[buffer.charCodeAt(index)];
        if (group) {
          return this._token(group, buffer.charAt(index), index);
        }
        var re = this.re;
        re.lastIndex = index;
        var match = eat(re, buffer);
        var error = this.error;
        if (match == null) {
          return this._token(error, buffer.slice(index, buffer.length), index);
        }
        var group = this._getGroup(match);
        var text = match[0];
        if (error.fallback && match.index !== index) {
          this.queuedGroup = group;
          this.queuedText = text;
          return this._token(error, buffer.slice(index, match.index), index);
        }
        return this._token(group, text, index);
      };
      Lexer.prototype._token = function(group, text, offset) {
        var lineBreaks = 0;
        if (group.lineBreaks) {
          var matchNL = /\n/g;
          var nl3 = 1;
          if (text === "\n") {
            lineBreaks = 1;
          } else {
            while (matchNL.exec(text)) {
              lineBreaks++;
              nl3 = matchNL.lastIndex;
            }
          }
        }
        var token = {
          type: typeof group.type === "function" && group.type(text) || group.defaultType,
          value: typeof group.value === "function" ? group.value(text) : text,
          text,
          toString: tokenToString,
          offset,
          lineBreaks,
          line: this.line,
          col: this.col
        };
        var size = text.length;
        this.index += size;
        this.line += lineBreaks;
        if (lineBreaks !== 0) {
          this.col = size - nl3 + 1;
        } else {
          this.col += size;
        }
        if (group.shouldThrow) {
          var err = new Error(this.formatError(token, "invalid syntax"));
          throw err;
        }
        if (group.pop) this.popState();
        else if (group.push) this.pushState(group.push);
        else if (group.next) this.setState(group.next);
        return token;
      };
      if (typeof Symbol !== "undefined" && Symbol.iterator) {
        var LexerIterator = function(lexer) {
          this.lexer = lexer;
        };
        LexerIterator.prototype.next = function() {
          var token = this.lexer.next();
          return { value: token, done: !token };
        };
        LexerIterator.prototype[Symbol.iterator] = function() {
          return this;
        };
        Lexer.prototype[Symbol.iterator] = function() {
          return new LexerIterator(this);
        };
      }
      Lexer.prototype.formatError = function(token, message) {
        if (token == null) {
          var text = this.buffer.slice(this.index);
          var token = {
            text,
            offset: this.index,
            lineBreaks: text.indexOf("\n") === -1 ? 0 : 1,
            line: this.line,
            col: this.col
          };
        }
        var numLinesAround = 2;
        var firstDisplayedLine = Math.max(token.line - numLinesAround, 1);
        var lastDisplayedLine = token.line + numLinesAround;
        var lastLineDigits = String(lastDisplayedLine).length;
        var displayedLines = lastNLines(
          this.buffer,
          this.line - token.line + numLinesAround + 1
        ).slice(0, 5);
        var errorLines = [];
        errorLines.push(message + " at line " + token.line + " col " + token.col + ":");
        errorLines.push("");
        for (var i = 0; i < displayedLines.length; i++) {
          var line = displayedLines[i];
          var lineNo = firstDisplayedLine + i;
          errorLines.push(pad(String(lineNo), lastLineDigits) + "  " + line);
          if (lineNo === token.line) {
            errorLines.push(pad("", lastLineDigits + token.col + 1) + "^");
          }
        }
        return errorLines.join("\n");
      };
      Lexer.prototype.clone = function() {
        return new Lexer(this.states, this.state);
      };
      Lexer.prototype.has = function(tokenType) {
        return true;
      };
      return {
        compile,
        states: compileStates,
        error: Object.freeze({ error: true }),
        fallback: Object.freeze({ fallback: true }),
        keywords: keywordTransform
      };
    });
  }
});

// node_modules/.pnpm/nearley@2.20.1/node_modules/nearley/lib/nearley.js
var require_nearley = __commonJS({
  "node_modules/.pnpm/nearley@2.20.1/node_modules/nearley/lib/nearley.js"(exports, module) {
    (function(root, factory) {
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.nearley = factory();
      }
    })(exports, function() {
      function Rule(name2, symbols, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name2;
        this.symbols = symbols;
        this.postprocess = postprocess;
        return this;
      }
      Rule.highestId = 0;
      Rule.prototype.toString = function(withCursorAt) {
        var symbolSequence = typeof withCursorAt === "undefined" ? this.symbols.map(getSymbolShortDisplay).join(" ") : this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(" ") + " \u25CF " + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(" ");
        return this.name + " \u2192 " + symbolSequence;
      };
      function State(rule, dot2, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot2;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
      }
      State.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      };
      State.prototype.nextState = function(child) {
        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
          state.data = state.build();
          state.right = void 0;
        }
        return state;
      };
      State.prototype.build = function() {
        var children = [];
        var node = this;
        do {
          children.push(node.right.data);
          node = node.left;
        } while (node.left);
        children.reverse();
        return children;
      };
      State.prototype.finish = function() {
        if (this.rule.postprocess) {
          this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
        }
      };
      function Column(grammar, index) {
        this.grammar = grammar;
        this.index = index;
        this.states = [];
        this.wants = {};
        this.scannable = [];
        this.completed = {};
      }
      Column.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;
        for (var w = 0; w < states.length; w++) {
          var state = states[w];
          if (state.isComplete) {
            state.finish();
            if (state.data !== Parser.fail) {
              var wantedBy = state.wantedBy;
              for (var i = wantedBy.length; i--; ) {
                var left = wantedBy[i];
                this.complete(left, state);
              }
              if (state.reference === this.index) {
                var exp = state.rule.name;
                (this.completed[exp] = this.completed[exp] || []).push(state);
              }
            }
          } else {
            var exp = state.rule.symbols[state.dot];
            if (typeof exp !== "string") {
              this.scannable.push(state);
              continue;
            }
            if (wants[exp]) {
              wants[exp].push(state);
              if (completed.hasOwnProperty(exp)) {
                var nulls = completed[exp];
                for (var i = 0; i < nulls.length; i++) {
                  var right = nulls[i];
                  this.complete(state, right);
                }
              }
            } else {
              wants[exp] = [state];
              this.predict(exp);
            }
          }
        }
      };
      Column.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];
        for (var i = 0; i < rules.length; i++) {
          var r = rules[i];
          var wantedBy = this.wants[exp];
          var s = new State(r, 0, this.index, wantedBy);
          this.states.push(s);
        }
      };
      Column.prototype.complete = function(left, right) {
        var copy = left.nextState(right);
        this.states.push(copy);
      };
      function Grammar(rules, start) {
        this.rules = rules;
        this.start = start || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
          if (!byName.hasOwnProperty(rule.name)) {
            byName[rule.name] = [];
          }
          byName[rule.name].push(rule);
        });
      }
      Grammar.fromCompiled = function(rules, start) {
        var lexer = rules.Lexer;
        if (rules.ParserStart) {
          start = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function(r) {
          return new Rule(r.name, r.symbols, r.postprocess);
        });
        var g = new Grammar(rules, start);
        g.lexer = lexer;
        return g;
      };
      function StreamLexer() {
        this.reset("");
      }
      StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
      };
      StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var ch = this.buffer[this.index++];
          if (ch === "\n") {
            this.line += 1;
            this.lastLineBreak = this.index;
          }
          return { value: ch };
        }
      };
      StreamLexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      };
      StreamLexer.prototype.formatError = function(token, message) {
        var buffer = this.buffer;
        if (typeof buffer === "string") {
          var lines = buffer.split("\n").slice(
            Math.max(0, this.line - 5),
            this.line
          );
          var nextLineBreak = buffer.indexOf("\n", this.index);
          if (nextLineBreak === -1) nextLineBreak = buffer.length;
          var col = this.index - this.lastLineBreak;
          var lastLineDigits = String(this.line).length;
          message += " at line " + this.line + " col " + col + ":\n\n";
          message += lines.map(function(line, i) {
            return pad(this.line - lines.length + i + 1, lastLineDigits) + " " + line;
          }, this).join("\n");
          message += "\n" + pad("", lastLineDigits + col) + "^\n";
          return message;
        } else {
          return message + " at index " + (this.index - 1);
        }
        function pad(n, length) {
          var s = String(n);
          return Array(length - s.length + 1).join(" ") + s;
        }
      };
      function Parser(rules, start, options) {
        if (rules instanceof Grammar) {
          var grammar = rules;
          var options = start;
        } else {
          var grammar = Grammar.fromCompiled(rules, start);
        }
        this.grammar = grammar;
        this.options = {
          keepHistory: false,
          lexer: grammar.lexer || new StreamLexer()
        };
        for (var key in options || {}) {
          this.options[key] = options[key];
        }
        this.lexer = this.options.lexer;
        this.lexerState = void 0;
        var column = new Column(grammar, 0);
        var table = this.table = [column];
        column.wants[grammar.start] = [];
        column.predict(grammar.start);
        column.process();
        this.current = 0;
      }
      Parser.fail = {};
      Parser.prototype.feed = function(chunk) {
        var lexer = this.lexer;
        lexer.reset(chunk, this.lexerState);
        var token;
        while (true) {
          try {
            token = lexer.next();
            if (!token) {
              break;
            }
          } catch (e) {
            var nextColumn = new Column(this.grammar, this.current + 1);
            this.table.push(nextColumn);
            var err = new Error(this.reportLexerError(e));
            err.offset = this.current;
            err.token = e.token;
            throw err;
          }
          var column = this.table[this.current];
          if (!this.options.keepHistory) {
            delete this.table[this.current - 1];
          }
          var n = this.current + 1;
          var nextColumn = new Column(this.grammar, n);
          this.table.push(nextColumn);
          var literal = token.text !== void 0 ? token.text : token.value;
          var value2 = lexer.constructor === StreamLexer ? token.value : token;
          var scannable = column.scannable;
          for (var w = scannable.length; w--; ) {
            var state = scannable[w];
            var expect = state.rule.symbols[state.dot];
            if (expect.test ? expect.test(value2) : expect.type ? expect.type === token.type : expect.literal === literal) {
              var next = state.nextState({ data: value2, token, isToken: true, reference: n - 1 });
              nextColumn.states.push(next);
            }
          }
          nextColumn.process();
          if (nextColumn.states.length === 0) {
            var err = new Error(this.reportError(token));
            err.offset = this.current;
            err.token = token;
            throw err;
          }
          if (this.options.keepHistory) {
            column.lexerState = lexer.save();
          }
          this.current++;
        }
        if (column) {
          this.lexerState = lexer.save();
        }
        this.results = this.finish();
        return this;
      };
      Parser.prototype.reportLexerError = function(lexerError) {
        var tokenDisplay, lexerMessage;
        var token = lexerError.token;
        if (token) {
          tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
          lexerMessage = this.lexer.formatError(token, "Syntax error");
        } else {
          tokenDisplay = "input (lexer error)";
          lexerMessage = lexerError.message;
        }
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportError = function(token) {
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== void 0 ? token.value : token);
        var lexerMessage = this.lexer.formatError(token, "Syntax error");
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
        var lines = [];
        lines.push(lexerMessage);
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states.filter(function(state) {
          var nextSymbol = state.rule.symbols[state.dot];
          return nextSymbol && typeof nextSymbol !== "string";
        });
        if (expectantStates.length === 0) {
          lines.push("Unexpected " + tokenDisplay + ". I did not expect any more input. Here is the state of my parse table:\n");
          this.displayStateStack(lastColumn.states, lines);
        } else {
          lines.push("Unexpected " + tokenDisplay + ". Instead, I was expecting to see one of the following:\n");
          var stateStacks = expectantStates.map(function(state) {
            return this.buildFirstStateStack(state, []) || [state];
          }, this);
          stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push("A " + symbolDisplay + " based on:");
            this.displayStateStack(stateStack, lines);
          }, this);
        }
        lines.push("");
        return lines.join("\n");
      };
      Parser.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j = 0; j < stateStack.length; j++) {
          var state = stateStack[j];
          var display = state.rule.toString(state.dot);
          if (display === lastDisplay) {
            sameDisplayCount++;
          } else {
            if (sameDisplayCount > 0) {
              lines.push("    ^ " + sameDisplayCount + " more lines identical to this");
            }
            sameDisplayCount = 0;
            lines.push("    " + display);
          }
          lastDisplay = display;
        }
      };
      Parser.prototype.getSymbolDisplay = function(symbol) {
        return getSymbolLongDisplay(symbol);
      };
      Parser.prototype.buildFirstStateStack = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
          return null;
        }
        if (state.wantedBy.length === 0) {
          return [state];
        }
        var prevState = state.wantedBy[0];
        var childVisited = [state].concat(visited);
        var childResult = this.buildFirstStateStack(prevState, childVisited);
        if (childResult === null) {
          return null;
        }
        return [state].concat(childResult);
      };
      Parser.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
      };
      Parser.prototype.restore = function(column) {
        var index = column.index;
        this.current = index;
        this.table[index] = column;
        this.table.splice(index + 1);
        this.lexerState = column.lexerState;
        this.results = this.finish();
      };
      Parser.prototype.rewind = function(index) {
        if (!this.options.keepHistory) {
          throw new Error("set option `keepHistory` to enable rewinding");
        }
        this.restore(this.table[index]);
      };
      Parser.prototype.finish = function() {
        var considerations = [];
        var start = this.grammar.start;
        var column = this.table[this.table.length - 1];
        column.states.forEach(function(t) {
          if (t.rule.name === start && t.dot === t.rule.symbols.length && t.reference === 0 && t.data !== Parser.fail) {
            considerations.push(t);
          }
        });
        return considerations.map(function(c) {
          return c.data;
        });
      };
      function getSymbolLongDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return "character matching " + symbol;
          } else if (symbol.type) {
            return symbol.type + " token";
          } else if (symbol.test) {
            return "token matching " + String(symbol.test);
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      function getSymbolShortDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return symbol.toString();
          } else if (symbol.type) {
            return "%" + symbol.type;
          } else if (symbol.test) {
            return "<" + String(symbol.test) + ">";
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      return {
        Parser,
        Grammar,
        Rule
      };
    });
  }
});

// node_modules/.pnpm/pgsql-ast-parser@11.1.0/node_modules/pgsql-ast-parser/index.js
var require_pgsql_ast_parser = __commonJS({
  "node_modules/.pnpm/pgsql-ast-parser@11.1.0/node_modules/pgsql-ast-parser/index.js"(exports) {
    (function(e, a) {
      for (var i in a) e[i] = a[i];
    })(
      exports,
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module2 = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.l = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name2, getter) {
          if (!__webpack_require__.o(exports2, name2)) {
            Object.defineProperty(exports2, name2, { enumerable: true, get: getter });
          }
        };
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__.t = function(value2, mode) {
          if (mode & 1) value2 = __webpack_require__(value2);
          if (mode & 8) return value2;
          if (mode & 4 && typeof value2 === "object" && value2 && value2.__esModule) return value2;
          var ns = /* @__PURE__ */ Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", { enumerable: true, value: value2 });
          if (mode & 2 && typeof value2 != "string") for (var key in value2) __webpack_require__.d(ns, key, function(key2) {
            return value2[key2];
          }.bind(null, key));
          return ns;
        };
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? (
            /******/
            function getDefault() {
              return module2["default"];
            }
          ) : (
            /******/
            function getModuleExports() {
              return module2;
            }
          );
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object2, property) {
          return Object.prototype.hasOwnProperty.call(object2, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 7);
      }([
        /* 0 */
        /***/
        function(module2, exports2) {
          module2.exports = require_moo();
        },
        /* 1 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.unbox = exports2.doubleQuoted = exports2.box = exports2.track = exports2.tracking = exports2.trackingComments = exports2.lexerAny = exports2.lexer = void 0;
          const moo_1 = __webpack_require__(0);
          const keywords_1 = __webpack_require__(3);
          const keywordsMap = {};
          for (const k of keywords_1.sqlKeywords) {
            keywordsMap["kw_" + k.toLowerCase()] = k;
          }
          const caseInsensitiveKeywords = (map) => {
            const transform2 = (0, moo_1.keywords)(map);
            return (text) => transform2(text.toUpperCase());
          };
          exports2.lexer = (0, moo_1.compile)({
            word: {
              match: /[eE](?!')[A-Za-z0-9_]*|[a-df-zA-DF-Z_][A-Za-z0-9_]*/,
              type: caseInsensitiveKeywords(keywordsMap),
              value: (x) => x.toLowerCase()
            },
            wordQuoted: {
              match: /"(?:[^"\*]|"")+"/,
              type: () => "quoted_word",
              value: (x) => x.substring(1, x.length - 1)
            },
            string: {
              match: /'(?:[^']|\'\')*'/,
              value: (x) => {
                return x.substring(1, x.length - 1).replace(/''/g, "'");
              }
            },
            eString: {
              match: /\b(?:e|E)'(?:[^'\\]|[\r\n\s]|(?:\\\s)|(?:\\\n)|(?:\\.)|(?:\'\'))+'/,
              value: (x) => {
                return x.substring(2, x.length - 1).replace(/''/g, "'").replace(/\\([\s\n])/g, (_, x2) => x2).replace(/\\./g, (m) => JSON.parse('"' + m + '"'));
              }
            },
            qparam: {
              match: /\$\d+/
            },
            commentLine: /\-\-.*?$[\s\r\n]*/,
            commentFullOpen: /\/\*/,
            commentFullClose: /\*\/[\s\r\n]*/,
            star: "*",
            comma: ",",
            space: { match: /[\s\t\n\v\f\r]+/, lineBreaks: true },
            int: /\-?\d+(?![\.\d])/,
            float: /\-?(?:(?:\d*\.\d+)|(?:\d+\.\d*))/,
            // word: /[a-zA-Z][A-Za-z0-9_\-]*/,
            lparen: "(",
            rparen: ")",
            lbracket: "[",
            rbracket: "]",
            semicolon: ";",
            dot: /\.(?!\d)/,
            op_cast: "::",
            op_colon: ":",
            op_plus: "+",
            op_eq: "=",
            op_neq: {
              match: /(?:!=)|(?:\<\>)/,
              value: () => "!="
            },
            op_membertext: "->>",
            op_member: "->",
            op_minus: "-",
            op_div: /\//,
            op_not_ilike: /\!~~\*/,
            op_not_like: /\!~~/,
            op_ilike: /~~\*/,
            op_like: /~~/,
            op_mod: "%",
            op_exp: "^",
            op_additive: {
              // group other additive operators
              match: ["||", "-", "#-", "&&"]
            },
            op_compare: {
              // group other comparison operators
              // ... to add: "IN" and "NOT IN" that are matched by keywords
              match: [">", ">=", "<", "<=", "@>", "<@", "?", "?|", "?&", "#>>", ">>", "<<", "~", "~*", "!~", "!~*", "@@"]
            },
            ops_others: {
              // referenced as (any other operator) in https://www.postgresql.org/docs/12/sql-syntax-lexical.html#SQL-PRECEDENCE
              // see also https://www.postgresql.org/docs/9.0/functions-math.html
              match: ["|", "&", "^", "#"]
            },
            codeblock: {
              match: /\$\$(?:.|[\s\t\n\v\f\r])*?\$\$/s,
              lineBreaks: true,
              value: (x) => x.substring(2, x.length - 2)
            }
          });
          exports2.lexer.next = /* @__PURE__ */ ((next) => () => {
            let tok;
            let commentFull = null;
            while (tok = next.call(exports2.lexer)) {
              if (tok.type === "commentFullOpen") {
                if (commentFull === null) {
                  commentFull = {
                    nested: 0,
                    offset: tok.offset,
                    text: tok.text
                  };
                  continue;
                }
                commentFull.nested++;
              }
              if (commentFull != null) {
                commentFull.text += tok.text;
                if (tok.type === "commentFullClose") {
                  if (commentFull.nested === 0) {
                    comments === null || comments === void 0 ? void 0 : comments.push(makeComment(commentFull));
                    commentFull = null;
                    continue;
                  }
                  commentFull.nested--;
                }
                continue;
              }
              if (tok.type === "space") {
                continue;
              }
              if (tok.type === "commentLine") {
                comments === null || comments === void 0 ? void 0 : comments.push(makeComment(tok));
                continue;
              }
              break;
            }
            if (trackingLoc && tok) {
              const start = tok.offset;
              const loc = {
                start,
                end: start + tok.text.length
              };
              tok._location = loc;
            }
            return tok;
          })(exports2.lexer.next);
          exports2.lexerAny = exports2.lexer;
          let comments = null;
          const makeComment = ({ offset, text }) => ({
            _location: { start: offset, end: offset + text.length },
            comment: text
          });
          function trackingComments(act) {
            if (comments) {
              throw new Error("WAT ? Recursive comments tracking \u{1F914}\u{1F928} ?");
            }
            try {
              comments = [];
              const ast = act();
              return { comments, ast };
            } finally {
              comments = null;
            }
          }
          exports2.trackingComments = trackingComments;
          let trackingLoc = false;
          function tracking(act) {
            if (trackingLoc) {
              return act();
            }
            try {
              trackingLoc = true;
              return act();
            } finally {
              trackingLoc = false;
            }
          }
          exports2.tracking = tracking;
          function track(xs, ret) {
            if (!trackingLoc || !ret || typeof ret !== "object") {
              return ret;
            }
            const start = seek(xs, true);
            const end = seek(xs, false);
            if (!start || !end) {
              return ret;
            }
            if (start === end) {
              ret._location = start;
            } else {
              const loc = {
                start: start.start,
                end: end.end
              };
              ret._location = loc;
            }
            return ret;
          }
          exports2.track = track;
          const literal = Symbol("_literal");
          const doubleQuotedSym = Symbol("_doublequoted");
          function box(xs, value2, doubleQuoted2) {
            if (!trackingLoc && !doubleQuoted2) {
              return value2;
            }
            return track(xs, { [literal]: value2, [doubleQuotedSym]: doubleQuoted2 });
          }
          exports2.box = box;
          function unwrapNoBox(e) {
            if (Array.isArray(e) && e.length === 1) {
              e = unwrapNoBox(e[0]);
            }
            if (Array.isArray(e) && !e.length) {
              return null;
            }
            return e;
          }
          function doubleQuoted(value2) {
            const uw = unwrapNoBox(value2);
            if (typeof value2 === "object" && (uw === null || uw === void 0 ? void 0 : uw[doubleQuotedSym])) {
              return { doubleQuoted: true };
            }
            return void 0;
          }
          exports2.doubleQuoted = doubleQuoted;
          function unbox(value2) {
            var _a;
            if (typeof value2 === "object") {
              return (_a = value2 === null || value2 === void 0 ? void 0 : value2[literal]) !== null && _a !== void 0 ? _a : value2;
            }
            return value2;
          }
          exports2.unbox = unbox;
          function seek(xs, start) {
            if (!xs) {
              return null;
            }
            if (Array.isArray(xs)) {
              const diff = start ? 1 : -1;
              for (let i = start ? 0 : xs.length - 1; i >= 0 && i < xs.length; i += diff) {
                const v = seek(xs[i], start);
                if (v) {
                  return v;
                }
              }
              return null;
            }
            if (typeof xs !== "object") {
              return null;
            }
            return xs._location;
          }
        },
        /* 2 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.AstDefaultMapper = exports2.arrayNilMap = exports2.assignChanged = exports2.astMapper = void 0;
          const utils_1 = __webpack_require__(6);
          function astMapper5(modifierBuilder) {
            const instance = new AstDefaultMapper();
            instance.wrapped = modifierBuilder(instance);
            return instance;
          }
          exports2.astMapper = astMapper5;
          function assignChanged(orig, assign) {
            if (!orig) {
              return orig;
            }
            let changed = false;
            for (const k of Object.keys(assign)) {
              if (orig[k] !== assign[k]) {
                changed = true;
                break;
              }
            }
            if (!changed) {
              return orig;
            }
            return (0, utils_1.trimNullish)({
              ...orig,
              ...assign
            }, 0);
          }
          exports2.assignChanged = assignChanged;
          function arrayNilMap(collection, mapper) {
            if (!(collection === null || collection === void 0 ? void 0 : collection.length)) {
              return collection;
            }
            let changed = false;
            let ret = collection;
            for (let i = 0; i < collection.length; i++) {
              const orig = collection[i];
              const val = mapper(orig);
              if (!changed && (!val || val !== orig)) {
                changed = true;
                ret = collection.slice(0, i);
              }
              if (!val) {
                continue;
              }
              if (changed) {
                ret.push(val);
              }
            }
            return ret;
          }
          exports2.arrayNilMap = arrayNilMap;
          function withAccepts(val) {
            switch (val === null || val === void 0 ? void 0 : val.type) {
              case "select":
              case "delete":
              case "insert":
              case "update":
              case "union":
              case "union all":
              case "with":
                return true;
              default:
                return false;
            }
          }
          class AstDefaultMapper {
            super() {
              return new SkipModifier(this);
            }
            statement(val) {
              switch (val.type) {
                case "alter table":
                  return this.alterTable(val);
                case "alter index":
                  return this.alterIndex(val);
                case "commit":
                case "start transaction":
                case "rollback":
                  return this.transaction(val);
                case "create index":
                  return this.createIndex(val);
                case "create table":
                  return this.createTable(val);
                case "truncate table":
                  return this.truncateTable(val);
                case "delete":
                  return this.delete(val);
                case "insert":
                  return this.insert(val);
                case "with":
                  return this.with(val);
                case "with recursive":
                  return this.withRecursive(val);
                case "select":
                  return this.selection(val);
                case "update":
                  return this.update(val);
                case "create extension":
                  return this.createExtension(val);
                case "tablespace":
                  return this.tablespace(val);
                case "set":
                  return this.setGlobal(val);
                case "set timezone":
                  return this.setTimezone(val);
                case "create sequence":
                  return this.createSequence(val);
                case "alter sequence":
                  return this.alterSequence(val);
                case "begin":
                  return this.begin(val);
                case "drop table":
                case "drop index":
                case "drop sequence":
                case "drop type":
                case "drop trigger":
                  return this.drop(val);
                case "create enum":
                  return this.createEnum(val);
                case "create composite type":
                  return this.createCompositeType(val);
                case "union":
                case "union all":
                  return this.union(val);
                case "show":
                  return this.show(val);
                case "prepare":
                  return this.prepare(val);
                case "deallocate":
                  return this.deallocate(val);
                case "create view":
                  return this.createView(val);
                case "create materialized view":
                  return this.createMaterializedView(val);
                case "refresh materialized view":
                  return this.refreshMaterializedView(val);
                case "create schema":
                  return this.createSchema(val);
                case "raise":
                  return this.raise(val);
                case "comment":
                  return this.comment(val);
                case "do":
                  return this.do(val);
                case "create function":
                  return this.createFunction(val);
                case "drop function":
                  return this.dropFunction(val);
                case "values":
                  return this.values(val);
                default:
                  throw utils_1.NotSupported.never(val);
              }
            }
            comment(val) {
              return val;
            }
            createView(val) {
              const query = this.select(val.query);
              if (!query) {
                return null;
              }
              const ref = this.tableRef(val.name);
              if (!ref) {
                return null;
              }
              return assignChanged(val, {
                query,
                name: ref
              });
            }
            createMaterializedView(val) {
              const query = this.select(val.query);
              if (!query) {
                return null;
              }
              const ref = this.tableRef(val.name);
              if (!ref) {
                return null;
              }
              return assignChanged(val, {
                query,
                name: ref
              });
            }
            refreshMaterializedView(val) {
              return val;
            }
            do(val) {
              return val;
            }
            createFunction(val) {
              const args = arrayNilMap(val.arguments, (a) => {
                const type = this.dataType(a.type);
                return assignChanged(a, { type });
              });
              let returns;
              if (val.returns) {
                switch (val.returns.kind) {
                  case "table":
                    returns = assignChanged(val.returns, {
                      columns: arrayNilMap(val.returns.columns, (v) => {
                        const type = this.dataType(v.type);
                        return type && assignChanged(v, { type });
                      })
                    });
                    break;
                  case void 0:
                  case null:
                  case "array":
                    returns = this.dataType(val.returns);
                    break;
                  default:
                    throw utils_1.NotSupported.never(val.returns);
                }
              }
              return assignChanged(val, {
                returns,
                arguments: args
              });
            }
            dropFunction(val) {
              const args = arrayNilMap(val.arguments, (a) => {
                const type = this.dataType(a.type);
                return assignChanged(a, { type });
              });
              return assignChanged(val, {
                arguments: args
              });
            }
            show(val) {
              return val;
            }
            createEnum(val) {
              return val;
            }
            createCompositeType(val) {
              const attributes = arrayNilMap(val.attributes, (a) => assignChanged(a, {
                dataType: this.dataType(a.dataType)
              }));
              return assignChanged(val, { attributes });
            }
            drop(val) {
              return val;
            }
            alterSequence(seq) {
              if (seq.change.type === "set options") {
                if (seq.change.as) {
                  this.dataType(seq.change.as);
                }
              }
              return seq;
            }
            begin(begin) {
              return begin;
            }
            createSequence(seq) {
              if (seq.options.as) {
                this.dataType(seq.options.as);
              }
              return seq;
            }
            tablespace(val) {
              return val;
            }
            setGlobal(val) {
              return val;
            }
            setTimezone(val) {
              return val;
            }
            update(val) {
              if (!val) {
                return val;
              }
              const table = this.tableRef(val.table);
              if (!table) {
                return null;
              }
              const from = val.from && this.from(val.from);
              const where = val.where && this.expr(val.where);
              const sets = arrayNilMap(val.sets, (x) => this.set(x));
              if (!(sets === null || sets === void 0 ? void 0 : sets.length)) {
                return null;
              }
              const returning = arrayNilMap(val.returning, (c) => this.selectionColumn(c));
              return assignChanged(val, {
                table,
                where,
                sets,
                from,
                returning
              });
            }
            insert(val) {
              var _a, _b;
              const into = this.tableRef(val.into);
              if (!into) {
                return null;
              }
              const select = val.insert && this.select(val.insert);
              if (!select) {
                return null;
              }
              const returning = arrayNilMap(val.returning, (c) => this.selectionColumn(c));
              let on = (_a = val.onConflict) === null || _a === void 0 ? void 0 : _a.on;
              switch (on === null || on === void 0 ? void 0 : on.type) {
                case "on constraint":
                  break;
                case "on expr":
                  on = assignChanged(on, {
                    exprs: arrayNilMap(on.exprs, (e) => this.expr(e))
                  });
                  break;
                case null:
                case void 0:
                  break;
                default:
                  throw utils_1.NotSupported.never(on);
              }
              let ocdo = (_b = val.onConflict) === null || _b === void 0 ? void 0 : _b.do;
              if (ocdo && ocdo !== "do nothing") {
                const sets = arrayNilMap(ocdo.sets, (x) => this.set(x));
                if (!(sets === null || sets === void 0 ? void 0 : sets.length)) {
                  ocdo = "do nothing";
                } else if (ocdo.sets !== sets) {
                  ocdo = { sets };
                }
              }
              return assignChanged(val, {
                into,
                insert: select,
                returning,
                onConflict: !ocdo ? val.onConflict : assignChanged(val.onConflict, {
                  do: ocdo,
                  on
                })
              });
            }
            raise(val) {
              return assignChanged(val, {
                formatExprs: val.formatExprs && arrayNilMap(val.formatExprs, (x) => this.expr(x)),
                using: val.using && arrayNilMap(val.using, (u) => {
                  return assignChanged(u, {
                    value: this.expr(u.value)
                  });
                })
              });
            }
            delete(val) {
              const from = this.tableRef(val.from);
              if (!from) {
                return null;
              }
              const where = val.where && this.expr(val.where);
              const returning = arrayNilMap(val.returning, (c) => this.selectionColumn(c));
              return assignChanged(val, {
                where,
                returning,
                from
              });
            }
            createSchema(val) {
              return val;
            }
            createTable(val) {
              const columns = arrayNilMap(val.columns, (col) => {
                switch (col.kind) {
                  case "column":
                    return this.createColumn(col);
                  case "like table":
                    return this.likeTable(col);
                  default:
                    throw utils_1.NotSupported.never(col);
                }
              });
              if (!(columns === null || columns === void 0 ? void 0 : columns.length)) {
                return null;
              }
              return assignChanged(val, {
                columns
              });
            }
            likeTable(col) {
              const like = this.tableRef(col.like);
              if (!like) {
                return null;
              }
              return assignChanged(col, { like });
            }
            truncateTable(val) {
              return val;
            }
            constraint(c) {
              switch (c.type) {
                case "not null":
                case "null":
                case "primary key":
                case "unique":
                case "add generated":
                  return c;
                case "default": {
                  const def = this.expr(c.default);
                  if (!def) {
                    return null;
                  }
                  return assignChanged(c, {
                    default: def
                  });
                }
                case "check": {
                  const def = this.expr(c.expr);
                  if (!def) {
                    return null;
                  }
                  return assignChanged(c, {
                    expr: def
                  });
                }
                case "reference": {
                  const foreignTable = this.tableRef(c.foreignTable);
                  if (!foreignTable) {
                    return null;
                  }
                  return assignChanged(c, {
                    foreignTable
                  });
                }
                default:
                  throw utils_1.NotSupported.never(c);
              }
            }
            set(st) {
              const value2 = this.expr(st.value);
              if (!value2) {
                return null;
              }
              return assignChanged(st, {
                value: value2
              });
            }
            // =========================================
            // ================ STUFF ==================
            // =========================================
            /** Called when a data type definition is encountered */
            dataType(dataType) {
              return dataType;
            }
            /** Called when an alias of a table is created */
            tableRef(st) {
              return st;
            }
            transaction(val) {
              return val;
            }
            createExtension(val) {
              return val;
            }
            createIndex(val) {
              const expressions = arrayNilMap(val.expressions, (e) => {
                const expression = this.expr(e.expression);
                if (expression === e.expression) {
                  return e;
                }
                if (!expression) {
                  return null;
                }
                return {
                  ...e,
                  expression
                };
              });
              if (!(expressions === null || expressions === void 0 ? void 0 : expressions.length)) {
                return null;
              }
              return assignChanged(val, {
                expressions
              });
            }
            prepare(st) {
              const statement = this.statement(st.statement);
              if (!statement) {
                return null;
              }
              return assignChanged(st, {
                args: arrayNilMap(st.args, (a) => this.dataType(a)),
                statement
              });
            }
            deallocate(st) {
              return st;
            }
            // =========================================
            // ============== ALTER INDEX ==============
            // =========================================
            alterIndex(st) {
              return st;
            }
            // =========================================
            // ============== ALTER TABLE ==============
            // =========================================
            alterTable(st) {
              var _a;
              const table = this.tableRef(st.table);
              if (!table) {
                return null;
              }
              let changes = [];
              let hasChanged = false;
              for (let i = 0; i < (((_a = st.changes) === null || _a === void 0 ? void 0 : _a.length) || 0); i++) {
                const currentChange = st.changes[i];
                const change = this.tableAlteration(currentChange, st.table);
                hasChanged = hasChanged || change != currentChange;
                if (!!change) {
                  changes.push(change);
                }
              }
              if (!changes.length) {
                return null;
              }
              if (!hasChanged) {
                return st;
              }
              return assignChanged(st, {
                table,
                changes
              });
            }
            tableAlteration(change, table) {
              switch (change.type) {
                case "add column":
                  return this.addColumn(change, table);
                case "add constraint":
                  return this.addConstraint(change, table);
                case "alter column":
                  return this.alterColumn(change, table);
                case "rename":
                  return this.renameTable(change, table);
                case "rename column":
                  return this.renameColumn(change, table);
                case "rename constraint":
                  return this.renameConstraint(change, table);
                case "drop column":
                  return this.dropColumn(change, table);
                case "drop constraint":
                  return this.dropConstraint(change, table);
                case "owner":
                  return this.setTableOwner(change, table);
                default:
                  throw utils_1.NotSupported.never(change);
              }
            }
            dropColumn(change, table) {
              return change;
            }
            dropConstraint(change, table) {
              return change;
            }
            setTableOwner(change, table) {
              return change;
            }
            renameConstraint(change, table) {
              return change;
            }
            renameColumn(change, table) {
              return change;
            }
            renameTable(change, table) {
              return change;
            }
            alterColumn(change, inTable) {
              let alter;
              switch (change.alter.type) {
                case "set default":
                  alter = this.setColumnDefault(change.alter, inTable, change.column);
                  break;
                case "set type":
                  alter = this.setColumnType(change.alter, inTable, change.column);
                  break;
                case "drop default":
                case "set not null":
                case "drop not null":
                  alter = this.alterColumnSimple(change.alter, inTable, change.column);
                  break;
                case "add generated":
                  alter = this.alterColumnAddGenerated(change.alter, inTable, change.column);
                  break;
                default:
                  throw utils_1.NotSupported.never(change.alter);
              }
              if (!alter) {
                return null;
              }
              return assignChanged(change, {
                alter
              });
            }
            setColumnType(alter, inTable, inColumn) {
              const dataType = this.dataType(alter.dataType);
              return assignChanged(alter, {
                dataType
              });
            }
            alterColumnAddGenerated(alter, inTable, inColumn) {
              return alter;
            }
            alterColumnSimple(alter, inTable, inColumn) {
              return alter;
            }
            setColumnDefault(alter, inTable, inColumn) {
              const def = this.expr(alter.default);
              if (!def) {
                return null;
              }
              return assignChanged(alter, {
                default: def
              });
            }
            addConstraint(change, inTable) {
              return change;
            }
            addColumn(change, inTable) {
              const column = this.createColumn(change.column);
              if (!column) {
                return null;
              }
              return assignChanged(change, {
                column
              });
            }
            createColumn(col) {
              var _a;
              const dataType = this.dataType(col.dataType);
              if (!dataType) {
                return null;
              }
              const constraints = (_a = arrayNilMap(col.constraints, (m) => this.constraint(m))) !== null && _a !== void 0 ? _a : void 0;
              return assignChanged(col, {
                dataType,
                constraints
              });
            }
            // =========================================
            // ============== SELECTIONS ==============
            // =========================================
            select(val) {
              switch (val.type) {
                case "select":
                  return this.selection(val);
                case "union":
                case "union all":
                  return this.union(val);
                case "with":
                  return this.with(val);
                case "values":
                  return this.values(val);
                case "with recursive":
                  return this.withRecursive(val);
                default:
                  throw utils_1.NotSupported.never(val);
              }
            }
            selection(val) {
              var _a, _b;
              const from = arrayNilMap(val.from, (c) => this.from(c));
              const columns = arrayNilMap(val.columns, (c) => this.selectionColumn(c));
              const where = val.where && this.expr(val.where);
              const groupBy = arrayNilMap(val.groupBy, (c) => this.expr(c));
              const having = val.having && this.expr(val.having);
              const orderBy = this.orderBy(val.orderBy);
              const limit = assignChanged(val.limit, {
                limit: this.expr((_a = val.limit) === null || _a === void 0 ? void 0 : _a.limit),
                offset: this.expr((_b = val.limit) === null || _b === void 0 ? void 0 : _b.offset)
              });
              return assignChanged(val, {
                from,
                columns,
                where,
                groupBy,
                having,
                orderBy,
                limit
              });
            }
            orderBy(orderBy) {
              return arrayNilMap(orderBy, (c) => {
                const by = this.expr(c.by);
                if (!by) {
                  return null;
                }
                if (by === c.by) {
                  return c;
                }
                return {
                  ...c,
                  by
                };
              });
            }
            union(val) {
              const left = this.select(val.left);
              const right = this.select(val.right);
              if (!left || !right) {
                return left !== null && left !== void 0 ? left : right;
              }
              return assignChanged(val, {
                left,
                right
              });
            }
            with(val) {
              const bind = arrayNilMap(val.bind, (s) => {
                const statement = this.statement(s.statement);
                return withAccepts(statement) ? assignChanged(s, { statement }) : null;
              });
              if (!bind) {
                return null;
              }
              const _in = this.statement(val.in);
              if (!withAccepts(_in)) {
                return null;
              }
              return assignChanged(val, {
                bind,
                in: _in
              });
            }
            withRecursive(val) {
              const statement = this.union(val.bind);
              if (!statement) {
                return null;
              }
              if (statement.type !== "union" && statement.type !== "union all") {
                return null;
              }
              const _in = this.statement(val.in);
              if (!withAccepts(_in)) {
                return null;
              }
              return assignChanged(val, {
                bind: statement,
                in: _in
              });
            }
            from(from) {
              switch (from.type) {
                case "table":
                  return this.fromTable(from);
                case "statement":
                  return this.fromStatement(from);
                case "call":
                  return this.fromCall(from);
                default:
                  throw utils_1.NotSupported.never(from);
              }
            }
            fromCall(from) {
              const call = this.call(from);
              if (!call || call.type !== "call") {
                return null;
              }
              return assignChanged(from, call);
            }
            fromStatement(from) {
              const statement = this.select(from.statement);
              if (!statement) {
                return null;
              }
              const join = from.join && this.join(from.join);
              return assignChanged(from, {
                statement,
                join
              });
            }
            values(from) {
              const values = arrayNilMap(from.values, (x) => arrayNilMap(x, (y) => this.expr(y)));
              if (!(values === null || values === void 0 ? void 0 : values.length)) {
                return null;
              }
              return assignChanged(from, {
                values
              });
            }
            join(join) {
              const on = join.on && this.expr(join.on);
              if (!on && !join.using) {
                return join;
              }
              return assignChanged(join, {
                on
              });
            }
            fromTable(from) {
              const nfrom = this.tableRef(from.name);
              if (!nfrom) {
                return null;
              }
              const join = from.join && this.join(from.join);
              return assignChanged(from, {
                name: nfrom,
                join
              });
            }
            selectionColumn(val) {
              const expr = this.expr(val.expr);
              if (!expr) {
                return null;
              }
              return assignChanged(val, {
                expr
              });
            }
            // =========================================
            // ============== EXPRESSIONS ==============
            // =========================================
            expr(val) {
              if (!val) {
                return val;
              }
              switch (val.type) {
                case "binary":
                  return this.binary(val);
                case "unary":
                  return this.unary(val);
                case "ref":
                  return this.ref(val);
                case "string":
                case "numeric":
                case "integer":
                case "boolean":
                case "constant":
                case "null":
                  return this.constant(val);
                case "list":
                case "array":
                  return this.array(val);
                case "array select":
                  return this.arraySelect(val);
                case "call":
                  return this.call(val);
                case "cast":
                  return this.cast(val);
                case "case":
                  return this.case(val);
                case "member":
                  return this.member(val);
                case "arrayIndex":
                  return this.arrayIndex(val);
                case "ternary":
                  return this.ternary(val);
                case "select":
                case "union":
                case "union all":
                case "with":
                case "with recursive":
                  return this.select(val);
                case "keyword":
                  return this.valueKeyword(val);
                case "parameter":
                  return this.parameter(val);
                case "extract":
                  return this.extract(val);
                case "overlay":
                  return this.callOverlay(val);
                case "substring":
                  return this.callSubstring(val);
                case "values":
                  return this.values(val);
                case "default":
                  return this.default(val);
                default:
                  throw utils_1.NotSupported.never(val);
              }
            }
            arraySelect(val) {
              const select = this.select(val.select);
              if (!select) {
                return null;
              }
              return assignChanged(val, { select });
            }
            extract(st) {
              const from = this.expr(st.from);
              if (!from) {
                return null;
              }
              return assignChanged(st, { from });
            }
            valueKeyword(val) {
              return val;
            }
            ternary(val) {
              const value2 = this.expr(val.value);
              const lo = this.expr(val.lo);
              const hi = this.expr(val.hi);
              if (!value2 || !lo || !hi) {
                return null;
              }
              return assignChanged(val, {
                value: value2,
                lo,
                hi
              });
            }
            parameter(st) {
              return st;
            }
            arrayIndex(val) {
              const array2 = this.expr(val.array);
              const index = this.expr(val.index);
              if (!array2 || !index) {
                return null;
              }
              return assignChanged(val, {
                array: array2,
                index
              });
            }
            member(val) {
              const operand = this.expr(val.operand);
              if (!operand) {
                return null;
              }
              return assignChanged(val, {
                operand
              });
            }
            case(val) {
              const value2 = val.value && this.expr(val.value);
              const whens = arrayNilMap(val.whens, (w) => {
                const when = this.expr(w.when);
                const value3 = this.expr(w.value);
                if (!when || !value3) {
                  return null;
                }
                return assignChanged(w, {
                  value: value3,
                  when
                });
              });
              if (!(whens === null || whens === void 0 ? void 0 : whens.length)) {
                return null;
              }
              const els = val.else && this.expr(val.else);
              return assignChanged(val, {
                value: value2,
                whens,
                else: els
              });
            }
            cast(val) {
              const operand = this.expr(val.operand);
              if (!operand) {
                return null;
              }
              return assignChanged(val, {
                operand
              });
            }
            call(val) {
              const args = arrayNilMap(val.args, (a) => this.expr(a));
              if (!args) {
                return null;
              }
              const orderBy = this.orderBy(val.orderBy);
              const filter = this.expr(val.filter);
              return assignChanged(val, {
                args,
                orderBy,
                filter
              });
            }
            callSubstring(val) {
              return assignChanged(val, {
                value: this.expr(val.value),
                from: this.expr(val.from),
                for: this.expr(val.for)
              });
            }
            callOverlay(val) {
              return assignChanged(val, {
                value: this.expr(val.value),
                placing: this.expr(val.placing),
                from: this.expr(val.from),
                for: this.expr(val.for)
              });
            }
            array(val) {
              const expressions = arrayNilMap(val.expressions, (a) => this.expr(a));
              if (!expressions) {
                return null;
              }
              return assignChanged(val, {
                expressions
              });
            }
            constant(value2) {
              return value2;
            }
            default(value2) {
              return value2;
            }
            /** Called when a reference is used */
            ref(val) {
              return val;
            }
            unary(val) {
              const operand = this.expr(val.operand);
              if (!operand) {
                return null;
              }
              return assignChanged(val, {
                operand
              });
            }
            binary(val) {
              const left = this.expr(val.left);
              const right = this.expr(val.right);
              if (!left || !right) {
                return null;
              }
              return assignChanged(val, {
                left,
                right
              });
            }
          }
          exports2.AstDefaultMapper = AstDefaultMapper;
          const proto = AstDefaultMapper.prototype;
          for (const k of Object.getOwnPropertyNames(proto)) {
            const orig = proto[k];
            if (k === "constructor" || k === "super" || typeof orig !== "function") {
              continue;
            }
            Object.defineProperty(proto, k, {
              configurable: false,
              get() {
                return function(...args) {
                  var _a;
                  if (this.skipNext) {
                    this.skipNext = false;
                    return orig.apply(this, args);
                  }
                  const impl = (_a = this.wrapped) === null || _a === void 0 ? void 0 : _a[k];
                  if (!impl) {
                    return orig.apply(this, args);
                  }
                  return impl.apply(this.wrapped, args);
                };
              }
            });
          }
          class SkipModifier extends AstDefaultMapper {
            constructor(parent) {
              super();
              this.parent = parent;
            }
          }
          for (const k of Object.getOwnPropertyNames(proto)) {
            const orig = proto[k];
            if (k === "constructor" || k === "super" || typeof orig !== "function") {
              continue;
            }
            Object.defineProperty(SkipModifier.prototype, k, {
              configurable: false,
              get() {
                return function(...args) {
                  this.parent.skipNext = true;
                  return orig.apply(this.parent, args);
                };
              }
            });
          }
        },
        /* 3 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.sqlKeywords = void 0;
          exports2.sqlKeywords = [
            "ALL",
            "ANALYSE",
            "ANALYZE",
            "AND",
            "ANY",
            "ARRAY",
            "AS",
            "ASC",
            "ASYMMETRIC",
            "AUTHORIZATION",
            "BINARY",
            "BOTH",
            "CASE",
            "CAST",
            "CHECK",
            "COLLATE",
            "COLLATION",
            "CONCURRENTLY",
            "CONSTRAINT",
            "CREATE",
            "CROSS",
            "CURRENT_CATALOG",
            "CURRENT_DATE",
            "CURRENT_ROLE",
            "CURRENT_SCHEMA",
            "CURRENT_TIME",
            "CURRENT_TIMESTAMP",
            "CURRENT_USER",
            "DEFAULT",
            "DEFERRABLE",
            "DESC",
            "DISTINCT",
            "DO",
            "ELSE",
            "END",
            "EXCEPT",
            "FALSE",
            "FETCH",
            "FOR",
            "FOREIGN",
            "FREEZE",
            "FROM",
            "FULL",
            "GRANT",
            "GROUP",
            "HAVING",
            "ILIKE",
            "IN",
            "INITIALLY",
            "INNER",
            "INTERSECT",
            "INTO",
            "IS",
            "ISNULL",
            "JOIN",
            "LATERAL",
            "LEADING",
            "LEFT",
            "LIKE",
            "LIMIT",
            "LOCALTIME",
            "LOCALTIMESTAMP",
            "NATURAL",
            "NOT",
            "NOTNULL",
            "NULL",
            "OFFSET",
            "ON",
            "ONLY",
            "OR",
            "ORDER",
            "OUTER",
            "OVERLAPS",
            "PLACING",
            "PRIMARY",
            "REFERENCES",
            "RETURNING",
            "RIGHT",
            "SELECT",
            "SESSION_USER",
            "SIMILAR",
            "SOME",
            "SYMMETRIC",
            "TABLE",
            "TABLESAMPLE",
            "THEN",
            "TO",
            "TRAILING",
            "TRUE",
            "UNION",
            "UNIQUE",
            "USER",
            "USING",
            "VARIADIC",
            "VERBOSE",
            "WHEN",
            "WHERE",
            "WINDOW",
            "WITH",
            "PRECISION"
          ];
        },
        /* 4 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.intervalToString = exports2.normalizeInterval = exports2.buildInterval = void 0;
          const types2 = [
            ["years", 12],
            ["months", 30],
            ["days", 24],
            ["hours", 60],
            ["minutes", 60],
            ["seconds", 1e3],
            ["milliseconds", 0]
          ];
          function* unwrap(k) {
            if (typeof k[1] === "number") {
              yield k;
            } else {
              for (const v of k) {
                yield* unwrap(v);
              }
            }
          }
          function buildInterval(orig, vals) {
            var _a;
            const ret = {};
            if (vals === "invalid") {
              throw new Error(`invalid input syntax for type interval: "${orig}"`);
            }
            for (const [k, v] of unwrap(vals)) {
              ret[k] = ((_a = ret[k]) !== null && _a !== void 0 ? _a : 0) + v;
            }
            return ret;
          }
          exports2.buildInterval = buildInterval;
          function normalizeInterval(value2) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const ret = { ...value2 };
            for (let i = 0; i < types2.length; i++) {
              const [k, mul] = types2[i];
              const v = (_a = ret[k]) !== null && _a !== void 0 ? _a : 0;
              const int2 = v >= 0 ? Math.floor(v) : Math.ceil(v);
              if (!v || int2 === v) {
                continue;
              }
              const nk = (_b = types2[i + 1]) === null || _b === void 0 ? void 0 : _b[0];
              if (nk) {
                ret[nk] = ((_c = ret[nk]) !== null && _c !== void 0 ? _c : 0) + mul * (v - int2);
              }
              ret[k] = int2;
            }
            if (ret.months || ret.years) {
              const m = ((_d = ret.months) !== null && _d !== void 0 ? _d : 0) + ((_e = ret.years) !== null && _e !== void 0 ? _e : 0) * 12;
              ret.months = m % 12;
              ret.years = (m - ret.months) / 12;
            }
            let t = ((_f = ret.hours) !== null && _f !== void 0 ? _f : 0) * 3600 + ((_g = ret.minutes) !== null && _g !== void 0 ? _g : 0) * 60 + ((_h = ret.seconds) !== null && _h !== void 0 ? _h : 0) + ((_j = ret.milliseconds) !== null && _j !== void 0 ? _j : 0) / 1e3;
            let sign = 1;
            if (t < 0) {
              sign = -1;
              t = -t;
            }
            if (t >= 3600) {
              ret.hours = sign * Math.floor(t / 3600);
              t -= sign * ret.hours * 3600;
            } else {
              delete ret.hours;
            }
            if (t >= 60) {
              ret.minutes = sign * Math.floor(t / 60);
              t -= sign * ret.minutes * 60;
            } else {
              delete ret.minutes;
            }
            if (t > 0) {
              ret.seconds = sign * Math.floor(t);
              t -= sign * ret.seconds;
            } else {
              delete ret.seconds;
            }
            if (t > 0) {
              ret.milliseconds = sign * Math.round(t * 1e3);
            } else {
              delete ret.milliseconds;
            }
            for (const [k] of types2) {
              if (!ret[k]) {
                delete ret[k];
              }
            }
            return ret;
          }
          exports2.normalizeInterval = normalizeInterval;
          function intervalToString(value2) {
            var _a, _b, _c;
            value2 = normalizeInterval(value2);
            const ret = [];
            if (value2.years) {
              ret.push(value2.years === 1 ? "1 year" : value2.years + " years");
            }
            if (value2.months) {
              ret.push(value2.months === 1 ? "1 month" : value2.months + " months");
            }
            if (value2.days) {
              ret.push(value2.days === 1 ? "1 day" : value2.days + " days");
            }
            if (value2.hours || value2.minutes || value2.seconds || value2.milliseconds) {
              let time = `${num((_a = value2.hours) !== null && _a !== void 0 ? _a : 0)}:${num((_b = value2.minutes) !== null && _b !== void 0 ? _b : 0)}:${num((_c = value2.seconds) !== null && _c !== void 0 ? _c : 0)}`;
              if (value2.milliseconds) {
                time = time + (value2.milliseconds / 1e3).toString().substr(1);
              }
              if (neg2(value2.hours) || neg2(value2.minutes) || neg2(value2.seconds) || neg2(value2.milliseconds)) {
                time = "-" + time;
              }
              ret.push(time);
            }
            return ret.join(" ");
          }
          exports2.intervalToString = intervalToString;
          function num(v) {
            v = Math.abs(v);
            return v < 10 ? "0" + v : v.toString();
          }
          function neg2(v) {
            return v && v < 0;
          }
        },
        /* 5 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.astVisitor = void 0;
          const ast_mapper_1 = __webpack_require__(2);
          class Visitor {
            super() {
              return new SkipVisitor(this);
            }
          }
          const mapperProto = ast_mapper_1.AstDefaultMapper.prototype;
          for (const k of Object.getOwnPropertyNames(mapperProto)) {
            const orig = mapperProto[k];
            if (k === "constructor" || k === "super" || typeof orig !== "function") {
              continue;
            }
            Object.defineProperty(Visitor.prototype, k, {
              configurable: false,
              get() {
                return function(...args) {
                  const impl = this.visitor[k];
                  if (!impl) {
                    return orig.apply(this, args);
                  }
                  impl.apply(this.visitor, args);
                  return args[0];
                };
              }
            });
          }
          class SkipVisitor {
            constructor(parent) {
              this.parent = parent;
            }
          }
          for (const k of Object.getOwnPropertyNames(mapperProto)) {
            const orig = mapperProto[k];
            if (k === "constructor" || k === "super" || typeof orig !== "function") {
              continue;
            }
            Object.defineProperty(SkipVisitor.prototype, k, {
              configurable: false,
              get() {
                return function(...args) {
                  return orig.apply(this.parent, args);
                };
              }
            });
          }
          function astVisitor2(visitorBuilder) {
            return (0, ast_mapper_1.astMapper)((m) => {
              const ret = new Visitor();
              ret.mapper = m;
              ret.visitor = visitorBuilder(ret);
              return ret;
            });
          }
          exports2.astVisitor = astVisitor2;
        },
        /* 6 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.trimNullish = exports2.NotSupported = void 0;
          class NotSupported extends Error {
            constructor(what) {
              super("Not supported" + (what ? ": " + what : ""));
            }
            static never(value2, msg) {
              return new NotSupported(`${msg !== null && msg !== void 0 ? msg : ""} ${JSON.stringify(value2)}`);
            }
          }
          exports2.NotSupported = NotSupported;
          function trimNullish(value2, depth = 5) {
            if (depth < 0)
              return value2;
            if (value2 instanceof Array) {
              value2.forEach((x) => trimNullish(x, depth - 1));
            }
            if (typeof value2 !== "object" || value2 instanceof Date)
              return value2;
            if (!value2) {
              return value2;
            }
            for (const k of Object.keys(value2)) {
              const val = value2[k];
              if (val === void 0 || val === null)
                delete value2[k];
              else
                trimNullish(val, depth - 1);
            }
            return value2;
          }
          exports2.trimNullish = trimNullish;
        },
        /* 7 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = { enumerable: true, get: function() {
                return m[k];
              } };
            }
            Object.defineProperty(o, k2, desc);
          } : function(o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
          var __exportStar = this && this.__exportStar || function(m, exports3) {
            for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.normalizeInterval = exports2.intervalToString = exports2.toSql = exports2.astMapper = exports2.assignChanged = exports2.arrayNilMap = exports2.astVisitor = exports2.parseWithComments = exports2.parseIntervalLiteral = exports2.parseGeometricLiteral = exports2.parseArrayLiteral = exports2.parseFirst = exports2.parse = void 0;
          var parser_1 = __webpack_require__(8);
          Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
            return parser_1.parse;
          } });
          Object.defineProperty(exports2, "parseFirst", { enumerable: true, get: function() {
            return parser_1.parseFirst;
          } });
          Object.defineProperty(exports2, "parseArrayLiteral", { enumerable: true, get: function() {
            return parser_1.parseArrayLiteral;
          } });
          Object.defineProperty(exports2, "parseGeometricLiteral", { enumerable: true, get: function() {
            return parser_1.parseGeometricLiteral;
          } });
          Object.defineProperty(exports2, "parseIntervalLiteral", { enumerable: true, get: function() {
            return parser_1.parseIntervalLiteral;
          } });
          Object.defineProperty(exports2, "parseWithComments", { enumerable: true, get: function() {
            return parser_1.parseWithComments;
          } });
          var ast_visitor_1 = __webpack_require__(5);
          Object.defineProperty(exports2, "astVisitor", { enumerable: true, get: function() {
            return ast_visitor_1.astVisitor;
          } });
          var ast_mapper_1 = __webpack_require__(2);
          Object.defineProperty(exports2, "arrayNilMap", { enumerable: true, get: function() {
            return ast_mapper_1.arrayNilMap;
          } });
          Object.defineProperty(exports2, "assignChanged", { enumerable: true, get: function() {
            return ast_mapper_1.assignChanged;
          } });
          Object.defineProperty(exports2, "astMapper", { enumerable: true, get: function() {
            return ast_mapper_1.astMapper;
          } });
          var to_sql_1 = __webpack_require__(19);
          Object.defineProperty(exports2, "toSql", { enumerable: true, get: function() {
            return to_sql_1.toSql;
          } });
          __exportStar(__webpack_require__(21), exports2);
          var interval_builder_1 = __webpack_require__(4);
          Object.defineProperty(exports2, "intervalToString", { enumerable: true, get: function() {
            return interval_builder_1.intervalToString;
          } });
          Object.defineProperty(exports2, "normalizeInterval", { enumerable: true, get: function() {
            return interval_builder_1.normalizeInterval;
          } });
        },
        /* 8 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.parseGeometricLiteral = exports2.parseIntervalLiteral = exports2.parseArrayLiteral = exports2.parse = exports2.parseWithComments = exports2.parseFirst = void 0;
          const nearley_1 = __webpack_require__(9);
          const main_ne_1 = __importDefault(__webpack_require__(10));
          const array_ne_1 = __importDefault(__webpack_require__(11));
          const geometric_ne_1 = __importDefault(__webpack_require__(13));
          const interval_ne_1 = __importDefault(__webpack_require__(15));
          const interval_iso_ne_1 = __importDefault(__webpack_require__(17));
          const interval_builder_1 = __webpack_require__(4);
          const lexer_1 = __webpack_require__(1);
          let sqlCompiled;
          let arrayCompiled;
          let geometricCompiled;
          let intervalTextCompiled;
          let intervalIsoCompiled;
          function parseFirst8(sql) {
            const first = parse3(sql);
            return first[0];
          }
          exports2.parseFirst = parseFirst8;
          function parseWithComments(sql, options) {
            return (0, lexer_1.trackingComments)(() => parse3(sql, options));
          }
          exports2.parseWithComments = parseWithComments;
          function parse3(sql, optEntry) {
            if (!sqlCompiled) {
              sqlCompiled = nearley_1.Grammar.fromCompiled(main_ne_1.default);
            }
            const entry = typeof optEntry === "string" ? optEntry : optEntry === null || optEntry === void 0 ? void 0 : optEntry.entry;
            const opts = typeof optEntry === "string" ? null : optEntry;
            const doParse = () => _parse(sql, sqlCompiled, entry);
            let parsed = (opts === null || opts === void 0 ? void 0 : opts.locationTracking) ? (0, lexer_1.tracking)(doParse) : doParse();
            if (typeof optEntry !== "string" && !Array.isArray(parsed)) {
              parsed = [parsed];
            }
            return parsed;
          }
          exports2.parse = parse3;
          function parseArrayLiteral(sql) {
            if (!arrayCompiled) {
              arrayCompiled = nearley_1.Grammar.fromCompiled(array_ne_1.default);
            }
            return _parse(sql, arrayCompiled);
          }
          exports2.parseArrayLiteral = parseArrayLiteral;
          function parseIntervalLiteral(literal) {
            if (literal.startsWith("P")) {
              if (!intervalIsoCompiled) {
                intervalIsoCompiled = nearley_1.Grammar.fromCompiled(interval_iso_ne_1.default);
              }
              return (0, interval_builder_1.buildInterval)(literal, _parse(literal, intervalIsoCompiled));
            } else {
              if (!intervalTextCompiled) {
                intervalTextCompiled = nearley_1.Grammar.fromCompiled(interval_ne_1.default);
              }
              const low = literal.toLowerCase();
              return (0, interval_builder_1.buildInterval)(literal, _parse(low, intervalTextCompiled));
            }
          }
          exports2.parseIntervalLiteral = parseIntervalLiteral;
          function parseGeometricLiteral(sql, type) {
            if (!geometricCompiled) {
              geometricCompiled = nearley_1.Grammar.fromCompiled(geometric_ne_1.default);
            }
            return _parse(sql, geometricCompiled, type);
          }
          exports2.parseGeometricLiteral = parseGeometricLiteral;
          function _parse(sql, grammar, entry) {
            try {
              grammar.start = entry !== null && entry !== void 0 ? entry : "main";
              const parser = new nearley_1.Parser(grammar);
              parser.feed(sql);
              const asts = parser.finish();
              if (!asts.length) {
                throw new Error("Unexpected end of input");
              } else if (asts.length !== 1) {
                throw new Error(`\u{1F480} Ambiguous SQL syntax: Please file an issue stating the request that has failed at https://github.com/oguimbal/pgsql-ast-parser:

        ${sql}

        `);
              }
              return asts[0];
            } catch (e) {
              if (typeof (e === null || e === void 0 ? void 0 : e.message) !== "string") {
                throw e;
              }
              let msg = e.message;
              let begin = null;
              const parts = [];
              const reg = /A (.+) token based on:/g;
              let m;
              while (m = reg.exec(msg)) {
                begin = begin !== null && begin !== void 0 ? begin : msg.substr(0, m.index);
                parts.push(`    - A "${m[1]}" token`);
              }
              if (begin) {
                msg = begin + parts.join("\n") + "\n\n";
              }
              e.message = msg;
              throw e;
            }
          }
        },
        /* 9 */
        /***/
        function(module2, exports2) {
          module2.exports = require_nearley();
        },
        /* 10 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function id(d) {
            return d[0];
          }
          const lexer_1 = __webpack_require__(1);
          const lexer_2 = __webpack_require__(1);
          function debug(fn) {
            fn = fn || ((x) => x);
            return (x, ...args) => {
              debugger;
              return fn(x, ...args);
            };
          }
          function asName(val) {
            return asNameWithColumns(val, void 0);
          }
          function asNameWithColumns(val, columns) {
            const name2 = toStr(val);
            if (!columns || columns.length === 0) {
              return (0, lexer_2.track)(val, { name: name2 });
            }
            return (0, lexer_2.track)(val, {
              name: name2,
              columns: columns.map((c) => ({ name: toStr(c) }))
            });
          }
          function asLit(val) {
            const value3 = toStr(val);
            return (0, lexer_2.track)(val, { value: value3 });
          }
          function unwrap(e) {
            if (Array.isArray(e) && e.length === 1) {
              e = unwrap(e[0]);
            }
            if (Array.isArray(e) && !e.length) {
              return null;
            }
            return (0, lexer_2.unbox)(e);
          }
          const get2 = (i) => (x) => (0, lexer_2.track)(x, x[i]);
          const last = (x) => Array.isArray(x) ? (0, lexer_2.track)(x[x.length - 1], x[x.length - 1]) : x;
          const trim = (x) => x && x.trim();
          const value2 = (x) => x && x.value;
          function flatten(e) {
            if (Array.isArray(e)) {
              const ret = [];
              for (const i of e) {
                ret.push(...flatten(i));
              }
              return ret;
            }
            if (!e) {
              return [];
            }
            return [e];
          }
          function asStr(value3) {
            var _a;
            value3 = (0, lexer_2.unbox)(value3);
            return (_a = value3 === null || value3 === void 0 ? void 0 : value3.value) !== null && _a !== void 0 ? _a : value3;
          }
          function flattenStr(e) {
            const fl = flatten((0, lexer_2.unbox)(e));
            return fl.filter((x) => !!x).map((x) => asStr(x)).filter((x) => typeof x === "string").map((x) => x.trim()).filter((x) => !!x);
          }
          function toStr(e, join) {
            return flattenStr(e).join(join || "");
          }
          function fromEntries(vals) {
            const ret = {};
            for (const [k, v] of vals) {
              ret[k] = v;
            }
            return ret;
          }
          const kwSensitivity = { sensitivity: "accent" };
          const eqInsensitive = (a, b) => a.localeCompare(b, void 0, kwSensitivity) === 0;
          const notReservedKw = (kw2) => (x, _, rej) => {
            const val = asStr(x[0]);
            if (eqInsensitive(val, kw2)) {
              return (0, lexer_2.box)(x, kw2);
            }
            return rej;
          };
          const kw = notReservedKw;
          const anyKw = (...kw2) => {
            const kwSet = new Set(kw2);
            return (x, _, rej) => {
              const val = typeof x[0] === "string" ? x[0] : x[0].value;
              return kwSet.has(val) ? val : rej;
            };
          };
          function setSeqOpts(ret, opts) {
            const defs = /* @__PURE__ */ new Set();
            const unboxed = opts.map(lexer_2.unbox);
            for (const [k, v] of unboxed) {
              if (defs.has(k)) {
                throw new Error("conflicting or redundant options");
              }
              defs.add(k);
              ret[k] = (0, lexer_2.unbox)(v);
            }
          }
          ;
          ;
          ;
          ;
          const grammar = {
            Lexer: lexer_1.lexerAny,
            ParserRules: [
              { "name": "lparen", "symbols": [lexer_1.lexerAny.has("lparen") ? { type: "lparen" } : lparen] },
              { "name": "rparen", "symbols": [lexer_1.lexerAny.has("rparen") ? { type: "rparen" } : rparen] },
              { "name": "number$subexpression$1", "symbols": ["float"] },
              { "name": "number$subexpression$1", "symbols": ["int"] },
              { "name": "number", "symbols": ["number$subexpression$1"], "postprocess": unwrap },
              { "name": "dot", "symbols": [lexer_1.lexerAny.has("dot") ? { type: "dot" } : dot], "postprocess": id },
              { "name": "float", "symbols": [lexer_1.lexerAny.has("float") ? { type: "float" } : float], "postprocess": (x) => (0, lexer_2.box)(x, parseFloat(unwrap(x))) },
              { "name": "int", "symbols": [lexer_1.lexerAny.has("int") ? { type: "int" } : int], "postprocess": (x) => (0, lexer_2.box)(x, parseInt(unwrap(x), 10)) },
              { "name": "comma", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma], "postprocess": id },
              { "name": "star", "symbols": [lexer_1.lexerAny.has("star") ? { type: "star" } : star], "postprocess": (x) => (0, lexer_2.box)(x, x[0].value) },
              { "name": "string$subexpression$1", "symbols": [lexer_1.lexerAny.has("string") ? { type: "string" } : string] },
              { "name": "string$subexpression$1", "symbols": [lexer_1.lexerAny.has("eString") ? { type: "eString" } : eString] },
              { "name": "string", "symbols": ["string$subexpression$1"], "postprocess": (x) => (0, lexer_2.box)(x, unwrap(x[0]).value) },
              { "name": "ident", "symbols": ["word"], "postprocess": get2(0) },
              { "name": "word", "symbols": [lexer_1.lexerAny.has("kw_primary") ? { type: "kw_primary" } : kw_primary], "postprocess": (x) => (0, lexer_2.box)(x, "primary") },
              { "name": "word", "symbols": [lexer_1.lexerAny.has("kw_unique") ? { type: "kw_unique" } : kw_unique], "postprocess": (x) => (0, lexer_2.box)(x, "unique") },
              { "name": "word", "symbols": [lexer_1.lexerAny.has("quoted_word") ? { type: "quoted_word" } : quoted_word], "postprocess": (x) => (0, lexer_2.box)(x, x[0].value, true) },
              { "name": "word", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": (x) => (0, lexer_2.box)(x, x[0].value) },
              { "name": "collist_paren", "symbols": ["lparen", "collist", "rparen"], "postprocess": get2(1) },
              { "name": "collist$ebnf$1", "symbols": [] },
              { "name": "collist$ebnf$1$subexpression$1", "symbols": ["comma", "ident"], "postprocess": last },
              { "name": "collist$ebnf$1", "symbols": ["collist$ebnf$1", "collist$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "collist", "symbols": ["ident", "collist$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "kw_between", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("between") },
              { "name": "kw_conflict", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("conflict") },
              { "name": "kw_nothing", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("nothing") },
              { "name": "kw_begin", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("begin") },
              { "name": "kw_if", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("if") },
              { "name": "kw_exists", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("exists") },
              { "name": "kw_key", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("key") },
              { "name": "kw_index", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("index") },
              { "name": "kw_extension", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("extension") },
              { "name": "kw_schema", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("schema") },
              { "name": "kw_nulls", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("nulls") },
              { "name": "kw_first", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("first") },
              { "name": "kw_last", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("last") },
              { "name": "kw_start", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("start") },
              { "name": "kw_restart", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("restart") },
              { "name": "kw_filter", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("filter") },
              { "name": "kw_commit", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("commit") },
              { "name": "kw_tablespace", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("tablespace") },
              { "name": "kw_transaction", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("transaction") },
              { "name": "kw_work", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("work") },
              { "name": "kw_read", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("read") },
              { "name": "kw_write", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("write") },
              { "name": "kw_isolation", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("isolation") },
              { "name": "kw_level", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("level") },
              { "name": "kw_serializable", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("serializable") },
              { "name": "kw_rollback", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("rollback") },
              { "name": "kw_insert", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("insert") },
              { "name": "kw_value", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("value") },
              { "name": "kw_values", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("values") },
              { "name": "kw_update", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("update") },
              { "name": "kw_column", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("column") },
              { "name": "kw_set", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("set") },
              { "name": "kw_version", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("version") },
              { "name": "kw_alter", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("alter") },
              { "name": "kw_rename", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("rename") },
              { "name": "kw_sequence", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("sequence") },
              { "name": "kw_temp", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("temp") },
              { "name": "kw_temporary", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("temporary") },
              { "name": "kw_add", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("add") },
              { "name": "kw_owner", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("owner") },
              { "name": "kw_owned", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("owned") },
              { "name": "kw_including", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("including") },
              { "name": "kw_excluding", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("excluding") },
              { "name": "kw_none", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("none") },
              { "name": "kw_drop", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("drop") },
              { "name": "kw_operator", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("operator") },
              { "name": "kw_minvalue", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("minvalue") },
              { "name": "kw_maxvalue", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("maxvalue") },
              { "name": "kw_data", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("data") },
              { "name": "kw_type", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("type") },
              { "name": "kw_trigger", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("trigger") },
              { "name": "kw_delete", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("delete") },
              { "name": "kw_cache", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("cache") },
              { "name": "kw_cascade", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("cascade") },
              { "name": "kw_no", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("no") },
              { "name": "kw_timestamp", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("timestamp") },
              { "name": "kw_cycle", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("cycle") },
              { "name": "kw_function", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("function") },
              { "name": "kw_returns", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("returns") },
              { "name": "kw_language", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("language") },
              { "name": "kw_out", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("out") },
              { "name": "kw_inout", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("inout") },
              { "name": "kw_variadic", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("variadic") },
              { "name": "kw_action", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("action") },
              { "name": "kw_restrict", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("restrict") },
              { "name": "kw_truncate", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("truncate") },
              { "name": "kw_increment", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("increment") },
              { "name": "kw_by", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("by") },
              { "name": "kw_row", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("row") },
              { "name": "kw_rows", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("rows") },
              { "name": "kw_next", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("next") },
              { "name": "kw_match", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("match") },
              { "name": "kw_replace", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("replace") },
              { "name": "kw_recursive", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("recursive") },
              { "name": "kw_view", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("view") },
              { "name": "kw_cascaded", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("cascaded") },
              { "name": "kw_unlogged", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("unlogged") },
              { "name": "kw_global", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("global") },
              { "name": "kw_option", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("option") },
              { "name": "kw_materialized", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("materialized") },
              { "name": "kw_partial", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("partial") },
              { "name": "kw_partition", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("partition") },
              { "name": "kw_simple", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("simple") },
              { "name": "kw_generated", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("generated") },
              { "name": "kw_always", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("always") },
              { "name": "kw_identity", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("identity") },
              { "name": "kw_name", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("name") },
              { "name": "kw_enum", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("enum") },
              { "name": "kw_show", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("show") },
              { "name": "kw_ordinality", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("ordinality") },
              { "name": "kw_overriding", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("overriding") },
              { "name": "kw_over", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("over") },
              { "name": "kw_system", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("system") },
              { "name": "kw_comment", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("comment") },
              { "name": "kw_time", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("time") },
              { "name": "kw_at", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("at") },
              { "name": "kw_zone", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("zone") },
              { "name": "kw_interval", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("interval") },
              { "name": "kw_hour", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("hour") },
              { "name": "kw_minute", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("minute") },
              { "name": "kw_local", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("local") },
              { "name": "kw_prepare", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("prepare") },
              { "name": "kw_deallocate", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("deallocate") },
              { "name": "kw_raise", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("raise") },
              { "name": "kw_continue", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("continue") },
              { "name": "kw_share", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("share") },
              { "name": "kw_refresh", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("refresh") },
              { "name": "kw_nowait", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("nowait") },
              { "name": "kw_skip", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("skip") },
              { "name": "kw_locked", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("locked") },
              { "name": "kw_ifnotexists", "symbols": ["kw_if", lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not, "kw_exists"] },
              { "name": "kw_ifexists", "symbols": ["kw_if", "kw_exists"] },
              { "name": "kw_withordinality", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "kw_ordinality"] },
              { "name": "kw_not_null", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not, lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null] },
              { "name": "kw_primary_key", "symbols": [lexer_1.lexerAny.has("kw_primary") ? { type: "kw_primary" } : kw_primary, "kw_key"] },
              { "name": "data_type$ebnf$1$subexpression$1$macrocall$2", "symbols": ["int"] },
              { "name": "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "data_type$ebnf$1$subexpression$1$macrocall$2"], "postprocess": last },
              { "name": "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1", "symbols": ["data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1", "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "data_type$ebnf$1$subexpression$1$macrocall$1", "symbols": ["data_type$ebnf$1$subexpression$1$macrocall$2", "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "data_type$ebnf$1$subexpression$1", "symbols": ["lparen", "data_type$ebnf$1$subexpression$1$macrocall$1", "rparen"], "postprocess": get2(1) },
              { "name": "data_type$ebnf$1", "symbols": ["data_type$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "data_type$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "data_type$ebnf$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_array") ? { type: "kw_array" } : kw_array] },
              { "name": "data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("lbracket") ? { type: "lbracket" } : lbracket, lexer_1.lexerAny.has("rbracket") ? { type: "rbracket" } : rbracket] },
              { "name": "data_type$ebnf$2$subexpression$1$ebnf$1", "symbols": ["data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$1"] },
              { "name": "data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$2", "symbols": [lexer_1.lexerAny.has("lbracket") ? { type: "lbracket" } : lbracket, lexer_1.lexerAny.has("rbracket") ? { type: "rbracket" } : rbracket] },
              { "name": "data_type$ebnf$2$subexpression$1$ebnf$1", "symbols": ["data_type$ebnf$2$subexpression$1$ebnf$1", "data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "data_type$ebnf$2$subexpression$1", "symbols": ["data_type$ebnf$2$subexpression$1$ebnf$1"] },
              { "name": "data_type$ebnf$2", "symbols": ["data_type$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "data_type$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "data_type", "symbols": ["data_type_simple", "data_type$ebnf$1", "data_type$ebnf$2"], "postprocess": (x) => {
                let asArray = x[2];
                const name2 = unwrap(x[0]);
                let ret;
                ret = {
                  ...name2,
                  ...Array.isArray(x[1]) && x[1].length ? { config: x[1].map(unwrap) } : {}
                };
                if (asArray) {
                  if (asArray[0].type === "kw_array") {
                    asArray = [["array"]];
                  }
                  for (const _ of asArray[0]) {
                    ret = {
                      kind: "array",
                      arrayOf: ret
                    };
                  }
                }
                return (0, lexer_2.track)(x, ret);
              } },
              { "name": "data_type_list$ebnf$1", "symbols": [] },
              { "name": "data_type_list$ebnf$1$subexpression$1", "symbols": ["comma", "data_type"], "postprocess": last },
              { "name": "data_type_list$ebnf$1", "symbols": ["data_type_list$ebnf$1", "data_type_list$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "data_type_list", "symbols": ["data_type", "data_type_list$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "data_type_simple", "symbols": ["data_type_text"], "postprocess": (x) => (0, lexer_2.track)(x, { name: toStr(x, " ") }) },
              { "name": "data_type_simple", "symbols": ["data_type_numeric"], "postprocess": (x) => (0, lexer_2.track)(x, { name: toStr(x, " ") }) },
              { "name": "data_type_simple", "symbols": ["data_type_date"] },
              { "name": "data_type_simple", "symbols": ["qualified_name_mark_quotes"] },
              { "name": "data_type_numeric$subexpression$1", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("double") },
              { "name": "data_type_numeric", "symbols": ["data_type_numeric$subexpression$1", lexer_1.lexerAny.has("kw_precision") ? { type: "kw_precision" } : kw_precision] },
              { "name": "data_type_text$subexpression$1", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": anyKw("character", "bit") },
              { "name": "data_type_text$subexpression$2", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("varying") },
              { "name": "data_type_text", "symbols": ["data_type_text$subexpression$1", "data_type_text$subexpression$2"] },
              { "name": "data_type_date$subexpression$1", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": anyKw("timestamp", "time") },
              { "name": "data_type_date$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with] },
              { "name": "data_type_date$subexpression$2", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("without") },
              { "name": "data_type_date$subexpression$3", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("time") },
              { "name": "data_type_date$subexpression$4", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("zone") },
              { "name": "data_type_date", "symbols": ["data_type_date$subexpression$1", "data_type_date$subexpression$2", "data_type_date$subexpression$3", "data_type_date$subexpression$4"], "postprocess": (x) => (0, lexer_2.track)(x, { name: toStr(x, " ") }) },
              { "name": "data_type_date$subexpression$5", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": anyKw("timestamp", "time") },
              { "name": "data_type_date$subexpression$6", "symbols": ["lparen", "int", "rparen"], "postprocess": get2(1) },
              { "name": "data_type_date$subexpression$7", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with] },
              { "name": "data_type_date$subexpression$7", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("without") },
              { "name": "data_type_date$subexpression$8", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("time") },
              { "name": "data_type_date$subexpression$9", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("zone") },
              { "name": "data_type_date", "symbols": ["data_type_date$subexpression$5", "data_type_date$subexpression$6", "data_type_date$subexpression$7", "data_type_date$subexpression$8", "data_type_date$subexpression$9"], "postprocess": (x) => (0, lexer_2.track)(x, { name: `timestamp ${toStr(x[2])} time zone`, config: [(0, lexer_2.unbox)(x[1])] }) },
              { "name": "ident_aliased$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "ident"], "postprocess": last },
              { "name": "ident_aliased", "symbols": ["ident_aliased$subexpression$1"] },
              { "name": "ident_aliased", "symbols": ["ident"], "postprocess": unwrap },
              { "name": "table_ref", "symbols": ["qualified_name"], "postprocess": unwrap },
              { "name": "qcolumn$ebnf$1$subexpression$1", "symbols": ["dot", "ident"], "postprocess": last },
              { "name": "qcolumn$ebnf$1", "symbols": ["qcolumn$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "qcolumn$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "qcolumn", "symbols": ["ident", "dot", "ident", "qcolumn$ebnf$1"], "postprocess": (x) => {
                if (!x[3]) {
                  return (0, lexer_2.track)(x, {
                    table: (0, lexer_2.unbox)(x[0]),
                    column: (0, lexer_2.unbox)(x[2])
                  });
                }
                return (0, lexer_2.track)(x, {
                  schema: (0, lexer_2.unbox)(x[0]),
                  table: (0, lexer_2.unbox)(x[2]),
                  column: (0, lexer_2.unbox)(x[3])
                });
              } },
              { "name": "table_ref_aliased$ebnf$1", "symbols": ["ident_aliased"], "postprocess": id },
              { "name": "table_ref_aliased$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "table_ref_aliased", "symbols": ["table_ref", "table_ref_aliased$ebnf$1"], "postprocess": (x) => {
                const alias = unwrap(x[1]);
                return (0, lexer_2.track)(x, {
                  ...unwrap(x[0]),
                  ...alias ? { alias } : {}
                });
              } },
              { "name": "qualified_name", "symbols": ["qname_ident"], "postprocess": (x) => (0, lexer_2.track)(x, { name: toStr(x) }) },
              { "name": "qualified_name", "symbols": ["ident", "dot", "ident_extended"], "postprocess": (x) => {
                const schema = toStr(x[0]);
                const name2 = toStr(x[2]);
                return (0, lexer_2.track)(x, { schema, name: name2 });
              } },
              { "name": "qualified_name", "symbols": [lexer_1.lexerAny.has("kw_current_schema") ? { type: "kw_current_schema" } : kw_current_schema], "postprocess": (x) => (0, lexer_2.track)(x, { name: "current_schema" }) },
              { "name": "qualified_name_mark_quotes", "symbols": ["qname_ident"], "postprocess": (x) => (0, lexer_2.track)(x, { name: toStr(x), ...(0, lexer_2.doubleQuoted)(x) }) },
              { "name": "qualified_name_mark_quotes", "symbols": ["ident", "dot", "ident_extended"], "postprocess": (x) => {
                const schema = toStr(x[0]);
                const name2 = toStr(x[2]);
                return (0, lexer_2.track)(x, { schema, name: name2, ...(0, lexer_2.doubleQuoted)(x[2]) });
              } },
              { "name": "qualified_name_mark_quotes", "symbols": [lexer_1.lexerAny.has("kw_current_schema") ? { type: "kw_current_schema" } : kw_current_schema], "postprocess": (x) => (0, lexer_2.track)(x, { name: "current_schema" }) },
              { "name": "qname_ident", "symbols": ["ident"] },
              { "name": "qname_ident", "symbols": [lexer_1.lexerAny.has("kw_precision") ? { type: "kw_precision" } : kw_precision] },
              { "name": "qname", "symbols": ["qualified_name"], "postprocess": unwrap },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_all") ? { type: "kw_all" } : kw_all] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_analyse") ? { type: "kw_analyse" } : kw_analyse] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_analyze") ? { type: "kw_analyze" } : kw_analyze] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_and") ? { type: "kw_and" } : kw_and] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_any") ? { type: "kw_any" } : kw_any] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_array") ? { type: "kw_array" } : kw_array] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_asc") ? { type: "kw_asc" } : kw_asc] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_asymmetric") ? { type: "kw_asymmetric" } : kw_asymmetric] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_authorization") ? { type: "kw_authorization" } : kw_authorization] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_binary") ? { type: "kw_binary" } : kw_binary] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_both") ? { type: "kw_both" } : kw_both] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_case") ? { type: "kw_case" } : kw_case] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_cast") ? { type: "kw_cast" } : kw_cast] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_check") ? { type: "kw_check" } : kw_check] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_collate") ? { type: "kw_collate" } : kw_collate] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_collation") ? { type: "kw_collation" } : kw_collation] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_concurrently") ? { type: "kw_concurrently" } : kw_concurrently] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_constraint") ? { type: "kw_constraint" } : kw_constraint] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_cross") ? { type: "kw_cross" } : kw_cross] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_catalog") ? { type: "kw_current_catalog" } : kw_current_catalog] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_date") ? { type: "kw_current_date" } : kw_current_date] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_role") ? { type: "kw_current_role" } : kw_current_role] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_schema") ? { type: "kw_current_schema" } : kw_current_schema] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_time") ? { type: "kw_current_time" } : kw_current_time] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_timestamp") ? { type: "kw_current_timestamp" } : kw_current_timestamp] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_user") ? { type: "kw_current_user" } : kw_current_user] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_deferrable") ? { type: "kw_deferrable" } : kw_deferrable] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_desc") ? { type: "kw_desc" } : kw_desc] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_distinct") ? { type: "kw_distinct" } : kw_distinct] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_do") ? { type: "kw_do" } : kw_do] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_else") ? { type: "kw_else" } : kw_else] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_end") ? { type: "kw_end" } : kw_end] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_except") ? { type: "kw_except" } : kw_except] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_false") ? { type: "kw_false" } : kw_false] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_fetch") ? { type: "kw_fetch" } : kw_fetch] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_for") ? { type: "kw_for" } : kw_for] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_foreign") ? { type: "kw_foreign" } : kw_foreign] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_freeze") ? { type: "kw_freeze" } : kw_freeze] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_full") ? { type: "kw_full" } : kw_full] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_grant") ? { type: "kw_grant" } : kw_grant] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_group") ? { type: "kw_group" } : kw_group] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_having") ? { type: "kw_having" } : kw_having] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_ilike") ? { type: "kw_ilike" } : kw_ilike] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_in") ? { type: "kw_in" } : kw_in] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_initially") ? { type: "kw_initially" } : kw_initially] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_inner") ? { type: "kw_inner" } : kw_inner] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_intersect") ? { type: "kw_intersect" } : kw_intersect] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_into") ? { type: "kw_into" } : kw_into] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_is") ? { type: "kw_is" } : kw_is] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_isnull") ? { type: "kw_isnull" } : kw_isnull] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_join") ? { type: "kw_join" } : kw_join] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_lateral") ? { type: "kw_lateral" } : kw_lateral] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_leading") ? { type: "kw_leading" } : kw_leading] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_left") ? { type: "kw_left" } : kw_left] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_like") ? { type: "kw_like" } : kw_like] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_limit") ? { type: "kw_limit" } : kw_limit] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_localtime") ? { type: "kw_localtime" } : kw_localtime] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_localtimestamp") ? { type: "kw_localtimestamp" } : kw_localtimestamp] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_natural") ? { type: "kw_natural" } : kw_natural] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_notnull") ? { type: "kw_notnull" } : kw_notnull] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_offset") ? { type: "kw_offset" } : kw_offset] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_only") ? { type: "kw_only" } : kw_only] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_or") ? { type: "kw_or" } : kw_or] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_order") ? { type: "kw_order" } : kw_order] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_outer") ? { type: "kw_outer" } : kw_outer] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_overlaps") ? { type: "kw_overlaps" } : kw_overlaps] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_placing") ? { type: "kw_placing" } : kw_placing] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_primary") ? { type: "kw_primary" } : kw_primary] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_references") ? { type: "kw_references" } : kw_references] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_returning") ? { type: "kw_returning" } : kw_returning] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_right") ? { type: "kw_right" } : kw_right] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_select") ? { type: "kw_select" } : kw_select] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_session_user") ? { type: "kw_session_user" } : kw_session_user] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_similar") ? { type: "kw_similar" } : kw_similar] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_some") ? { type: "kw_some" } : kw_some] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_symmetric") ? { type: "kw_symmetric" } : kw_symmetric] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_tablesample") ? { type: "kw_tablesample" } : kw_tablesample] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_then") ? { type: "kw_then" } : kw_then] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_trailing") ? { type: "kw_trailing" } : kw_trailing] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_true") ? { type: "kw_true" } : kw_true] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_union") ? { type: "kw_union" } : kw_union] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_unique") ? { type: "kw_unique" } : kw_unique] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_user") ? { type: "kw_user" } : kw_user] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_using") ? { type: "kw_using" } : kw_using] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_variadic") ? { type: "kw_variadic" } : kw_variadic] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_verbose") ? { type: "kw_verbose" } : kw_verbose] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_when") ? { type: "kw_when" } : kw_when] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_where") ? { type: "kw_where" } : kw_where] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_window") ? { type: "kw_window" } : kw_window] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with] },
              { "name": "ident_extended", "symbols": ["ident"] },
              { "name": "ident_extended", "symbols": ["any_keyword"] },
              { "name": "select_statement$ebnf$1", "symbols": ["select_from"], "postprocess": id },
              { "name": "select_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_statement$ebnf$2", "symbols": ["select_where"], "postprocess": id },
              { "name": "select_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "select_statement$ebnf$3$subexpression$1$ebnf$1", "symbols": ["select_having"], "postprocess": id },
              { "name": "select_statement$ebnf$3$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_statement$ebnf$3$subexpression$1", "symbols": ["select_groupby", "select_statement$ebnf$3$subexpression$1$ebnf$1"] },
              { "name": "select_statement$ebnf$3", "symbols": ["select_statement$ebnf$3$subexpression$1"], "postprocess": id },
              { "name": "select_statement$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "select_statement$ebnf$4", "symbols": ["select_order_by"], "postprocess": id },
              { "name": "select_statement$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "select_statement$ebnf$5", "symbols": ["select_limit_offset"], "postprocess": id },
              { "name": "select_statement$ebnf$5", "symbols": [], "postprocess": () => null },
              { "name": "select_statement$ebnf$6$subexpression$1$ebnf$1", "symbols": ["select_skip"], "postprocess": id },
              { "name": "select_statement$ebnf$6$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_statement$ebnf$6$subexpression$1", "symbols": ["select_for", "select_statement$ebnf$6$subexpression$1$ebnf$1"] },
              { "name": "select_statement$ebnf$6", "symbols": ["select_statement$ebnf$6$subexpression$1"], "postprocess": id },
              { "name": "select_statement$ebnf$6", "symbols": [], "postprocess": () => null },
              { "name": "select_statement", "symbols": ["select_what", "select_statement$ebnf$1", "select_statement$ebnf$2", "select_statement$ebnf$3", "select_statement$ebnf$4", "select_statement$ebnf$5", "select_statement$ebnf$6"], "postprocess": (x) => {
                let [what, from, where, _groupBy, orderBy, limit, _selectFor] = x;
                from = unwrap(from);
                let groupBy = _groupBy && _groupBy[0];
                let having = _groupBy && _groupBy[1];
                groupBy = groupBy && (groupBy.length === 1 && groupBy[0].type === "list" ? groupBy[0].expressions : groupBy);
                having = having && unwrap(having);
                let selectFor = _selectFor && _selectFor[0];
                let skip = _selectFor && _selectFor[1];
                skip = unwrap(skip);
                return (0, lexer_2.track)(x, {
                  ...what,
                  ...from ? { from: Array.isArray(from) ? from : [from] } : {},
                  ...groupBy ? { groupBy } : {},
                  ...having ? { having } : {},
                  ...limit ? { limit: unwrap(limit) } : {},
                  ...orderBy ? { orderBy } : {},
                  ...where ? { where } : {},
                  ...selectFor ? { for: selectFor[1] } : {},
                  ...skip ? { skip } : {},
                  type: "select"
                });
              } },
              { "name": "select_from", "symbols": [lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from, "select_from_items"], "postprocess": last },
              { "name": "select_from_items$ebnf$1", "symbols": [] },
              { "name": "select_from_items$ebnf$1$subexpression$1", "symbols": ["comma", "select_from_item"], "postprocess": last },
              { "name": "select_from_items$ebnf$1", "symbols": ["select_from_items$ebnf$1", "select_from_items$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "select_from_items", "symbols": ["select_from_item", "select_from_items$ebnf$1"], "postprocess": ([head, tail]) => {
                return [...head, ...flatten(tail) || []];
              } },
              { "name": "select_from_item", "symbols": ["select_from_subject"] },
              { "name": "select_from_item", "symbols": ["select_from_item_joins"], "postprocess": get2(0) },
              { "name": "select_from_item_joins$subexpression$1", "symbols": ["select_from_item"], "postprocess": get2(0) },
              { "name": "select_from_item_joins", "symbols": ["select_from_item_joins$subexpression$1", "select_table_join"], "postprocess": flatten },
              { "name": "select_from_item_joins", "symbols": ["lparen", "select_from_item_joins", "rparen"], "postprocess": get2(1) },
              { "name": "select_from_subject", "symbols": ["stb_table"], "postprocess": unwrap },
              { "name": "select_from_subject", "symbols": ["stb_statement"], "postprocess": unwrap },
              { "name": "select_from_subject", "symbols": ["stb_call"], "postprocess": unwrap },
              { "name": "stb_opts$ebnf$1", "symbols": ["collist_paren"], "postprocess": id },
              { "name": "stb_opts$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "stb_opts", "symbols": ["ident_aliased", "stb_opts$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                alias: toStr(x[0]),
                ...x[1] && { columnNames: (0, lexer_2.unbox)(x[1]).map(asName) }
              }) },
              { "name": "stb_table$ebnf$1", "symbols": ["stb_opts"], "postprocess": id },
              { "name": "stb_table$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "stb_table", "symbols": ["table_ref", "stb_table$ebnf$1"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  type: "table",
                  name: (0, lexer_2.track)(x, {
                    ...x[0],
                    ...x[1]
                  })
                });
              } },
              { "name": "stb_statement", "symbols": ["selection_paren", "stb_opts"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "statement",
                statement: unwrap(x[0]),
                ...x[1]
              }) },
              { "name": "select_values", "symbols": ["kw_values", "insert_values"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "values",
                values: x[1]
              }) },
              { "name": "stb_call$ebnf$1", "symbols": ["kw_withordinality"], "postprocess": id },
              { "name": "stb_call$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "stb_call$ebnf$2", "symbols": ["stb_call_alias"], "postprocess": id },
              { "name": "stb_call$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "stb_call", "symbols": ["expr_function_call", "stb_call$ebnf$1", "stb_call$ebnf$2"], "postprocess": (x) => {
                const withOrdinality = x[1];
                const alias = x[2];
                if (!withOrdinality && !alias) {
                  return x[0];
                }
                return (0, lexer_2.track)(x, {
                  ...x[0],
                  ...withOrdinality && { withOrdinality: true },
                  alias: alias ? asNameWithColumns(alias[0], alias[1]) : void 0
                });
              } },
              { "name": "stb_call_alias$subexpression$1$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as], "postprocess": id },
              { "name": "stb_call_alias$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "stb_call_alias$subexpression$1", "symbols": ["stb_call_alias$subexpression$1$ebnf$1", "ident"], "postprocess": last },
              { "name": "stb_call_alias$ebnf$1", "symbols": ["stb_call_alias_list"], "postprocess": id },
              { "name": "stb_call_alias$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "stb_call_alias", "symbols": ["stb_call_alias$subexpression$1", "stb_call_alias$ebnf$1"] },
              { "name": "stb_call_alias_list", "symbols": ["lparen", "stb_call_alias_list_raw", "rparen"], "postprocess": get2(1) },
              { "name": "stb_call_alias_list_raw$ebnf$1", "symbols": [] },
              { "name": "stb_call_alias_list_raw$ebnf$1$subexpression$1", "symbols": ["comma", "ident"], "postprocess": last },
              { "name": "stb_call_alias_list_raw$ebnf$1", "symbols": ["stb_call_alias_list_raw$ebnf$1", "stb_call_alias_list_raw$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "stb_call_alias_list_raw", "symbols": ["ident", "stb_call_alias_list_raw$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "select_table_join$ebnf$1", "symbols": ["select_table_join_clause"], "postprocess": id },
              { "name": "select_table_join$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_table_join", "symbols": ["select_join_op", lexer_1.lexerAny.has("kw_join") ? { type: "kw_join" } : kw_join, "select_from_subject", "select_table_join$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                ...unwrap(x[2]),
                join: {
                  type: toStr(x[0], " "),
                  ...x[3] && unwrap(x[3])
                }
              }) },
              { "name": "select_table_join_clause", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, "expr"], "postprocess": (x) => (0, lexer_2.track)(x, { on: last(x) }) },
              { "name": "select_table_join_clause$macrocall$2", "symbols": ["ident"] },
              { "name": "select_table_join_clause$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "select_table_join_clause$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "select_table_join_clause$macrocall$2"], "postprocess": last },
              { "name": "select_table_join_clause$macrocall$1$ebnf$1", "symbols": ["select_table_join_clause$macrocall$1$ebnf$1", "select_table_join_clause$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "select_table_join_clause$macrocall$1", "symbols": ["select_table_join_clause$macrocall$2", "select_table_join_clause$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "select_table_join_clause", "symbols": [lexer_1.lexerAny.has("kw_using") ? { type: "kw_using" } : kw_using, "lparen", "select_table_join_clause$macrocall$1", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, { using: x[2].map(asName) }) },
              { "name": "select_join_op$subexpression$1$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_inner") ? { type: "kw_inner" } : kw_inner], "postprocess": id },
              { "name": "select_join_op$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_join_op$subexpression$1", "symbols": ["select_join_op$subexpression$1$ebnf$1"], "postprocess": (x) => (0, lexer_2.box)(x, "INNER JOIN") },
              { "name": "select_join_op", "symbols": ["select_join_op$subexpression$1"] },
              { "name": "select_join_op$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_cross") ? { type: "kw_cross" } : kw_cross], "postprocess": (x) => (0, lexer_2.box)(x, "CROSS JOIN") },
              { "name": "select_join_op", "symbols": ["select_join_op$subexpression$2"] },
              { "name": "select_join_op$subexpression$3$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_outer") ? { type: "kw_outer" } : kw_outer], "postprocess": id },
              { "name": "select_join_op$subexpression$3$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_join_op$subexpression$3", "symbols": [lexer_1.lexerAny.has("kw_left") ? { type: "kw_left" } : kw_left, "select_join_op$subexpression$3$ebnf$1"], "postprocess": (x) => (0, lexer_2.box)(x, "LEFT JOIN") },
              { "name": "select_join_op", "symbols": ["select_join_op$subexpression$3"] },
              { "name": "select_join_op$subexpression$4$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_outer") ? { type: "kw_outer" } : kw_outer], "postprocess": id },
              { "name": "select_join_op$subexpression$4$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_join_op$subexpression$4", "symbols": [lexer_1.lexerAny.has("kw_right") ? { type: "kw_right" } : kw_right, "select_join_op$subexpression$4$ebnf$1"], "postprocess": (x) => (0, lexer_2.box)(x, "RIGHT JOIN") },
              { "name": "select_join_op", "symbols": ["select_join_op$subexpression$4"] },
              { "name": "select_join_op$subexpression$5$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_outer") ? { type: "kw_outer" } : kw_outer], "postprocess": id },
              { "name": "select_join_op$subexpression$5$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_join_op$subexpression$5", "symbols": [lexer_1.lexerAny.has("kw_full") ? { type: "kw_full" } : kw_full, "select_join_op$subexpression$5$ebnf$1"], "postprocess": (x) => (0, lexer_2.box)(x, "FULL JOIN") },
              { "name": "select_join_op", "symbols": ["select_join_op$subexpression$5"] },
              { "name": "select_what$ebnf$1", "symbols": ["select_distinct"], "postprocess": id },
              { "name": "select_what$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_what$ebnf$2", "symbols": ["select_expr_list_aliased"], "postprocess": id },
              { "name": "select_what$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "select_what", "symbols": [lexer_1.lexerAny.has("kw_select") ? { type: "kw_select" } : kw_select, "select_what$ebnf$1", "select_what$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                columns: x[2],
                ...x[1] && { distinct: (0, lexer_2.unbox)(x[1]) }
              }) },
              { "name": "select_expr_list_aliased$ebnf$1", "symbols": [] },
              { "name": "select_expr_list_aliased$ebnf$1$subexpression$1", "symbols": ["comma", "select_expr_list_item"], "postprocess": last },
              { "name": "select_expr_list_aliased$ebnf$1", "symbols": ["select_expr_list_aliased$ebnf$1", "select_expr_list_aliased$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "select_expr_list_aliased", "symbols": ["select_expr_list_item", "select_expr_list_aliased$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "select_expr_list_item$ebnf$1", "symbols": ["ident_aliased"], "postprocess": id },
              { "name": "select_expr_list_item$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_expr_list_item", "symbols": ["expr", "select_expr_list_item$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                expr: x[0],
                ...x[1] ? { alias: asName(x[1]) } : {}
              }) },
              { "name": "select_distinct", "symbols": [lexer_1.lexerAny.has("kw_all") ? { type: "kw_all" } : kw_all], "postprocess": (x) => (0, lexer_2.box)(x, "all") },
              { "name": "select_distinct$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, "lparen", "expr_list_raw", "rparen"], "postprocess": get2(2) },
              { "name": "select_distinct$ebnf$1", "symbols": ["select_distinct$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "select_distinct$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_distinct", "symbols": [lexer_1.lexerAny.has("kw_distinct") ? { type: "kw_distinct" } : kw_distinct, "select_distinct$ebnf$1"], "postprocess": (x) => (0, lexer_2.box)(x, x[1] || "distinct") },
              { "name": "select_where", "symbols": [lexer_1.lexerAny.has("kw_where") ? { type: "kw_where" } : kw_where, "expr"], "postprocess": last },
              { "name": "select_groupby", "symbols": [lexer_1.lexerAny.has("kw_group") ? { type: "kw_group" } : kw_group, "kw_by", "expr_list_raw"], "postprocess": last },
              { "name": "select_having", "symbols": [lexer_1.lexerAny.has("kw_having") ? { type: "kw_having" } : kw_having, "expr"], "postprocess": last },
              { "name": "select_limit_offset$ebnf$1$subexpression$1", "symbols": ["select_offset"] },
              { "name": "select_limit_offset$ebnf$1$subexpression$1", "symbols": ["select_limit"] },
              { "name": "select_limit_offset$ebnf$1", "symbols": ["select_limit_offset$ebnf$1$subexpression$1"] },
              { "name": "select_limit_offset$ebnf$1$subexpression$2", "symbols": ["select_offset"] },
              { "name": "select_limit_offset$ebnf$1$subexpression$2", "symbols": ["select_limit"] },
              { "name": "select_limit_offset$ebnf$1", "symbols": ["select_limit_offset$ebnf$1", "select_limit_offset$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "select_limit_offset", "symbols": ["select_limit_offset$ebnf$1"], "postprocess": (x, rej) => {
                const value3 = unwrap(x);
                if (!Array.isArray(value3)) {
                  return (0, lexer_2.track)(x, value3);
                }
                if (value3.length != 2) {
                  return rej;
                }
                const a = unwrap(value3[0]);
                const b = unwrap(value3[1]);
                if (a.offset && b.offset || a.limit && b.limit) {
                  return rej;
                }
                return (0, lexer_2.track)(x, {
                  ...a,
                  ...b
                });
              } },
              { "name": "select_offset$ebnf$1$subexpression$1", "symbols": ["kw_row"] },
              { "name": "select_offset$ebnf$1$subexpression$1", "symbols": ["kw_rows"] },
              { "name": "select_offset$ebnf$1", "symbols": ["select_offset$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "select_offset$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_offset", "symbols": [lexer_1.lexerAny.has("kw_offset") ? { type: "kw_offset" } : kw_offset, "expr_nostar", "select_offset$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, { offset: unwrap(x[1]) }) },
              { "name": "select_limit$subexpression$1", "symbols": ["select_limit_1"] },
              { "name": "select_limit$subexpression$1", "symbols": ["select_limit_2"] },
              { "name": "select_limit", "symbols": ["select_limit$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, { limit: unwrap(x) }) },
              { "name": "select_limit_1", "symbols": [lexer_1.lexerAny.has("kw_limit") ? { type: "kw_limit" } : kw_limit, "expr_nostar"], "postprocess": last },
              { "name": "select_limit_2$ebnf$1$subexpression$1", "symbols": ["kw_first"] },
              { "name": "select_limit_2$ebnf$1$subexpression$1", "symbols": ["kw_next"] },
              { "name": "select_limit_2$ebnf$1", "symbols": ["select_limit_2$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "select_limit_2$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_limit_2$subexpression$1", "symbols": ["kw_row"] },
              { "name": "select_limit_2$subexpression$1", "symbols": ["kw_rows"] },
              { "name": "select_limit_2", "symbols": [lexer_1.lexerAny.has("kw_fetch") ? { type: "kw_fetch" } : kw_fetch, "select_limit_2$ebnf$1", "expr_nostar", "select_limit_2$subexpression$1", lexer_1.lexerAny.has("kw_only") ? { type: "kw_only" } : kw_only], "postprocess": get2(2) },
              { "name": "select_for$subexpression$1", "symbols": ["kw_update"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "update" }) },
              { "name": "select_for$subexpression$1", "symbols": ["kw_no", "kw_key", "kw_update"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "no key update" }) },
              { "name": "select_for$subexpression$1", "symbols": ["kw_share"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "share" }) },
              { "name": "select_for$subexpression$1", "symbols": ["kw_key", "kw_share"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "key share" }) },
              { "name": "select_for", "symbols": [lexer_1.lexerAny.has("kw_for") ? { type: "kw_for" } : kw_for, "select_for$subexpression$1"] },
              { "name": "select_skip$subexpression$1", "symbols": ["kw_nowait"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "nowait" }) },
              { "name": "select_skip$subexpression$1", "symbols": ["kw_skip", "kw_locked"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "skip locked" }) },
              { "name": "select_skip", "symbols": ["select_skip$subexpression$1"] },
              { "name": "select_order_by$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_order") ? { type: "kw_order" } : kw_order, "kw_by"] },
              { "name": "select_order_by$ebnf$1", "symbols": [] },
              { "name": "select_order_by$ebnf$1$subexpression$1", "symbols": ["comma", "select_order_by_expr"], "postprocess": last },
              { "name": "select_order_by$ebnf$1", "symbols": ["select_order_by$ebnf$1", "select_order_by$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "select_order_by", "symbols": ["select_order_by$subexpression$1", "select_order_by_expr", "select_order_by$ebnf$1"], "postprocess": ([_, head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "select_order_by_expr$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_asc") ? { type: "kw_asc" } : kw_asc] },
              { "name": "select_order_by_expr$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_desc") ? { type: "kw_desc" } : kw_desc] },
              { "name": "select_order_by_expr$ebnf$1", "symbols": ["select_order_by_expr$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "select_order_by_expr$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_order_by_expr$ebnf$2$subexpression$1$subexpression$1", "symbols": ["kw_first"] },
              { "name": "select_order_by_expr$ebnf$2$subexpression$1$subexpression$1", "symbols": ["kw_last"] },
              { "name": "select_order_by_expr$ebnf$2$subexpression$1", "symbols": ["kw_nulls", "select_order_by_expr$ebnf$2$subexpression$1$subexpression$1"], "postprocess": last },
              { "name": "select_order_by_expr$ebnf$2", "symbols": ["select_order_by_expr$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "select_order_by_expr$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "select_order_by_expr", "symbols": ["expr", "select_order_by_expr$ebnf$1", "select_order_by_expr$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                by: x[0],
                ...x[1] && { order: toStr(x[1]).toUpperCase() },
                ...x[2] && { nulls: toStr(x[2]).toUpperCase() }
              }) },
              { "name": "expr", "symbols": ["expr_nostar"], "postprocess": unwrap },
              { "name": "expr", "symbols": ["expr_star"], "postprocess": unwrap },
              { "name": "expr_nostar", "symbols": ["expr_paren"], "postprocess": unwrap },
              { "name": "expr_nostar", "symbols": ["expr_or"], "postprocess": unwrap },
              { "name": "expr_paren$subexpression$1", "symbols": ["expr_or_select"] },
              { "name": "expr_paren$subexpression$1", "symbols": ["expr_list_many"] },
              { "name": "expr_paren", "symbols": ["lparen", "expr_paren$subexpression$1", "rparen"], "postprocess": get2(1) },
              { "name": "expr_or$macrocall$2$macrocall$2", "symbols": [lexer_1.lexerAny.has("kw_or") ? { type: "kw_or" } : kw_or] },
              { "name": "expr_or$macrocall$2$macrocall$1", "symbols": ["expr_or$macrocall$2$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_or$macrocall$2", "symbols": ["expr_or$macrocall$2$macrocall$1"] },
              { "name": "expr_or$macrocall$3", "symbols": ["expr_or"] },
              { "name": "expr_or$macrocall$4", "symbols": ["expr_and"] },
              { "name": "expr_or$macrocall$1$subexpression$1", "symbols": ["expr_or$macrocall$3"] },
              { "name": "expr_or$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_or$macrocall$1$subexpression$2", "symbols": ["expr_or$macrocall$4"] },
              { "name": "expr_or$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_or$macrocall$1", "symbols": ["expr_or$macrocall$1$subexpression$1", "expr_or$macrocall$2", "expr_or$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_or$macrocall$1", "symbols": ["expr_or$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_or", "symbols": ["expr_or$macrocall$1"] },
              { "name": "expr_and$macrocall$2$macrocall$2", "symbols": [lexer_1.lexerAny.has("kw_and") ? { type: "kw_and" } : kw_and] },
              { "name": "expr_and$macrocall$2$macrocall$1", "symbols": ["expr_and$macrocall$2$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_and$macrocall$2", "symbols": ["expr_and$macrocall$2$macrocall$1"] },
              { "name": "expr_and$macrocall$3", "symbols": ["expr_and"] },
              { "name": "expr_and$macrocall$4", "symbols": ["expr_not"] },
              { "name": "expr_and$macrocall$1$subexpression$1", "symbols": ["expr_and$macrocall$3"] },
              { "name": "expr_and$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_and$macrocall$1$subexpression$2", "symbols": ["expr_and$macrocall$4"] },
              { "name": "expr_and$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_and$macrocall$1", "symbols": ["expr_and$macrocall$1$subexpression$1", "expr_and$macrocall$2", "expr_and$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_and$macrocall$1", "symbols": ["expr_and$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_and", "symbols": ["expr_and$macrocall$1"] },
              { "name": "expr_not$macrocall$2$macrocall$2", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not] },
              { "name": "expr_not$macrocall$2$macrocall$1", "symbols": ["expr_not$macrocall$2$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_not$macrocall$2", "symbols": ["expr_not$macrocall$2$macrocall$1"] },
              { "name": "expr_not$macrocall$3", "symbols": ["expr_not"] },
              { "name": "expr_not$macrocall$4", "symbols": ["expr_eq"] },
              { "name": "expr_not$macrocall$1$subexpression$1", "symbols": ["expr_not$macrocall$3"] },
              { "name": "expr_not$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_not$macrocall$1", "symbols": ["expr_not$macrocall$2", "expr_not$macrocall$1$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "unary",
                ...unwrap(x[0]),
                operand: unwrap(x[1])
              }) },
              { "name": "expr_not$macrocall$1", "symbols": ["expr_not$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_not", "symbols": ["expr_not$macrocall$1"] },
              { "name": "expr_eq$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq] },
              { "name": "expr_eq$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_neq") ? { type: "op_neq" } : op_neq] },
              { "name": "expr_eq$macrocall$2$macrocall$2", "symbols": ["expr_eq$macrocall$2$macrocall$2$subexpression$1"] },
              { "name": "expr_eq$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_eq$macrocall$2$macrocall$2"] },
              { "name": "expr_eq$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_eq$macrocall$2$macrocall$1$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_eq$macrocall$2$macrocall$1", "symbols": ["expr_eq$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap },
              { "name": "expr_eq$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_eq$macrocall$2$macrocall$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x[4], " ") || "<error>").toUpperCase(),
                opSchema: toStr(x[2])
              }) },
              { "name": "expr_eq$macrocall$2", "symbols": ["expr_eq$macrocall$2$macrocall$1"] },
              { "name": "expr_eq$macrocall$3", "symbols": ["expr_eq"] },
              { "name": "expr_eq$macrocall$4", "symbols": ["expr_is"] },
              { "name": "expr_eq$macrocall$1$subexpression$1", "symbols": ["expr_eq$macrocall$3"] },
              { "name": "expr_eq$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_eq$macrocall$1$subexpression$2", "symbols": ["expr_eq$macrocall$4"] },
              { "name": "expr_eq$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_eq$macrocall$1", "symbols": ["expr_eq$macrocall$1$subexpression$1", "expr_eq$macrocall$2", "expr_eq$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_eq$macrocall$1", "symbols": ["expr_eq$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_eq", "symbols": ["expr_eq$macrocall$1"] },
              { "name": "expr_star", "symbols": ["star"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "ref", name: "*" }) },
              { "name": "expr_is$subexpression$1", "symbols": ["expr_is"] },
              { "name": "expr_is$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_is$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_isnull") ? { type: "kw_isnull" } : kw_isnull] },
              { "name": "expr_is$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_is") ? { type: "kw_is" } : kw_is, lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null] },
              { "name": "expr_is", "symbols": ["expr_is$subexpression$1", "expr_is$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "unary", op: "IS NULL", operand: unwrap(x[0]) }) },
              { "name": "expr_is$subexpression$3", "symbols": ["expr_is"] },
              { "name": "expr_is$subexpression$3", "symbols": ["expr_paren"] },
              { "name": "expr_is$subexpression$4", "symbols": [lexer_1.lexerAny.has("kw_notnull") ? { type: "kw_notnull" } : kw_notnull] },
              { "name": "expr_is$subexpression$4", "symbols": [lexer_1.lexerAny.has("kw_is") ? { type: "kw_is" } : kw_is, "kw_not_null"] },
              { "name": "expr_is", "symbols": ["expr_is$subexpression$3", "expr_is$subexpression$4"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "unary", op: "IS NOT NULL", operand: unwrap(x[0]) }) },
              { "name": "expr_is$subexpression$5", "symbols": ["expr_is"] },
              { "name": "expr_is$subexpression$5", "symbols": ["expr_paren"] },
              { "name": "expr_is$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not], "postprocess": id },
              { "name": "expr_is$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_is$subexpression$6", "symbols": [lexer_1.lexerAny.has("kw_true") ? { type: "kw_true" } : kw_true] },
              { "name": "expr_is$subexpression$6", "symbols": [lexer_1.lexerAny.has("kw_false") ? { type: "kw_false" } : kw_false] },
              { "name": "expr_is", "symbols": ["expr_is$subexpression$5", lexer_1.lexerAny.has("kw_is") ? { type: "kw_is" } : kw_is, "expr_is$ebnf$1", "expr_is$subexpression$6"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "unary",
                op: "IS " + flattenStr([x[2], x[3]]).join(" ").toUpperCase(),
                operand: unwrap(x[0])
              }) },
              { "name": "expr_is", "symbols": ["expr_compare"], "postprocess": unwrap },
              { "name": "expr_compare$macrocall$2$macrocall$2", "symbols": [lexer_1.lexerAny.has("op_compare") ? { type: "op_compare" } : op_compare] },
              { "name": "expr_compare$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_compare$macrocall$2$macrocall$2"] },
              { "name": "expr_compare$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_compare$macrocall$2$macrocall$1$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_compare$macrocall$2$macrocall$1", "symbols": ["expr_compare$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap },
              { "name": "expr_compare$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_compare$macrocall$2$macrocall$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x[4], " ") || "<error>").toUpperCase(),
                opSchema: toStr(x[2])
              }) },
              { "name": "expr_compare$macrocall$2", "symbols": ["expr_compare$macrocall$2$macrocall$1"] },
              { "name": "expr_compare$macrocall$3", "symbols": ["expr_compare"] },
              { "name": "expr_compare$macrocall$4", "symbols": ["expr_range"] },
              { "name": "expr_compare$macrocall$1$subexpression$1", "symbols": ["expr_compare$macrocall$3"] },
              { "name": "expr_compare$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_compare$macrocall$1$subexpression$2", "symbols": ["expr_compare$macrocall$4"] },
              { "name": "expr_compare$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_compare$macrocall$1", "symbols": ["expr_compare$macrocall$1$subexpression$1", "expr_compare$macrocall$2", "expr_compare$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_compare$macrocall$1", "symbols": ["expr_compare$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_compare", "symbols": ["expr_compare$macrocall$1"] },
              { "name": "expr_range$macrocall$2", "symbols": ["ops_between"] },
              { "name": "expr_range$macrocall$3", "symbols": [lexer_1.lexerAny.has("kw_and") ? { type: "kw_and" } : kw_and] },
              { "name": "expr_range$macrocall$4", "symbols": ["expr_range"] },
              { "name": "expr_range$macrocall$5", "symbols": ["expr_others"] },
              { "name": "expr_range$macrocall$1$subexpression$1", "symbols": ["expr_range$macrocall$4"] },
              { "name": "expr_range$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_range$macrocall$1$subexpression$2", "symbols": ["expr_range$macrocall$4"] },
              { "name": "expr_range$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_range$macrocall$1$subexpression$3", "symbols": ["expr_range$macrocall$5"] },
              { "name": "expr_range$macrocall$1$subexpression$3", "symbols": ["expr_paren"] },
              { "name": "expr_range$macrocall$1", "symbols": ["expr_range$macrocall$1$subexpression$1", "expr_range$macrocall$2", "expr_range$macrocall$1$subexpression$2", "expr_range$macrocall$3", "expr_range$macrocall$1$subexpression$3"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "ternary",
                value: unwrap(x[0]),
                lo: unwrap(x[2]),
                hi: unwrap(x[4]),
                op: (flattenStr(x[1]).join(" ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_range$macrocall$1", "symbols": ["expr_range$macrocall$5"], "postprocess": unwrap },
              { "name": "expr_range", "symbols": ["expr_range$macrocall$1"] },
              { "name": "expr_others$macrocall$2$macrocall$2", "symbols": [lexer_1.lexerAny.has("ops_others") ? { type: "ops_others" } : ops_others] },
              { "name": "expr_others$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_others$macrocall$2$macrocall$2"] },
              { "name": "expr_others$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_others$macrocall$2$macrocall$1$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_others$macrocall$2$macrocall$1", "symbols": ["expr_others$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap },
              { "name": "expr_others$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_others$macrocall$2$macrocall$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x[4], " ") || "<error>").toUpperCase(),
                opSchema: toStr(x[2])
              }) },
              { "name": "expr_others$macrocall$2", "symbols": ["expr_others$macrocall$2$macrocall$1"] },
              { "name": "expr_others$macrocall$3", "symbols": ["expr_others"] },
              { "name": "expr_others$macrocall$4", "symbols": ["expr_like"] },
              { "name": "expr_others$macrocall$1$subexpression$1", "symbols": ["expr_others$macrocall$3"] },
              { "name": "expr_others$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_others$macrocall$1$subexpression$2", "symbols": ["expr_others$macrocall$4"] },
              { "name": "expr_others$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_others$macrocall$1", "symbols": ["expr_others$macrocall$1$subexpression$1", "expr_others$macrocall$2", "expr_others$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_others$macrocall$1", "symbols": ["expr_others$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_others", "symbols": ["expr_others$macrocall$1"] },
              { "name": "expr_like$macrocall$2$macrocall$2", "symbols": ["ops_like"] },
              { "name": "expr_like$macrocall$2$macrocall$1", "symbols": ["expr_like$macrocall$2$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_like$macrocall$2", "symbols": ["expr_like$macrocall$2$macrocall$1"] },
              { "name": "expr_like$macrocall$3", "symbols": ["expr_like"] },
              { "name": "expr_like$macrocall$4", "symbols": ["expr_in"] },
              { "name": "expr_like$macrocall$1$subexpression$1", "symbols": ["expr_like$macrocall$3"] },
              { "name": "expr_like$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_like$macrocall$1$subexpression$2", "symbols": ["expr_like$macrocall$4"] },
              { "name": "expr_like$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_like$macrocall$1", "symbols": ["expr_like$macrocall$1$subexpression$1", "expr_like$macrocall$2", "expr_like$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_like$macrocall$1", "symbols": ["expr_like$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_like", "symbols": ["expr_like$macrocall$1"] },
              { "name": "expr_in$macrocall$2$macrocall$2", "symbols": ["ops_in"] },
              { "name": "expr_in$macrocall$2$macrocall$1", "symbols": ["expr_in$macrocall$2$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_in$macrocall$2", "symbols": ["expr_in$macrocall$2$macrocall$1"] },
              { "name": "expr_in$macrocall$3", "symbols": ["expr_in"] },
              { "name": "expr_in$macrocall$4", "symbols": ["expr_add"] },
              { "name": "expr_in$macrocall$1$subexpression$1", "symbols": ["expr_in$macrocall$3"] },
              { "name": "expr_in$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_in$macrocall$1$subexpression$2", "symbols": ["expr_in$macrocall$4"] },
              { "name": "expr_in$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_in$macrocall$1", "symbols": ["expr_in$macrocall$1$subexpression$1", "expr_in$macrocall$2", "expr_in$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_in$macrocall$1", "symbols": ["expr_in$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_in", "symbols": ["expr_in$macrocall$1"] },
              { "name": "expr_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_plus") ? { type: "op_plus" } : op_plus] },
              { "name": "expr_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_minus") ? { type: "op_minus" } : op_minus] },
              { "name": "expr_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_additive") ? { type: "op_additive" } : op_additive] },
              { "name": "expr_add$macrocall$2$macrocall$2", "symbols": ["expr_add$macrocall$2$macrocall$2$subexpression$1"] },
              { "name": "expr_add$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_add$macrocall$2$macrocall$2"] },
              { "name": "expr_add$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_add$macrocall$2$macrocall$1$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_add$macrocall$2$macrocall$1", "symbols": ["expr_add$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap },
              { "name": "expr_add$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_add$macrocall$2$macrocall$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x[4], " ") || "<error>").toUpperCase(),
                opSchema: toStr(x[2])
              }) },
              { "name": "expr_add$macrocall$2", "symbols": ["expr_add$macrocall$2$macrocall$1"] },
              { "name": "expr_add$macrocall$3", "symbols": ["expr_add"] },
              { "name": "expr_add$macrocall$4", "symbols": ["expr_mult"] },
              { "name": "expr_add$macrocall$1$subexpression$1", "symbols": ["expr_add$macrocall$3"] },
              { "name": "expr_add$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_add$macrocall$1$subexpression$2", "symbols": ["expr_add$macrocall$4"] },
              { "name": "expr_add$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_add$macrocall$1", "symbols": ["expr_add$macrocall$1$subexpression$1", "expr_add$macrocall$2", "expr_add$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_add$macrocall$1", "symbols": ["expr_add$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_add", "symbols": ["expr_add$macrocall$1"] },
              { "name": "expr_mult$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("star") ? { type: "star" } : star] },
              { "name": "expr_mult$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_div") ? { type: "op_div" } : op_div] },
              { "name": "expr_mult$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_mod") ? { type: "op_mod" } : op_mod] },
              { "name": "expr_mult$macrocall$2$macrocall$2", "symbols": ["expr_mult$macrocall$2$macrocall$2$subexpression$1"] },
              { "name": "expr_mult$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_mult$macrocall$2$macrocall$2"] },
              { "name": "expr_mult$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_mult$macrocall$2$macrocall$1$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_mult$macrocall$2$macrocall$1", "symbols": ["expr_mult$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap },
              { "name": "expr_mult$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_mult$macrocall$2$macrocall$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x[4], " ") || "<error>").toUpperCase(),
                opSchema: toStr(x[2])
              }) },
              { "name": "expr_mult$macrocall$2", "symbols": ["expr_mult$macrocall$2$macrocall$1"] },
              { "name": "expr_mult$macrocall$3", "symbols": ["expr_mult"] },
              { "name": "expr_mult$macrocall$4", "symbols": ["expr_exp"] },
              { "name": "expr_mult$macrocall$1$subexpression$1", "symbols": ["expr_mult$macrocall$3"] },
              { "name": "expr_mult$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_mult$macrocall$1$subexpression$2", "symbols": ["expr_mult$macrocall$4"] },
              { "name": "expr_mult$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_mult$macrocall$1", "symbols": ["expr_mult$macrocall$1$subexpression$1", "expr_mult$macrocall$2", "expr_mult$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_mult$macrocall$1", "symbols": ["expr_mult$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_mult", "symbols": ["expr_mult$macrocall$1"] },
              { "name": "expr_exp$macrocall$2$macrocall$2", "symbols": [lexer_1.lexerAny.has("op_exp") ? { type: "op_exp" } : op_exp] },
              { "name": "expr_exp$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_exp$macrocall$2$macrocall$2"] },
              { "name": "expr_exp$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_exp$macrocall$2$macrocall$1$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_exp$macrocall$2$macrocall$1", "symbols": ["expr_exp$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap },
              { "name": "expr_exp$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_exp$macrocall$2$macrocall$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x[4], " ") || "<error>").toUpperCase(),
                opSchema: toStr(x[2])
              }) },
              { "name": "expr_exp$macrocall$2", "symbols": ["expr_exp$macrocall$2$macrocall$1"] },
              { "name": "expr_exp$macrocall$3", "symbols": ["expr_exp"] },
              { "name": "expr_exp$macrocall$4", "symbols": ["expr_unary_add"] },
              { "name": "expr_exp$macrocall$1$subexpression$1", "symbols": ["expr_exp$macrocall$3"] },
              { "name": "expr_exp$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_exp$macrocall$1$subexpression$2", "symbols": ["expr_exp$macrocall$4"] },
              { "name": "expr_exp$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_exp$macrocall$1", "symbols": ["expr_exp$macrocall$1$subexpression$1", "expr_exp$macrocall$2", "expr_exp$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_exp$macrocall$1", "symbols": ["expr_exp$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_exp", "symbols": ["expr_exp$macrocall$1"] },
              { "name": "expr_unary_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_plus") ? { type: "op_plus" } : op_plus] },
              { "name": "expr_unary_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_minus") ? { type: "op_minus" } : op_minus] },
              { "name": "expr_unary_add$macrocall$2$macrocall$2", "symbols": ["expr_unary_add$macrocall$2$macrocall$2$subexpression$1"] },
              { "name": "expr_unary_add$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_unary_add$macrocall$2$macrocall$2"] },
              { "name": "expr_unary_add$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_unary_add$macrocall$2$macrocall$1$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_unary_add$macrocall$2$macrocall$1", "symbols": ["expr_unary_add$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap },
              { "name": "expr_unary_add$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_unary_add$macrocall$2$macrocall$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x[4], " ") || "<error>").toUpperCase(),
                opSchema: toStr(x[2])
              }) },
              { "name": "expr_unary_add$macrocall$2", "symbols": ["expr_unary_add$macrocall$2$macrocall$1"] },
              { "name": "expr_unary_add$macrocall$3", "symbols": ["expr_unary_add"] },
              { "name": "expr_unary_add$macrocall$4", "symbols": ["expr_various_constructs"] },
              { "name": "expr_unary_add$macrocall$1$subexpression$1", "symbols": ["expr_unary_add$macrocall$3"] },
              { "name": "expr_unary_add$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_unary_add$macrocall$1", "symbols": ["expr_unary_add$macrocall$2", "expr_unary_add$macrocall$1$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "unary",
                ...unwrap(x[0]),
                operand: unwrap(x[1])
              }) },
              { "name": "expr_unary_add$macrocall$1", "symbols": ["expr_unary_add$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_unary_add", "symbols": ["expr_unary_add$macrocall$1"] },
              { "name": "expr_various_constructs$macrocall$2$macrocall$2", "symbols": ["various_binaries"] },
              { "name": "expr_various_constructs$macrocall$2$macrocall$1", "symbols": ["expr_various_constructs$macrocall$2$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_various_constructs$macrocall$2", "symbols": ["expr_various_constructs$macrocall$2$macrocall$1"] },
              { "name": "expr_various_constructs$macrocall$3", "symbols": ["expr_various_constructs"] },
              { "name": "expr_various_constructs$macrocall$4", "symbols": ["expr_array_index"] },
              { "name": "expr_various_constructs$macrocall$1$subexpression$1", "symbols": ["expr_various_constructs$macrocall$3"] },
              { "name": "expr_various_constructs$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_various_constructs$macrocall$1$subexpression$2", "symbols": ["expr_various_constructs$macrocall$4"] },
              { "name": "expr_various_constructs$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_various_constructs$macrocall$1", "symbols": ["expr_various_constructs$macrocall$1$subexpression$1", "expr_various_constructs$macrocall$2", "expr_various_constructs$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_various_constructs$macrocall$1", "symbols": ["expr_various_constructs$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_various_constructs", "symbols": ["expr_various_constructs$macrocall$1"] },
              { "name": "expr_array_index$subexpression$1", "symbols": ["expr_array_index"] },
              { "name": "expr_array_index$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_array_index", "symbols": ["expr_array_index$subexpression$1", lexer_1.lexerAny.has("lbracket") ? { type: "lbracket" } : lbracket, "expr_nostar", lexer_1.lexerAny.has("rbracket") ? { type: "rbracket" } : rbracket], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "arrayIndex",
                array: unwrap(x[0]),
                index: unwrap(x[2])
              }) },
              { "name": "expr_array_index", "symbols": ["expr_member"], "postprocess": unwrap },
              { "name": "expr_member$subexpression$1", "symbols": ["expr_member"] },
              { "name": "expr_member$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_member$subexpression$2", "symbols": ["string"] },
              { "name": "expr_member$subexpression$2", "symbols": ["int"] },
              { "name": "expr_member", "symbols": ["expr_member$subexpression$1", "ops_member", "expr_member$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "member",
                operand: unwrap(x[0]),
                op: x[1],
                member: unwrap(x[2])
              }) },
              { "name": "expr_member$subexpression$3", "symbols": ["expr_member"] },
              { "name": "expr_member$subexpression$3", "symbols": ["expr_paren"] },
              { "name": "expr_member", "symbols": ["expr_member$subexpression$3", lexer_1.lexerAny.has("op_cast") ? { type: "op_cast" } : op_cast, "data_type"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "cast",
                operand: unwrap(x[0]),
                to: x[2]
              }) },
              { "name": "expr_member", "symbols": [lexer_1.lexerAny.has("kw_cast") ? { type: "kw_cast" } : kw_cast, "lparen", "expr_nostar", lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "data_type", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "cast",
                operand: unwrap(x[2]),
                to: x[4]
              }) },
              { "name": "expr_member", "symbols": ["data_type", "string"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "cast",
                operand: (0, lexer_2.track)(x[1], {
                  type: "string",
                  value: (0, lexer_2.unbox)(x[1])
                }),
                to: (0, lexer_2.unbox)(x[0])
              }) },
              { "name": "expr_member", "symbols": ["expr_dot"], "postprocess": unwrap },
              { "name": "expr_dot$subexpression$1", "symbols": ["word"] },
              { "name": "expr_dot$subexpression$1", "symbols": ["star"] },
              { "name": "expr_dot", "symbols": ["qname", lexer_1.lexerAny.has("dot") ? { type: "dot" } : dot, "expr_dot$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "ref",
                table: unwrap(x[0]),
                name: toStr(x[2])
              }) },
              { "name": "expr_dot", "symbols": ["expr_final"], "postprocess": unwrap },
              { "name": "expr_final", "symbols": ["expr_basic"] },
              { "name": "expr_final", "symbols": ["expr_primary"] },
              { "name": "expr_basic", "symbols": ["expr_special_calls"] },
              { "name": "expr_basic", "symbols": ["expr_call"] },
              { "name": "expr_basic", "symbols": ["expr_array"] },
              { "name": "expr_basic", "symbols": ["expr_case"] },
              { "name": "expr_basic", "symbols": ["expr_extract"] },
              { "name": "expr_basic", "symbols": ["word"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "ref",
                name: unwrap(x[0])
              }) },
              { "name": "expr_array$ebnf$1", "symbols": ["expr_subarray_items"], "postprocess": id },
              { "name": "expr_array$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_array", "symbols": [lexer_1.lexerAny.has("kw_array") ? { type: "kw_array" } : kw_array, lexer_1.lexerAny.has("lbracket") ? { type: "lbracket" } : lbracket, "expr_array$ebnf$1", lexer_1.lexerAny.has("rbracket") ? { type: "rbracket" } : rbracket], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "array",
                expressions: x[2] || []
              }) },
              { "name": "expr_array", "symbols": [lexer_1.lexerAny.has("kw_array") ? { type: "kw_array" } : kw_array, "lparen", "selection", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "array select",
                select: unwrap(x[2])
              }) },
              { "name": "expr_subarray$ebnf$1", "symbols": ["expr_subarray_items"], "postprocess": id },
              { "name": "expr_subarray$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_subarray", "symbols": [lexer_1.lexerAny.has("lbracket") ? { type: "lbracket" } : lbracket, "expr_subarray$ebnf$1", lexer_1.lexerAny.has("rbracket") ? { type: "rbracket" } : rbracket], "postprocess": get2(1) },
              { "name": "expr_subarray_items$macrocall$2", "symbols": ["expr_list_item"] },
              { "name": "expr_subarray_items$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "expr_subarray_items$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "expr_subarray_items$macrocall$2"], "postprocess": last },
              { "name": "expr_subarray_items$macrocall$1$ebnf$1", "symbols": ["expr_subarray_items$macrocall$1$ebnf$1", "expr_subarray_items$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "expr_subarray_items$macrocall$1", "symbols": ["expr_subarray_items$macrocall$2", "expr_subarray_items$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "expr_subarray_items", "symbols": ["expr_subarray_items$macrocall$1"], "postprocess": (x) => x[0].map(unwrap) },
              { "name": "expr_subarray_items$macrocall$4", "symbols": ["expr_subarray"] },
              { "name": "expr_subarray_items$macrocall$3$ebnf$1", "symbols": [] },
              { "name": "expr_subarray_items$macrocall$3$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "expr_subarray_items$macrocall$4"], "postprocess": last },
              { "name": "expr_subarray_items$macrocall$3$ebnf$1", "symbols": ["expr_subarray_items$macrocall$3$ebnf$1", "expr_subarray_items$macrocall$3$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "expr_subarray_items$macrocall$3", "symbols": ["expr_subarray_items$macrocall$4", "expr_subarray_items$macrocall$3$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "expr_subarray_items", "symbols": ["expr_subarray_items$macrocall$3"], "postprocess": (x) => {
                return x[0].map((v) => {
                  return (0, lexer_2.track)(v, {
                    type: "array",
                    expressions: v[0].map(unwrap)
                  });
                });
              } },
              { "name": "expr_function_call$ebnf$1", "symbols": ["expr_list_raw"], "postprocess": id },
              { "name": "expr_function_call$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_function_call", "symbols": ["expr_fn_name", "lparen", "expr_function_call$ebnf$1", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "call",
                function: unwrap(x[0]),
                args: x[2] || []
              }) },
              { "name": "expr_call$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_all") ? { type: "kw_all" } : kw_all] },
              { "name": "expr_call$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_distinct") ? { type: "kw_distinct" } : kw_distinct] },
              { "name": "expr_call$ebnf$1", "symbols": ["expr_call$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "expr_call$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_call$ebnf$2", "symbols": ["expr_list_raw"], "postprocess": id },
              { "name": "expr_call$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "expr_call$ebnf$3", "symbols": ["select_order_by"], "postprocess": id },
              { "name": "expr_call$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "expr_call$ebnf$4$subexpression$1", "symbols": ["kw_filter", "lparen", lexer_1.lexerAny.has("kw_where") ? { type: "kw_where" } : kw_where, "expr", "rparen"], "postprocess": get2(3) },
              { "name": "expr_call$ebnf$4", "symbols": ["expr_call$ebnf$4$subexpression$1"], "postprocess": id },
              { "name": "expr_call$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "expr_call$ebnf$5", "symbols": ["expr_call_over"], "postprocess": id },
              { "name": "expr_call$ebnf$5", "symbols": [], "postprocess": () => null },
              { "name": "expr_call", "symbols": ["expr_fn_name", "lparen", "expr_call$ebnf$1", "expr_call$ebnf$2", "expr_call$ebnf$3", "rparen", "expr_call$ebnf$4", "expr_call$ebnf$5"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "call",
                function: unwrap(x[0]),
                ...x[2] && { distinct: toStr(x[2]) },
                args: x[3] || [],
                ...x[4] && { orderBy: x[4] },
                ...x[6] && { filter: unwrap(x[6]) },
                ...x[7] && { over: unwrap(x[7]) }
              }) },
              { "name": "expr_call_over$ebnf$1$subexpression$1", "symbols": ["kw_partition", "kw_by", "expr_list_raw"], "postprocess": last },
              { "name": "expr_call_over$ebnf$1", "symbols": ["expr_call_over$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "expr_call_over$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_call_over$ebnf$2", "symbols": ["select_order_by"], "postprocess": id },
              { "name": "expr_call_over$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "expr_call_over", "symbols": ["kw_over", "lparen", "expr_call_over$ebnf$1", "expr_call_over$ebnf$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                ...x[2] && { partitionBy: x[2] },
                ...x[3] && { orderBy: x[3] }
              }) },
              { "name": "expr_extract$subexpression$1", "symbols": ["word"], "postprocess": kw("extract") },
              { "name": "expr_extract", "symbols": ["expr_extract$subexpression$1", "lparen", "word", lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from, "expr", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "extract",
                field: asName(x[2]),
                from: x[4]
              }) },
              { "name": "expr_primary", "symbols": ["float"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "numeric", value: (0, lexer_2.unbox)(x[0]) }) },
              { "name": "expr_primary", "symbols": ["int"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "integer", value: (0, lexer_2.unbox)(x[0]) }) },
              { "name": "expr_primary", "symbols": ["string"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "string", value: (0, lexer_2.unbox)(x[0]) }) },
              { "name": "expr_primary", "symbols": [lexer_1.lexerAny.has("kw_true") ? { type: "kw_true" } : kw_true], "postprocess": (x) => (0, lexer_2.track)(x, { type: "boolean", value: true }) },
              { "name": "expr_primary", "symbols": [lexer_1.lexerAny.has("kw_false") ? { type: "kw_false" } : kw_false], "postprocess": (x) => (0, lexer_2.track)(x, { type: "boolean", value: false }) },
              { "name": "expr_primary", "symbols": [lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null], "postprocess": (x) => (0, lexer_2.track)(x, { type: "null" }) },
              { "name": "expr_primary", "symbols": ["value_keyword"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "keyword", keyword: toStr(x) }) },
              { "name": "expr_primary", "symbols": [lexer_1.lexerAny.has("qparam") ? { type: "qparam" } : qparam], "postprocess": (x) => (0, lexer_2.track)(x, { type: "parameter", name: toStr(x[0]) }) },
              { "name": "expr_primary", "symbols": [lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default], "postprocess": (x) => (0, lexer_2.track)(x, { type: "default" }) },
              { "name": "ops_like", "symbols": ["ops_like_keywors"] },
              { "name": "ops_like", "symbols": ["ops_like_operators"] },
              { "name": "ops_like_keywors$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not], "postprocess": id },
              { "name": "ops_like_keywors$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "ops_like_keywors$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_like") ? { type: "kw_like" } : kw_like] },
              { "name": "ops_like_keywors$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_ilike") ? { type: "kw_ilike" } : kw_ilike] },
              { "name": "ops_like_keywors", "symbols": ["ops_like_keywors$ebnf$1", "ops_like_keywors$subexpression$1"] },
              { "name": "ops_like_operators$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_like") ? { type: "op_like" } : op_like], "postprocess": () => "LIKE" },
              { "name": "ops_like_operators", "symbols": ["ops_like_operators$subexpression$1"] },
              { "name": "ops_like_operators$subexpression$2", "symbols": [lexer_1.lexerAny.has("op_ilike") ? { type: "op_ilike" } : op_ilike], "postprocess": () => "ILIKE" },
              { "name": "ops_like_operators", "symbols": ["ops_like_operators$subexpression$2"] },
              { "name": "ops_like_operators$subexpression$3", "symbols": [lexer_1.lexerAny.has("op_not_like") ? { type: "op_not_like" } : op_not_like], "postprocess": () => "NOT LIKE" },
              { "name": "ops_like_operators", "symbols": ["ops_like_operators$subexpression$3"] },
              { "name": "ops_like_operators$subexpression$4", "symbols": [lexer_1.lexerAny.has("op_not_ilike") ? { type: "op_not_ilike" } : op_not_ilike], "postprocess": () => "NOT ILIKE" },
              { "name": "ops_like_operators", "symbols": ["ops_like_operators$subexpression$4"] },
              { "name": "ops_in$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not], "postprocess": id },
              { "name": "ops_in$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "ops_in", "symbols": ["ops_in$ebnf$1", lexer_1.lexerAny.has("kw_in") ? { type: "kw_in" } : kw_in] },
              { "name": "ops_between$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not], "postprocess": id },
              { "name": "ops_between$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "ops_between", "symbols": ["ops_between$ebnf$1", "kw_between"] },
              { "name": "ops_member$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_member") ? { type: "op_member" } : op_member] },
              { "name": "ops_member$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_membertext") ? { type: "op_membertext" } : op_membertext] },
              { "name": "ops_member", "symbols": ["ops_member$subexpression$1"], "postprocess": (x) => {
                var _a;
                return (_a = unwrap(x)) === null || _a === void 0 ? void 0 : _a.value;
              } },
              { "name": "expr_list_item", "symbols": ["expr_or_select"], "postprocess": unwrap },
              { "name": "expr_list_item", "symbols": ["expr_star"], "postprocess": unwrap },
              { "name": "expr_list_raw$macrocall$2", "symbols": ["expr_list_item"] },
              { "name": "expr_list_raw$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "expr_list_raw$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "expr_list_raw$macrocall$2"], "postprocess": last },
              { "name": "expr_list_raw$macrocall$1$ebnf$1", "symbols": ["expr_list_raw$macrocall$1$ebnf$1", "expr_list_raw$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "expr_list_raw$macrocall$1", "symbols": ["expr_list_raw$macrocall$2", "expr_list_raw$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "expr_list_raw", "symbols": ["expr_list_raw$macrocall$1"], "postprocess": ([x]) => x.map(unwrap) },
              { "name": "expr_list_raw_many$macrocall$2", "symbols": ["expr_list_item"] },
              { "name": "expr_list_raw_many$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "expr_list_raw_many$macrocall$2"], "postprocess": last },
              { "name": "expr_list_raw_many$macrocall$1$ebnf$1", "symbols": ["expr_list_raw_many$macrocall$1$ebnf$1$subexpression$1"] },
              { "name": "expr_list_raw_many$macrocall$1$ebnf$1$subexpression$2", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "expr_list_raw_many$macrocall$2"], "postprocess": last },
              { "name": "expr_list_raw_many$macrocall$1$ebnf$1", "symbols": ["expr_list_raw_many$macrocall$1$ebnf$1", "expr_list_raw_many$macrocall$1$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "expr_list_raw_many$macrocall$1", "symbols": ["expr_list_raw_many$macrocall$2", "expr_list_raw_many$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "expr_list_raw_many", "symbols": ["expr_list_raw_many$macrocall$1"], "postprocess": ([x]) => x.map(unwrap) },
              { "name": "expr_or_select", "symbols": ["expr_nostar"], "postprocess": unwrap },
              { "name": "expr_or_select", "symbols": ["selection"], "postprocess": unwrap },
              { "name": "expr_list_many", "symbols": ["expr_list_raw_many"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "list",
                expressions: x[0]
              }) },
              { "name": "expr_case$ebnf$1", "symbols": ["expr_nostar"], "postprocess": id },
              { "name": "expr_case$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_case$ebnf$2", "symbols": [] },
              { "name": "expr_case$ebnf$2", "symbols": ["expr_case$ebnf$2", "expr_case_whens"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "expr_case$ebnf$3", "symbols": ["expr_case_else"], "postprocess": id },
              { "name": "expr_case$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "expr_case", "symbols": [lexer_1.lexerAny.has("kw_case") ? { type: "kw_case" } : kw_case, "expr_case$ebnf$1", "expr_case$ebnf$2", "expr_case$ebnf$3", lexer_1.lexerAny.has("kw_end") ? { type: "kw_end" } : kw_end], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "case",
                value: x[1],
                whens: x[2],
                else: x[3]
              }) },
              { "name": "expr_case_whens", "symbols": [lexer_1.lexerAny.has("kw_when") ? { type: "kw_when" } : kw_when, "expr_nostar", lexer_1.lexerAny.has("kw_then") ? { type: "kw_then" } : kw_then, "expr_nostar"], "postprocess": (x) => (0, lexer_2.track)(x, {
                when: x[1],
                value: x[3]
              }) },
              { "name": "expr_case_else", "symbols": [lexer_1.lexerAny.has("kw_else") ? { type: "kw_else" } : kw_else, "expr_nostar"], "postprocess": last },
              { "name": "expr_fn_name$subexpression$1$ebnf$1$subexpression$1", "symbols": ["word", lexer_1.lexerAny.has("dot") ? { type: "dot" } : dot] },
              { "name": "expr_fn_name$subexpression$1$ebnf$1", "symbols": ["expr_fn_name$subexpression$1$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "expr_fn_name$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_fn_name$subexpression$1", "symbols": ["expr_fn_name$subexpression$1$ebnf$1", "word_or_keyword"], "postprocess": (x) => (0, lexer_2.track)(x, {
                name: (0, lexer_2.unbox)(unwrap(x[1])),
                ...x[0] && { schema: toStr(x[0][0]) }
              }) },
              { "name": "expr_fn_name", "symbols": ["expr_fn_name$subexpression$1"] },
              { "name": "expr_fn_name$subexpression$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_any") ? { type: "kw_any" } : kw_any] },
              { "name": "expr_fn_name$subexpression$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_some") ? { type: "kw_some" } : kw_some] },
              { "name": "expr_fn_name$subexpression$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_all") ? { type: "kw_all" } : kw_all] },
              { "name": "expr_fn_name$subexpression$2", "symbols": ["expr_fn_name$subexpression$2$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                name: toStr(unwrap(x))
              }) },
              { "name": "expr_fn_name", "symbols": ["expr_fn_name$subexpression$2"] },
              { "name": "word_or_keyword", "symbols": ["word"] },
              { "name": "word_or_keyword", "symbols": ["value_keyword"], "postprocess": (x) => (0, lexer_2.box)(x, toStr(x)) },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_catalog") ? { type: "kw_current_catalog" } : kw_current_catalog] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_date") ? { type: "kw_current_date" } : kw_current_date] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_role") ? { type: "kw_current_role" } : kw_current_role] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_schema") ? { type: "kw_current_schema" } : kw_current_schema] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_timestamp") ? { type: "kw_current_timestamp" } : kw_current_timestamp] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_time") ? { type: "kw_current_time" } : kw_current_time] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_localtimestamp") ? { type: "kw_localtimestamp" } : kw_localtimestamp] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_localtime") ? { type: "kw_localtime" } : kw_localtime] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_session_user") ? { type: "kw_session_user" } : kw_session_user] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_user") ? { type: "kw_user" } : kw_user] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_user") ? { type: "kw_current_user" } : kw_current_user] },
              { "name": "expr_special_calls", "symbols": ["spe_overlay"] },
              { "name": "expr_special_calls", "symbols": ["spe_substring"] },
              { "name": "spe_overlay$subexpression$1", "symbols": ["word"], "postprocess": kw("overlay") },
              { "name": "spe_overlay$subexpression$2", "symbols": [lexer_1.lexerAny.has("lparen") ? { type: "lparen" } : lparen, "expr_nostar"] },
              { "name": "spe_overlay$subexpression$3", "symbols": [lexer_1.lexerAny.has("kw_placing") ? { type: "kw_placing" } : kw_placing, "expr_nostar"] },
              { "name": "spe_overlay$subexpression$4", "symbols": [lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from, "expr_nostar"] },
              { "name": "spe_overlay$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_for") ? { type: "kw_for" } : kw_for, "expr_nostar"] },
              { "name": "spe_overlay$ebnf$1", "symbols": ["spe_overlay$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "spe_overlay$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "spe_overlay", "symbols": ["spe_overlay$subexpression$1", "spe_overlay$subexpression$2", "spe_overlay$subexpression$3", "spe_overlay$subexpression$4", "spe_overlay$ebnf$1", lexer_1.lexerAny.has("rparen") ? { type: "rparen" } : rparen], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "overlay",
                value: x[1][1],
                placing: x[2][1],
                from: x[3][1],
                ...x[4] && { for: x[4][1] }
              }) },
              { "name": "spe_substring$subexpression$1", "symbols": ["word"], "postprocess": kw("substring") },
              { "name": "spe_substring$subexpression$2", "symbols": [lexer_1.lexerAny.has("lparen") ? { type: "lparen" } : lparen, "expr_nostar"] },
              { "name": "spe_substring$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from, "expr_nostar"] },
              { "name": "spe_substring$ebnf$1", "symbols": ["spe_substring$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "spe_substring$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "spe_substring$ebnf$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_for") ? { type: "kw_for" } : kw_for, "expr_nostar"] },
              { "name": "spe_substring$ebnf$2", "symbols": ["spe_substring$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "spe_substring$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "spe_substring", "symbols": ["spe_substring$subexpression$1", "spe_substring$subexpression$2", "spe_substring$ebnf$1", "spe_substring$ebnf$2", lexer_1.lexerAny.has("rparen") ? { type: "rparen" } : rparen], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "substring",
                value: x[1][1],
                ...x[2] && { from: x[2][1] },
                ...x[3] && { for: x[3][1] }
              }) },
              { "name": "various_binaries", "symbols": ["kw_at", "kw_time", "kw_zone"], "postprocess": () => "AT TIME ZONE" },
              { "name": "createtable_statement$ebnf$1", "symbols": ["createtable_modifiers"], "postprocess": id },
              { "name": "createtable_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createtable_statement$ebnf$2", "symbols": ["kw_ifnotexists"], "postprocess": id },
              { "name": "createtable_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "createtable_statement$ebnf$3", "symbols": ["createtable_opts"], "postprocess": id },
              { "name": "createtable_statement$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "createtable_statement", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "createtable_statement$ebnf$1", lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table, "createtable_statement$ebnf$2", "qname", "lparen", "createtable_declarationlist", "rparen", "createtable_statement$ebnf$3"], "postprocess": (x) => {
                const cols = x[6].filter((v) => "kind" in v);
                const constraints = x[6].filter((v) => !("kind" in v));
                return (0, lexer_2.track)(x, {
                  type: "create table",
                  ...!!x[3] ? { ifNotExists: true } : {},
                  name: x[4],
                  columns: cols,
                  ...unwrap(x[1]),
                  ...constraints.length ? { constraints } : {},
                  ...last(x)
                });
              } },
              { "name": "createtable_modifiers", "symbols": ["kw_unlogged"], "postprocess": (x) => x[0] ? { unlogged: true } : {} },
              { "name": "createtable_modifiers", "symbols": ["m_locglob"] },
              { "name": "createtable_modifiers", "symbols": ["m_tmp"] },
              { "name": "createtable_modifiers", "symbols": ["m_locglob", "m_tmp"], "postprocess": ([a, b]) => ({ ...a, ...b }) },
              { "name": "m_locglob$subexpression$1", "symbols": ["kw_local"] },
              { "name": "m_locglob$subexpression$1", "symbols": ["kw_global"] },
              { "name": "m_locglob", "symbols": ["m_locglob$subexpression$1"], "postprocess": (x) => ({ locality: toStr(x) }) },
              { "name": "m_tmp$subexpression$1", "symbols": ["kw_temp"] },
              { "name": "m_tmp$subexpression$1", "symbols": ["kw_temporary"] },
              { "name": "m_tmp", "symbols": ["m_tmp$subexpression$1"], "postprocess": (x) => ({ temporary: true }) },
              { "name": "createtable_declarationlist$ebnf$1", "symbols": [] },
              { "name": "createtable_declarationlist$ebnf$1$subexpression$1", "symbols": ["comma", "createtable_declaration"], "postprocess": last },
              { "name": "createtable_declarationlist$ebnf$1", "symbols": ["createtable_declarationlist$ebnf$1", "createtable_declarationlist$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtable_declarationlist", "symbols": ["createtable_declaration", "createtable_declarationlist$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "createtable_declaration$subexpression$1", "symbols": ["createtable_constraint"] },
              { "name": "createtable_declaration$subexpression$1", "symbols": ["createtable_column"] },
              { "name": "createtable_declaration$subexpression$1", "symbols": ["createtable_like"] },
              { "name": "createtable_declaration", "symbols": ["createtable_declaration$subexpression$1"], "postprocess": unwrap },
              { "name": "createtable_constraint$macrocall$2", "symbols": ["createtable_constraint_def"] },
              { "name": "createtable_constraint$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_constraint") ? { type: "kw_constraint" } : kw_constraint, "word"] },
              { "name": "createtable_constraint$macrocall$1$ebnf$1", "symbols": ["createtable_constraint$macrocall$1$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "createtable_constraint$macrocall$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createtable_constraint$macrocall$1", "symbols": ["createtable_constraint$macrocall$1$ebnf$1", "createtable_constraint$macrocall$2"], "postprocess": (x) => {
                const name2 = x[0] && asName(x[0][1]);
                if (!name2) {
                  return (0, lexer_2.track)(x, unwrap(x[1]));
                }
                return (0, lexer_2.track)(x, {
                  constraintName: name2,
                  ...unwrap(x[1])
                });
              } },
              { "name": "createtable_constraint", "symbols": ["createtable_constraint$macrocall$1"], "postprocess": unwrap },
              { "name": "createtable_constraint_def", "symbols": ["createtable_constraint_def_unique"] },
              { "name": "createtable_constraint_def", "symbols": ["createtable_constraint_def_check"] },
              { "name": "createtable_constraint_def", "symbols": ["createtable_constraint_foreignkey"] },
              { "name": "createtable_constraint_def_unique$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_unique") ? { type: "kw_unique" } : kw_unique] },
              { "name": "createtable_constraint_def_unique$subexpression$1", "symbols": ["kw_primary_key"] },
              { "name": "createtable_constraint_def_unique", "symbols": ["createtable_constraint_def_unique$subexpression$1", "lparen", "createtable_collist", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: toStr(x[0], " "),
                columns: x[2].map(asName)
              }) },
              { "name": "createtable_constraint_def_check", "symbols": [lexer_1.lexerAny.has("kw_check") ? { type: "kw_check" } : kw_check, "expr_paren"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "check",
                expr: unwrap(x[1])
              }) },
              { "name": "createtable_constraint_foreignkey", "symbols": [lexer_1.lexerAny.has("kw_foreign") ? { type: "kw_foreign" } : kw_foreign, "kw_key", "collist_paren", "createtable_references"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  type: "foreign key",
                  localColumns: x[2].map(asName),
                  ...x[3]
                });
              } },
              { "name": "createtable_references$ebnf$1", "symbols": [] },
              { "name": "createtable_references$ebnf$1", "symbols": ["createtable_references$ebnf$1", "createtable_constraint_foreignkey_onsometing"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtable_references", "symbols": [lexer_1.lexerAny.has("kw_references") ? { type: "kw_references" } : kw_references, "table_ref", "collist_paren", "createtable_references$ebnf$1"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  foreignTable: unwrap(x[1]),
                  foreignColumns: x[2].map(asName),
                  ...x[3].reduce((a, b) => ({ ...a, ...b }), {})
                });
              } },
              { "name": "createtable_constraint_foreignkey_onsometing", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, "kw_delete", "createtable_constraint_on_action"], "postprocess": (x) => (0, lexer_2.track)(x, { onDelete: last(x) }) },
              { "name": "createtable_constraint_foreignkey_onsometing", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, "kw_update", "createtable_constraint_on_action"], "postprocess": (x) => (0, lexer_2.track)(x, { onUpdate: last(x) }) },
              { "name": "createtable_constraint_foreignkey_onsometing$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_full") ? { type: "kw_full" } : kw_full] },
              { "name": "createtable_constraint_foreignkey_onsometing$subexpression$1", "symbols": ["kw_partial"] },
              { "name": "createtable_constraint_foreignkey_onsometing$subexpression$1", "symbols": ["kw_simple"] },
              { "name": "createtable_constraint_foreignkey_onsometing", "symbols": ["kw_match", "createtable_constraint_foreignkey_onsometing$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, { match: toStr(last(x)) }) },
              { "name": "createtable_constraint_on_action$subexpression$1", "symbols": ["kw_cascade"] },
              { "name": "createtable_constraint_on_action$subexpression$1$subexpression$1", "symbols": ["kw_no", "kw_action"] },
              { "name": "createtable_constraint_on_action$subexpression$1", "symbols": ["createtable_constraint_on_action$subexpression$1$subexpression$1"] },
              { "name": "createtable_constraint_on_action$subexpression$1", "symbols": ["kw_restrict"] },
              { "name": "createtable_constraint_on_action$subexpression$1$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null] },
              { "name": "createtable_constraint_on_action$subexpression$1$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default] },
              { "name": "createtable_constraint_on_action$subexpression$1", "symbols": ["kw_set", "createtable_constraint_on_action$subexpression$1$subexpression$2"] },
              { "name": "createtable_constraint_on_action", "symbols": ["createtable_constraint_on_action$subexpression$1"], "postprocess": (x) => toStr(x, " ") },
              { "name": "createtable_collist$ebnf$1", "symbols": [] },
              { "name": "createtable_collist$ebnf$1$subexpression$1", "symbols": ["comma", "ident"], "postprocess": last },
              { "name": "createtable_collist$ebnf$1", "symbols": ["createtable_collist$ebnf$1", "createtable_collist$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtable_collist", "symbols": ["ident", "createtable_collist$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "createtable_column$ebnf$1", "symbols": ["createtable_collate"], "postprocess": id },
              { "name": "createtable_column$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createtable_column$ebnf$2", "symbols": [] },
              { "name": "createtable_column$ebnf$2", "symbols": ["createtable_column$ebnf$2", "createtable_column_constraint"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtable_column", "symbols": ["word", "data_type", "createtable_column$ebnf$1", "createtable_column$ebnf$2"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  kind: "column",
                  name: asName(x[0]),
                  dataType: x[1],
                  ...x[2] ? { collate: x[2][1] } : {},
                  ...x[3] && x[3].length ? { constraints: x[3] } : {}
                });
              } },
              { "name": "createtable_like$ebnf$1", "symbols": [] },
              { "name": "createtable_like$ebnf$1", "symbols": ["createtable_like$ebnf$1", "createtable_like_opt"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtable_like", "symbols": [lexer_1.lexerAny.has("kw_like") ? { type: "kw_like" } : kw_like, "qname", "createtable_like$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                kind: "like table",
                like: x[1],
                options: x[2]
              }) },
              { "name": "createtable_like_opt$subexpression$1", "symbols": ["kw_including"] },
              { "name": "createtable_like_opt$subexpression$1", "symbols": ["kw_excluding"] },
              { "name": "createtable_like_opt", "symbols": ["createtable_like_opt$subexpression$1", "createtable_like_opt_val"], "postprocess": (x) => (0, lexer_2.track)(x, {
                verb: toStr(x[0]),
                option: toStr(x[1])
              }) },
              { "name": "createtable_like_opt_val", "symbols": ["word"], "postprocess": anyKw("defaults", "constraints", "indexes", "storage", "comments") },
              { "name": "createtable_like_opt_val", "symbols": [lexer_1.lexerAny.has("kw_all") ? { type: "kw_all" } : kw_all] },
              { "name": "createtable_column_constraint$macrocall$2", "symbols": ["createtable_column_constraint_def"] },
              { "name": "createtable_column_constraint$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_constraint") ? { type: "kw_constraint" } : kw_constraint, "word"] },
              { "name": "createtable_column_constraint$macrocall$1$ebnf$1", "symbols": ["createtable_column_constraint$macrocall$1$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "createtable_column_constraint$macrocall$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createtable_column_constraint$macrocall$1", "symbols": ["createtable_column_constraint$macrocall$1$ebnf$1", "createtable_column_constraint$macrocall$2"], "postprocess": (x) => {
                const name2 = x[0] && asName(x[0][1]);
                if (!name2) {
                  return (0, lexer_2.track)(x, unwrap(x[1]));
                }
                return (0, lexer_2.track)(x, {
                  constraintName: name2,
                  ...unwrap(x[1])
                });
              } },
              { "name": "createtable_column_constraint", "symbols": ["createtable_column_constraint$macrocall$1"], "postprocess": unwrap },
              { "name": "createtable_column_constraint_def", "symbols": [lexer_1.lexerAny.has("kw_unique") ? { type: "kw_unique" } : kw_unique], "postprocess": (x) => (0, lexer_2.track)(x, { type: "unique" }) },
              { "name": "createtable_column_constraint_def", "symbols": ["kw_primary_key"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "primary key" }) },
              { "name": "createtable_column_constraint_def", "symbols": ["kw_not_null"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "not null" }) },
              { "name": "createtable_column_constraint_def", "symbols": [lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null], "postprocess": (x) => (0, lexer_2.track)(x, { type: "null" }) },
              { "name": "createtable_column_constraint_def", "symbols": [lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default, "expr"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "default", default: unwrap(x[1]) }) },
              { "name": "createtable_column_constraint_def", "symbols": [lexer_1.lexerAny.has("kw_check") ? { type: "kw_check" } : kw_check, "expr_paren"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "check", expr: unwrap(x[1]) }) },
              { "name": "createtable_column_constraint_def", "symbols": ["createtable_references"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "reference", ...unwrap(x) }) },
              { "name": "createtable_column_constraint_def", "symbols": ["altercol_generated"] },
              { "name": "createtable_collate", "symbols": [lexer_1.lexerAny.has("kw_collate") ? { type: "kw_collate" } : kw_collate, "qualified_name"] },
              { "name": "createtable_opts$subexpression$1", "symbols": ["word"], "postprocess": kw("inherits") },
              { "name": "createtable_opts$macrocall$2", "symbols": ["qname"] },
              { "name": "createtable_opts$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "createtable_opts$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "createtable_opts$macrocall$2"], "postprocess": last },
              { "name": "createtable_opts$macrocall$1$ebnf$1", "symbols": ["createtable_opts$macrocall$1$ebnf$1", "createtable_opts$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtable_opts$macrocall$1", "symbols": ["createtable_opts$macrocall$2", "createtable_opts$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "createtable_opts", "symbols": ["createtable_opts$subexpression$1", "lparen", "createtable_opts$macrocall$1", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, { inherits: x[2] }) },
              { "name": "createindex_statement$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_unique") ? { type: "kw_unique" } : kw_unique], "postprocess": id },
              { "name": "createindex_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createindex_statement$ebnf$2", "symbols": ["kw_ifnotexists"], "postprocess": id },
              { "name": "createindex_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "createindex_statement$ebnf$3", "symbols": ["word"], "postprocess": id },
              { "name": "createindex_statement$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "createindex_statement$ebnf$4$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_using") ? { type: "kw_using" } : kw_using, "ident"], "postprocess": last },
              { "name": "createindex_statement$ebnf$4", "symbols": ["createindex_statement$ebnf$4$subexpression$1"], "postprocess": id },
              { "name": "createindex_statement$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "createindex_statement$ebnf$5", "symbols": ["createindex_with"], "postprocess": id },
              { "name": "createindex_statement$ebnf$5", "symbols": [], "postprocess": () => null },
              { "name": "createindex_statement$ebnf$6", "symbols": ["createindex_tblspace"], "postprocess": id },
              { "name": "createindex_statement$ebnf$6", "symbols": [], "postprocess": () => null },
              { "name": "createindex_statement$ebnf$7", "symbols": ["createindex_predicate"], "postprocess": id },
              { "name": "createindex_statement$ebnf$7", "symbols": [], "postprocess": () => null },
              { "name": "createindex_statement", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "createindex_statement$ebnf$1", "kw_index", "createindex_statement$ebnf$2", "createindex_statement$ebnf$3", lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, "table_ref", "createindex_statement$ebnf$4", "lparen", "createindex_expressions", "rparen", "createindex_statement$ebnf$5", "createindex_statement$ebnf$6", "createindex_statement$ebnf$7"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "create index",
                ...x[1] && { unique: true },
                ...x[3] && { ifNotExists: true },
                ...x[4] && { indexName: asName(x[4]) },
                table: x[6],
                ...x[7] && { using: asName(x[7]) },
                expressions: x[9],
                ...x[11] && { with: x[11] },
                ...x[12] && { tablespace: unwrap(x[12]) },
                ...x[13] && { where: unwrap(x[13]) }
              }) },
              { "name": "createindex_expressions$ebnf$1", "symbols": [] },
              { "name": "createindex_expressions$ebnf$1$subexpression$1", "symbols": ["comma", "createindex_expression"], "postprocess": last },
              { "name": "createindex_expressions$ebnf$1", "symbols": ["createindex_expressions$ebnf$1", "createindex_expressions$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createindex_expressions", "symbols": ["createindex_expression", "createindex_expressions$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "createindex_expression$subexpression$1", "symbols": ["expr_basic"] },
              { "name": "createindex_expression$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "createindex_expression$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_collate") ? { type: "kw_collate" } : kw_collate, "qualified_name"], "postprocess": last },
              { "name": "createindex_expression$ebnf$1", "symbols": ["createindex_expression$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "createindex_expression$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createindex_expression$ebnf$2", "symbols": ["qualified_name"], "postprocess": id },
              { "name": "createindex_expression$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "createindex_expression$ebnf$3$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_asc") ? { type: "kw_asc" } : kw_asc] },
              { "name": "createindex_expression$ebnf$3$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_desc") ? { type: "kw_desc" } : kw_desc] },
              { "name": "createindex_expression$ebnf$3", "symbols": ["createindex_expression$ebnf$3$subexpression$1"], "postprocess": id },
              { "name": "createindex_expression$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "createindex_expression$ebnf$4$subexpression$1$subexpression$1", "symbols": ["kw_first"] },
              { "name": "createindex_expression$ebnf$4$subexpression$1$subexpression$1", "symbols": ["kw_last"] },
              { "name": "createindex_expression$ebnf$4$subexpression$1", "symbols": ["kw_nulls", "createindex_expression$ebnf$4$subexpression$1$subexpression$1"], "postprocess": last },
              { "name": "createindex_expression$ebnf$4", "symbols": ["createindex_expression$ebnf$4$subexpression$1"], "postprocess": id },
              { "name": "createindex_expression$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "createindex_expression", "symbols": ["createindex_expression$subexpression$1", "createindex_expression$ebnf$1", "createindex_expression$ebnf$2", "createindex_expression$ebnf$3", "createindex_expression$ebnf$4"], "postprocess": (x) => (0, lexer_2.track)(x, {
                expression: unwrap(x[0]),
                ...x[1] && { collate: unwrap(x[1]) },
                ...x[2] && { opclass: unwrap(x[2]) },
                ...x[3] && { order: unwrap(x[3]).value },
                ...x[4] && { nulls: unwrap(x[4]) }
              }) },
              { "name": "createindex_predicate", "symbols": [lexer_1.lexerAny.has("kw_where") ? { type: "kw_where" } : kw_where, "expr"], "postprocess": last },
              { "name": "createindex_with$macrocall$2", "symbols": ["createindex_with_item"] },
              { "name": "createindex_with$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "createindex_with$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "createindex_with$macrocall$2"], "postprocess": last },
              { "name": "createindex_with$macrocall$1$ebnf$1", "symbols": ["createindex_with$macrocall$1$ebnf$1", "createindex_with$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createindex_with$macrocall$1", "symbols": ["createindex_with$macrocall$2", "createindex_with$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "createindex_with", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "lparen", "createindex_with$macrocall$1", "rparen"], "postprocess": get2(2) },
              { "name": "createindex_with_item$subexpression$1", "symbols": ["string"] },
              { "name": "createindex_with_item$subexpression$1", "symbols": ["int"] },
              { "name": "createindex_with_item", "symbols": ["ident", lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq, "createindex_with_item$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, { parameter: toStr(x[0]), value: unwrap(x[2]).toString() }) },
              { "name": "createindex_tblspace", "symbols": ["kw_tablespace", "ident"], "postprocess": last },
              { "name": "createextension_statement$ebnf$1", "symbols": ["kw_ifnotexists"], "postprocess": id },
              { "name": "createextension_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createextension_statement$ebnf$2", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with], "postprocess": id },
              { "name": "createextension_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "createextension_statement$ebnf$3$subexpression$1", "symbols": ["kw_schema", "word"], "postprocess": last },
              { "name": "createextension_statement$ebnf$3", "symbols": ["createextension_statement$ebnf$3$subexpression$1"], "postprocess": id },
              { "name": "createextension_statement$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "createextension_statement$ebnf$4$subexpression$1", "symbols": ["kw_version", "string"], "postprocess": last },
              { "name": "createextension_statement$ebnf$4", "symbols": ["createextension_statement$ebnf$4$subexpression$1"], "postprocess": id },
              { "name": "createextension_statement$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "createextension_statement$ebnf$5$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from, "string"], "postprocess": last },
              { "name": "createextension_statement$ebnf$5", "symbols": ["createextension_statement$ebnf$5$subexpression$1"], "postprocess": id },
              { "name": "createextension_statement$ebnf$5", "symbols": [], "postprocess": () => null },
              { "name": "createextension_statement", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "kw_extension", "createextension_statement$ebnf$1", "word", "createextension_statement$ebnf$2", "createextension_statement$ebnf$3", "createextension_statement$ebnf$4", "createextension_statement$ebnf$5"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "create extension",
                ...!!x[2] ? { ifNotExists: true } : {},
                extension: asName(x[3]),
                ...!!x[5] ? { schema: asName(x[5]) } : {},
                ...!!x[6] ? { version: asLit(x[6]) } : {},
                ...!!x[7] ? { from: asLit(x[7]) } : {}
              }) },
              { "name": "simplestatements_all", "symbols": ["simplestatements_start_transaction"] },
              { "name": "simplestatements_all", "symbols": ["simplestatements_commit"] },
              { "name": "simplestatements_all", "symbols": ["simplestatements_rollback"] },
              { "name": "simplestatements_all", "symbols": ["simplestatements_tablespace"] },
              { "name": "simplestatements_all", "symbols": ["simplestatements_set"] },
              { "name": "simplestatements_all", "symbols": ["simplestatements_show"] },
              { "name": "simplestatements_all", "symbols": ["simplestatements_begin"] },
              { "name": "simplestatements_start_transaction$subexpression$1", "symbols": ["kw_start", "kw_transaction"] },
              { "name": "simplestatements_start_transaction", "symbols": ["simplestatements_start_transaction$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "start transaction" }) },
              { "name": "simplestatements_commit", "symbols": ["kw_commit"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "commit" }) },
              { "name": "simplestatements_rollback", "symbols": ["kw_rollback"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "rollback" }) },
              { "name": "simplestatements_tablespace", "symbols": ["kw_tablespace", "word"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "tablespace",
                tablespace: asName(x[1])
              }) },
              { "name": "simplestatements_set$subexpression$1", "symbols": ["simplestatements_set_simple"] },
              { "name": "simplestatements_set$subexpression$1", "symbols": ["simplestatements_set_timezone"] },
              { "name": "simplestatements_set", "symbols": ["kw_set", "simplestatements_set$subexpression$1"], "postprocess": last },
              { "name": "simplestatements_set_timezone", "symbols": ["kw_time", "kw_zone", "simplestatements_set_timezone_val"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "set timezone", to: x[2] }) },
              { "name": "simplestatements_set_timezone_val$subexpression$1", "symbols": ["string"] },
              { "name": "simplestatements_set_timezone_val$subexpression$1", "symbols": ["int"] },
              { "name": "simplestatements_set_timezone_val", "symbols": ["simplestatements_set_timezone_val$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "value", value: unwrap(x[0]) }) },
              { "name": "simplestatements_set_timezone_val", "symbols": ["kw_local"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "local" }) },
              { "name": "simplestatements_set_timezone_val", "symbols": [lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default], "postprocess": (x) => (0, lexer_2.track)(x, { type: "default" }) },
              { "name": "simplestatements_set_timezone_val", "symbols": ["kw_interval", "string", "kw_hour", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "kw_minute"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "interval", value: (0, lexer_2.unbox)(x[1]) }) },
              { "name": "simplestatements_set_simple$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq] },
              { "name": "simplestatements_set_simple$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to] },
              { "name": "simplestatements_set_simple", "symbols": ["ident", "simplestatements_set_simple$subexpression$1", "simplestatements_set_val"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "set",
                variable: asName(x[0]),
                set: (0, lexer_2.unbox)(x[2])
              }) },
              { "name": "simplestatements_set_val", "symbols": ["simplestatements_set_val_raw"], "postprocess": unwrap },
              { "name": "simplestatements_set_val", "symbols": [lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default], "postprocess": (x) => (0, lexer_2.track)(x, { type: "default" }) },
              { "name": "simplestatements_set_val$ebnf$1$subexpression$1", "symbols": ["comma", "simplestatements_set_val_raw"] },
              { "name": "simplestatements_set_val$ebnf$1", "symbols": ["simplestatements_set_val$ebnf$1$subexpression$1"] },
              { "name": "simplestatements_set_val$ebnf$1$subexpression$2", "symbols": ["comma", "simplestatements_set_val_raw"] },
              { "name": "simplestatements_set_val$ebnf$1", "symbols": ["simplestatements_set_val$ebnf$1", "simplestatements_set_val$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "simplestatements_set_val", "symbols": ["simplestatements_set_val_raw", "simplestatements_set_val$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "list",
                values: [x[0], ...x[1] || []]
              }) },
              { "name": "simplestatements_set_val_raw$subexpression$1", "symbols": ["string"] },
              { "name": "simplestatements_set_val_raw$subexpression$1", "symbols": ["int"] },
              { "name": "simplestatements_set_val_raw", "symbols": ["simplestatements_set_val_raw$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "value", value: unwrap(x) }) },
              { "name": "simplestatements_set_val_raw$subexpression$2", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word] },
              { "name": "simplestatements_set_val_raw$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on] },
              { "name": "simplestatements_set_val_raw$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_true") ? { type: "kw_true" } : kw_true] },
              { "name": "simplestatements_set_val_raw$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_false") ? { type: "kw_false" } : kw_false] },
              { "name": "simplestatements_set_val_raw", "symbols": ["simplestatements_set_val_raw$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "identifier", name: unwrap(x).value }) },
              { "name": "simplestatements_set_val_raw", "symbols": [lexer_1.lexerAny.has("quoted_word") ? { type: "quoted_word" } : quoted_word], "postprocess": (x) => (0, lexer_2.track)(x, { type: "identifier", doubleQuoted: true, name: unwrap(x).value }) },
              { "name": "simplestatements_show", "symbols": ["kw_show", "ident"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "show", variable: asName(x[1]) }) },
              { "name": "create_schema$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "kw_schema"] },
              { "name": "create_schema$ebnf$1", "symbols": ["kw_ifnotexists"], "postprocess": id },
              { "name": "create_schema$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_schema", "symbols": ["create_schema$subexpression$1", "create_schema$ebnf$1", "ident"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "create schema",
                name: asName(x[2]),
                ...!!x[1] ? { ifNotExists: true } : {}
              }) },
              { "name": "raise_statement$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": anyKw("debug", "log", "info", "notice", "warning", "exception") },
              { "name": "raise_statement$ebnf$1", "symbols": ["raise_statement$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "raise_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "raise_statement$ebnf$2$subexpression$1", "symbols": ["comma", "expr_list_raw"], "postprocess": last },
              { "name": "raise_statement$ebnf$2", "symbols": ["raise_statement$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "raise_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "raise_statement$ebnf$3", "symbols": ["raise_using"], "postprocess": id },
              { "name": "raise_statement$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "raise_statement", "symbols": ["kw_raise", "raise_statement$ebnf$1", "string", "raise_statement$ebnf$2", "raise_statement$ebnf$3"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "raise",
                format: toStr(x[2]),
                ...x[1] && { level: toStr(x[1]) },
                ...x[3] && x[3].length && { formatExprs: x[3] },
                ...x[4] && x[4].length && { using: x[4] }
              }) },
              { "name": "raise_using$macrocall$2", "symbols": ["raise_using_one"] },
              { "name": "raise_using$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "raise_using$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "raise_using$macrocall$2"], "postprocess": last },
              { "name": "raise_using$macrocall$1$ebnf$1", "symbols": ["raise_using$macrocall$1$ebnf$1", "raise_using$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "raise_using$macrocall$1", "symbols": ["raise_using$macrocall$2", "raise_using$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "raise_using", "symbols": [lexer_1.lexerAny.has("kw_using") ? { type: "kw_using" } : kw_using, "raise_using$macrocall$1"], "postprocess": last },
              { "name": "raise_using_one", "symbols": ["raise_using_what", lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq, "expr"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: toStr(x[0]),
                value: x[2]
              }) },
              { "name": "raise_using_what", "symbols": [lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table] },
              { "name": "raise_using_what", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": anyKw("message", "detail", "hint", "errcode", "column", "constraint", "datatype", "schema") },
              { "name": "comment_statement", "symbols": ["kw_comment", lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, "comment_what", lexer_1.lexerAny.has("kw_is") ? { type: "kw_is" } : kw_is, "string"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "comment",
                comment: (0, lexer_2.unbox)(last(x)),
                on: unwrap(x[2])
              }) },
              { "name": "comment_what", "symbols": ["comment_what_col"] },
              { "name": "comment_what", "symbols": ["comment_what_nm"] },
              { "name": "comment_what_nm$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table] },
              { "name": "comment_what_nm$subexpression$1", "symbols": ["kw_materialized", "kw_view"] },
              { "name": "comment_what_nm$subexpression$1", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": anyKw("database", "index", "trigger", "type", "view") },
              { "name": "comment_what_nm", "symbols": ["comment_what_nm$subexpression$1", "qualified_name"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: toStr(x[0]),
                name: x[1]
              }) },
              { "name": "comment_what_col", "symbols": ["kw_column", "qcolumn"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "column",
                column: last(x)
              }) },
              { "name": "simplestatements_begin$ebnf$1$subexpression$1", "symbols": ["kw_transaction"] },
              { "name": "simplestatements_begin$ebnf$1$subexpression$1", "symbols": ["kw_work"] },
              { "name": "simplestatements_begin$ebnf$1", "symbols": ["simplestatements_begin$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "simplestatements_begin$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "simplestatements_begin$ebnf$2", "symbols": [] },
              { "name": "simplestatements_begin$ebnf$2$subexpression$1", "symbols": ["simplestatements_begin_isol"] },
              { "name": "simplestatements_begin$ebnf$2$subexpression$1", "symbols": ["simplestatements_begin_writ"] },
              { "name": "simplestatements_begin$ebnf$2$subexpression$1", "symbols": ["simplestatements_begin_def"] },
              { "name": "simplestatements_begin$ebnf$2", "symbols": ["simplestatements_begin$ebnf$2", "simplestatements_begin$ebnf$2$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              {
                "name": "simplestatements_begin",
                "symbols": ["kw_begin", "simplestatements_begin$ebnf$1", "simplestatements_begin$ebnf$2"],
                "postprocess": (x) => (0, lexer_2.track)(x, {
                  type: "begin",
                  ...x[2].reduce((a, b) => ({ ...unwrap(a), ...unwrap(b) }), {})
                })
              },
              { "name": "simplestatements_begin_isol$subexpression$1", "symbols": ["kw_isolation", "kw_level"] },
              { "name": "simplestatements_begin_isol$subexpression$2", "symbols": ["kw_serializable"] },
              { "name": "simplestatements_begin_isol$subexpression$2$subexpression$1", "symbols": ["word"], "postprocess": kw("repeatable") },
              { "name": "simplestatements_begin_isol$subexpression$2", "symbols": ["simplestatements_begin_isol$subexpression$2$subexpression$1", "kw_read"] },
              { "name": "simplestatements_begin_isol$subexpression$2$subexpression$2", "symbols": ["word"], "postprocess": kw("committed") },
              { "name": "simplestatements_begin_isol$subexpression$2", "symbols": ["kw_read", "simplestatements_begin_isol$subexpression$2$subexpression$2"] },
              { "name": "simplestatements_begin_isol$subexpression$2$subexpression$3", "symbols": ["word"], "postprocess": kw("uncommitted") },
              { "name": "simplestatements_begin_isol$subexpression$2", "symbols": ["kw_read", "simplestatements_begin_isol$subexpression$2$subexpression$3"] },
              { "name": "simplestatements_begin_isol", "symbols": ["simplestatements_begin_isol$subexpression$1", "simplestatements_begin_isol$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                isolationLevel: toStr(x[1], " ")
              }) },
              { "name": "simplestatements_begin_writ$subexpression$1", "symbols": ["kw_read", "kw_write"] },
              { "name": "simplestatements_begin_writ$subexpression$1", "symbols": ["kw_read", lexer_1.lexerAny.has("kw_only") ? { type: "kw_only" } : kw_only] },
              { "name": "simplestatements_begin_writ", "symbols": ["simplestatements_begin_writ$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                writeable: toStr(x, " ")
              }) },
              { "name": "simplestatements_begin_def$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not], "postprocess": id },
              { "name": "simplestatements_begin_def$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "simplestatements_begin_def", "symbols": ["simplestatements_begin_def$ebnf$1", lexer_1.lexerAny.has("kw_deferrable") ? { type: "kw_deferrable" } : kw_deferrable], "postprocess": (x) => (0, lexer_2.track)(x, {
                deferrable: !x[0]
              }) },
              { "name": "insert_statement$subexpression$1", "symbols": ["kw_insert", lexer_1.lexerAny.has("kw_into") ? { type: "kw_into" } : kw_into] },
              { "name": "insert_statement$ebnf$1", "symbols": ["collist_paren"], "postprocess": id },
              { "name": "insert_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "insert_statement$ebnf$2$subexpression$1$subexpression$1", "symbols": ["kw_system"] },
              { "name": "insert_statement$ebnf$2$subexpression$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_user") ? { type: "kw_user" } : kw_user] },
              { "name": "insert_statement$ebnf$2$subexpression$1", "symbols": ["kw_overriding", "insert_statement$ebnf$2$subexpression$1$subexpression$1", "kw_value"], "postprocess": get2(1) },
              { "name": "insert_statement$ebnf$2", "symbols": ["insert_statement$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "insert_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "insert_statement$ebnf$3$subexpression$1", "symbols": ["selection"] },
              { "name": "insert_statement$ebnf$3$subexpression$1", "symbols": ["selection_paren"] },
              { "name": "insert_statement$ebnf$3", "symbols": ["insert_statement$ebnf$3$subexpression$1"], "postprocess": id },
              { "name": "insert_statement$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "insert_statement$ebnf$4$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, "kw_conflict", "insert_on_conflict"], "postprocess": last },
              { "name": "insert_statement$ebnf$4", "symbols": ["insert_statement$ebnf$4$subexpression$1"], "postprocess": id },
              { "name": "insert_statement$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "insert_statement$ebnf$5$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_returning") ? { type: "kw_returning" } : kw_returning, "select_expr_list_aliased"], "postprocess": last },
              { "name": "insert_statement$ebnf$5", "symbols": ["insert_statement$ebnf$5$subexpression$1"], "postprocess": id },
              { "name": "insert_statement$ebnf$5", "symbols": [], "postprocess": () => null },
              { "name": "insert_statement", "symbols": ["insert_statement$subexpression$1", "table_ref_aliased", "insert_statement$ebnf$1", "insert_statement$ebnf$2", "insert_statement$ebnf$3", "insert_statement$ebnf$4", "insert_statement$ebnf$5"], "postprocess": (x) => {
                const columns = x[2] && x[2].map(asName);
                const overriding = toStr(x[3]);
                const insert = unwrap(x[4]);
                const onConflict = x[5];
                const returning = x[6];
                return (0, lexer_2.track)(x, {
                  type: "insert",
                  into: unwrap(x[1]),
                  insert,
                  ...overriding && { overriding },
                  ...columns && { columns },
                  ...returning && { returning },
                  ...onConflict && { onConflict }
                });
              } },
              { "name": "insert_values$ebnf$1", "symbols": [] },
              { "name": "insert_values$ebnf$1$subexpression$1", "symbols": ["comma", "insert_value"], "postprocess": last },
              { "name": "insert_values$ebnf$1", "symbols": ["insert_values$ebnf$1", "insert_values$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "insert_values", "symbols": ["insert_value", "insert_values$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "insert_value", "symbols": ["lparen", "insert_expr_list_raw", "rparen"], "postprocess": get2(1) },
              { "name": "insert_expr_list_raw$ebnf$1", "symbols": [] },
              { "name": "insert_expr_list_raw$ebnf$1$subexpression$1", "symbols": ["comma", "expr_or_select"], "postprocess": last },
              { "name": "insert_expr_list_raw$ebnf$1", "symbols": ["insert_expr_list_raw$ebnf$1", "insert_expr_list_raw$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "insert_expr_list_raw", "symbols": ["expr_or_select", "insert_expr_list_raw$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "insert_on_conflict$ebnf$1", "symbols": ["insert_on_conflict_what"], "postprocess": id },
              { "name": "insert_on_conflict$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "insert_on_conflict", "symbols": ["insert_on_conflict$ebnf$1", "insert_on_conflict_do"], "postprocess": (x) => (0, lexer_2.track)(x, {
                ...x[0] ? { on: unwrap(x[0]) } : {},
                ...x[1]
              }) },
              { "name": "insert_on_conflict_what", "symbols": ["lparen", "expr_list_raw", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "on expr",
                exprs: x[1]
              }) },
              { "name": "insert_on_conflict_what", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, lexer_1.lexerAny.has("kw_constraint") ? { type: "kw_constraint" } : kw_constraint, "qname"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "on constraint",
                constraint: last(x)
              }) },
              { "name": "insert_on_conflict_do", "symbols": [lexer_1.lexerAny.has("kw_do") ? { type: "kw_do" } : kw_do, "kw_nothing"], "postprocess": (x) => ({ do: "do nothing" }) },
              { "name": "insert_on_conflict_do$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_do") ? { type: "kw_do" } : kw_do, "kw_update", "kw_set"] },
              { "name": "insert_on_conflict_do$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_where") ? { type: "kw_where" } : kw_where, "expr"], "postprocess": last },
              { "name": "insert_on_conflict_do$ebnf$1", "symbols": ["insert_on_conflict_do$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "insert_on_conflict_do$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "insert_on_conflict_do", "symbols": ["insert_on_conflict_do$subexpression$1", "update_set_list", "insert_on_conflict_do$ebnf$1"], "postprocess": (x) => ({
                do: { sets: x[1] },
                ...x[2] && { where: x[2] }
              }) },
              { "name": "update_statement$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from, "select_from_subject"], "postprocess": last },
              { "name": "update_statement$ebnf$1", "symbols": ["update_statement$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "update_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "update_statement$ebnf$2", "symbols": ["select_where"], "postprocess": id },
              { "name": "update_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "update_statement$ebnf$3$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_returning") ? { type: "kw_returning" } : kw_returning, "select_expr_list_aliased"], "postprocess": last },
              { "name": "update_statement$ebnf$3", "symbols": ["update_statement$ebnf$3$subexpression$1"], "postprocess": id },
              { "name": "update_statement$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "update_statement", "symbols": ["kw_update", "table_ref_aliased", "kw_set", "update_set_list", "update_statement$ebnf$1", "update_statement$ebnf$2", "update_statement$ebnf$3"], "postprocess": (x) => {
                const from = unwrap(x[4]);
                const where = unwrap(x[5]);
                const returning = x[6];
                return (0, lexer_2.track)(x, {
                  type: "update",
                  table: unwrap(x[1]),
                  sets: x[3],
                  ...where ? { where } : {},
                  ...from ? { from } : {},
                  ...returning ? { returning } : {}
                });
              } },
              { "name": "update_set_list$ebnf$1", "symbols": [] },
              { "name": "update_set_list$ebnf$1$subexpression$1", "symbols": ["comma", "update_set"], "postprocess": last },
              { "name": "update_set_list$ebnf$1", "symbols": ["update_set_list$ebnf$1", "update_set_list$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "update_set_list", "symbols": ["update_set", "update_set_list$ebnf$1"], "postprocess": ([head, tail]) => {
                const ret = [];
                for (const _t of [head, ...tail || []]) {
                  const t = unwrap(_t);
                  if (Array.isArray(t)) {
                    ret.push(...t);
                  } else {
                    ret.push(t);
                  }
                }
                return ret;
              } },
              { "name": "update_set", "symbols": ["update_set_one"] },
              { "name": "update_set", "symbols": ["update_set_multiple"] },
              { "name": "update_set_one", "symbols": ["ident", lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq, "expr"], "postprocess": (x) => (0, lexer_2.box)(x, {
                column: asName(x[0]),
                value: unwrap(x[2])
              }) },
              { "name": "update_set_multiple$subexpression$1", "symbols": ["lparen", "expr_list_raw", "rparen"], "postprocess": get2(1) },
              { "name": "update_set_multiple", "symbols": ["collist_paren", lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq, "update_set_multiple$subexpression$1"], "postprocess": (x) => {
                const cols = x[0];
                const exprs = x[2];
                if (cols.length !== exprs.length) {
                  throw new Error("number of columns does not match number of values");
                }
                return (0, lexer_2.box)(x, cols.map((x2, i) => ({
                  column: asName(x2),
                  value: unwrap(exprs[i])
                })));
              } },
              { "name": "altertable_statement$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id },
              { "name": "altertable_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altertable_statement$ebnf$2", "symbols": [lexer_1.lexerAny.has("kw_only") ? { type: "kw_only" } : kw_only], "postprocess": id },
              { "name": "altertable_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "altertable_statement", "symbols": ["kw_alter", lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table, "altertable_statement$ebnf$1", "altertable_statement$ebnf$2", "table_ref", "altertable_actions"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "alter table",
                ...x[2] ? { ifExists: true } : {},
                ...x[3] ? { only: true } : {},
                table: unwrap(x[4]),
                changes: (0, lexer_2.unbox)(x[5]).map(unwrap)
              }) },
              { "name": "altertable_actions$ebnf$1", "symbols": [] },
              { "name": "altertable_actions$ebnf$1$subexpression$1", "symbols": ["comma", "altertable_action"], "postprocess": last },
              { "name": "altertable_actions$ebnf$1", "symbols": ["altertable_actions$ebnf$1", "altertable_actions$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "altertable_actions", "symbols": ["altertable_action", "altertable_actions$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "altertable_action", "symbols": ["altertable_rename_table"] },
              { "name": "altertable_action", "symbols": ["altertable_rename_column"] },
              { "name": "altertable_action", "symbols": ["altertable_rename_constraint"] },
              { "name": "altertable_action", "symbols": ["altertable_add_column"] },
              { "name": "altertable_action", "symbols": ["altertable_drop_column"] },
              { "name": "altertable_action", "symbols": ["altertable_alter_column"] },
              { "name": "altertable_action", "symbols": ["altertable_add_constraint"] },
              { "name": "altertable_action", "symbols": ["altertable_drop_constraint"] },
              { "name": "altertable_action", "symbols": ["altertable_owner"] },
              { "name": "altertable_rename_table", "symbols": ["kw_rename", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "word"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "rename",
                to: asName(last(x))
              }) },
              { "name": "altertable_rename_column$ebnf$1", "symbols": ["kw_column"], "postprocess": id },
              { "name": "altertable_rename_column$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altertable_rename_column", "symbols": ["kw_rename", "altertable_rename_column$ebnf$1", "ident", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "ident"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "rename column",
                column: asName(x[2]),
                to: asName(last(x))
              }) },
              { "name": "altertable_rename_constraint", "symbols": ["kw_rename", lexer_1.lexerAny.has("kw_constraint") ? { type: "kw_constraint" } : kw_constraint, "ident", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "ident"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "rename constraint",
                constraint: asName(x[2]),
                to: asName(last(x))
              }) },
              { "name": "altertable_add_column$ebnf$1", "symbols": ["kw_column"], "postprocess": id },
              { "name": "altertable_add_column$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altertable_add_column$ebnf$2", "symbols": ["kw_ifnotexists"], "postprocess": id },
              { "name": "altertable_add_column$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "altertable_add_column", "symbols": ["kw_add", "altertable_add_column$ebnf$1", "altertable_add_column$ebnf$2", "createtable_column"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "add column",
                ...x[2] ? { ifNotExists: true } : {},
                column: unwrap(x[3])
              }) },
              { "name": "altertable_drop_column$ebnf$1", "symbols": ["kw_column"], "postprocess": id },
              { "name": "altertable_drop_column$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altertable_drop_column$ebnf$2", "symbols": ["kw_ifexists"], "postprocess": id },
              { "name": "altertable_drop_column$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "altertable_drop_column$ebnf$3$subexpression$1", "symbols": ["kw_restrict"] },
              { "name": "altertable_drop_column$ebnf$3$subexpression$1", "symbols": ["kw_cascade"] },
              { "name": "altertable_drop_column$ebnf$3", "symbols": ["altertable_drop_column$ebnf$3$subexpression$1"], "postprocess": id },
              { "name": "altertable_drop_column$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "altertable_drop_column", "symbols": ["kw_drop", "altertable_drop_column$ebnf$1", "altertable_drop_column$ebnf$2", "ident", "altertable_drop_column$ebnf$3"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "drop column",
                ...x[2] ? { ifExists: true } : {},
                column: asName(x[3]),
                ...x[4] ? { behaviour: toStr(x[4], " ") } : {}
              }) },
              { "name": "altertable_alter_column$ebnf$1", "symbols": ["kw_column"], "postprocess": id },
              { "name": "altertable_alter_column$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altertable_alter_column", "symbols": ["kw_alter", "altertable_alter_column$ebnf$1", "ident", "altercol"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "alter column",
                column: asName(x[2]),
                alter: unwrap(x[3])
              }) },
              { "name": "altercol$ebnf$1$subexpression$1", "symbols": ["kw_set", "kw_data"] },
              { "name": "altercol$ebnf$1", "symbols": ["altercol$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "altercol$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altercol", "symbols": ["altercol$ebnf$1", "kw_type", "data_type"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "set type", dataType: unwrap(last(x)) }) },
              { "name": "altercol", "symbols": ["kw_set", lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default, "expr"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "set default", default: unwrap(last(x)) }) },
              { "name": "altercol", "symbols": ["kw_drop", lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default], "postprocess": (x) => (0, lexer_2.track)(x, { type: "drop default" }) },
              { "name": "altercol$subexpression$1", "symbols": ["kw_set"] },
              { "name": "altercol$subexpression$1", "symbols": ["kw_drop"] },
              { "name": "altercol", "symbols": ["altercol$subexpression$1", "kw_not_null"], "postprocess": (x) => (0, lexer_2.track)(x, { type: toStr(x, " ") }) },
              { "name": "altercol", "symbols": ["altercol_generated_add"], "postprocess": unwrap },
              { "name": "altertable_add_constraint", "symbols": ["kw_add", "createtable_constraint"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "add constraint",
                constraint: unwrap(last(x))
              }) },
              { "name": "altertable_drop_constraint$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id },
              { "name": "altertable_drop_constraint$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altertable_drop_constraint$ebnf$2$subexpression$1", "symbols": ["kw_restrict"] },
              { "name": "altertable_drop_constraint$ebnf$2$subexpression$1", "symbols": ["kw_cascade"] },
              { "name": "altertable_drop_constraint$ebnf$2", "symbols": ["altertable_drop_constraint$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "altertable_drop_constraint$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "altertable_drop_constraint", "symbols": ["kw_drop", lexer_1.lexerAny.has("kw_constraint") ? { type: "kw_constraint" } : kw_constraint, "altertable_drop_constraint$ebnf$1", "ident", "altertable_drop_constraint$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "drop constraint",
                ...x[2] ? { ifExists: true } : {},
                constraint: asName(x[3]),
                ...x[4] ? { behaviour: toStr(x[4], " ") } : {}
              }) },
              { "name": "altertable_owner", "symbols": ["kw_owner", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "ident"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "owner",
                to: asName(last(x))
              }) },
              { "name": "altercol_generated_add", "symbols": ["kw_add", "altercol_generated"], "postprocess": last },
              { "name": "altercol_generated$ebnf$1$subexpression$1", "symbols": ["kw_always"] },
              { "name": "altercol_generated$ebnf$1$subexpression$1", "symbols": ["kw_by", lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default] },
              { "name": "altercol_generated$ebnf$1", "symbols": ["altercol_generated$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "altercol_generated$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altercol_generated$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "kw_identity"] },
              { "name": "altercol_generated$ebnf$2$subexpression$1", "symbols": ["lparen", "altercol_generated_seq", "rparen"], "postprocess": get2(1) },
              { "name": "altercol_generated$ebnf$2", "symbols": ["altercol_generated$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "altercol_generated$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "altercol_generated", "symbols": ["kw_generated", "altercol_generated$ebnf$1", "altercol_generated$subexpression$1", "altercol_generated$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "add generated",
                ...x[1] && { always: toStr(x[1], " ") },
                ...x[3] && { sequence: unwrap(x[3]) }
              }) },
              { "name": "altercol_generated_seq$ebnf$1$subexpression$1", "symbols": ["kw_sequence", "kw_name", "qualified_name"] },
              { "name": "altercol_generated_seq$ebnf$1", "symbols": ["altercol_generated_seq$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "altercol_generated_seq$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altercol_generated_seq$ebnf$2", "symbols": [] },
              { "name": "altercol_generated_seq$ebnf$2", "symbols": ["altercol_generated_seq$ebnf$2", "create_sequence_option"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "altercol_generated_seq", "symbols": ["altercol_generated_seq$ebnf$1", "altercol_generated_seq$ebnf$2"], "postprocess": (x) => {
                const ret = {
                  ...x[0] && { name: unwrap(last(x[0])) }
                };
                setSeqOpts(ret, x[1]);
                return (0, lexer_2.track)(x, ret);
              } },
              { "name": "alterindex_statement$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id },
              { "name": "alterindex_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "alterindex_statement", "symbols": ["kw_alter", "kw_index", "alterindex_statement$ebnf$1", "table_ref", "alterindex_action"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "alter index",
                ...x[2] ? { ifExists: true } : {},
                index: unwrap(x[3]),
                change: unwrap(x[4])
              }) },
              { "name": "alterindex_action", "symbols": ["alterindex_rename"] },
              { "name": "alterindex_action", "symbols": ["alterindex_set_tablespace"] },
              { "name": "alterindex_rename", "symbols": ["kw_rename", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "word"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "rename",
                to: asName(last(x))
              }) },
              { "name": "alterindex_set_tablespace", "symbols": ["kw_set", "kw_tablespace", "word"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "set tablespace",
                tablespace: asName(last(x))
              }) },
              { "name": "delete_statement", "symbols": ["delete_delete"] },
              { "name": "delete_statement", "symbols": ["delete_truncate"] },
              { "name": "delete_delete$subexpression$1", "symbols": ["kw_delete", lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from] },
              { "name": "delete_delete$ebnf$1", "symbols": ["select_where"], "postprocess": id },
              { "name": "delete_delete$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "delete_delete$ebnf$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_returning") ? { type: "kw_returning" } : kw_returning, "select_expr_list_aliased"], "postprocess": last },
              { "name": "delete_delete$ebnf$2", "symbols": ["delete_delete$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "delete_delete$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "delete_delete", "symbols": ["delete_delete$subexpression$1", "table_ref_aliased", "delete_delete$ebnf$1", "delete_delete$ebnf$2"], "postprocess": (x) => {
                const where = x[2];
                const returning = x[3];
                return (0, lexer_2.track)(x, {
                  type: "delete",
                  from: unwrap(x[1]),
                  ...where ? { where } : {},
                  ...returning ? { returning } : {}
                });
              } },
              { "name": "delete_truncate$subexpression$1$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table], "postprocess": id },
              { "name": "delete_truncate$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "delete_truncate$subexpression$1", "symbols": ["kw_truncate", "delete_truncate$subexpression$1$ebnf$1"] },
              { "name": "delete_truncate$macrocall$2", "symbols": ["table_ref"] },
              { "name": "delete_truncate$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "delete_truncate$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "delete_truncate$macrocall$2"], "postprocess": last },
              { "name": "delete_truncate$macrocall$1$ebnf$1", "symbols": ["delete_truncate$macrocall$1$ebnf$1", "delete_truncate$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "delete_truncate$macrocall$1", "symbols": ["delete_truncate$macrocall$2", "delete_truncate$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "delete_truncate$ebnf$1$subexpression$1$subexpression$1", "symbols": ["kw_restart"] },
              { "name": "delete_truncate$ebnf$1$subexpression$1$subexpression$1", "symbols": ["kw_continue"] },
              { "name": "delete_truncate$ebnf$1$subexpression$1", "symbols": ["delete_truncate$ebnf$1$subexpression$1$subexpression$1", "kw_identity"] },
              { "name": "delete_truncate$ebnf$1", "symbols": ["delete_truncate$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "delete_truncate$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "delete_truncate$ebnf$2$subexpression$1", "symbols": ["kw_restrict"] },
              { "name": "delete_truncate$ebnf$2$subexpression$1", "symbols": ["kw_cascade"] },
              { "name": "delete_truncate$ebnf$2", "symbols": ["delete_truncate$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "delete_truncate$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "delete_truncate", "symbols": ["delete_truncate$subexpression$1", "delete_truncate$macrocall$1", "delete_truncate$ebnf$1", "delete_truncate$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "truncate table",
                tables: x[1],
                ...x[2] && { identity: toStr(x[2][0]) },
                ...x[3] && { cascade: toStr(x[3]) }
              }) },
              { "name": "create_sequence_statement$ebnf$1$subexpression$1", "symbols": ["kw_temp"] },
              { "name": "create_sequence_statement$ebnf$1$subexpression$1", "symbols": ["kw_temporary"] },
              { "name": "create_sequence_statement$ebnf$1", "symbols": ["create_sequence_statement$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "create_sequence_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_sequence_statement$ebnf$2", "symbols": ["kw_ifnotexists"], "postprocess": id },
              { "name": "create_sequence_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "create_sequence_statement$ebnf$3", "symbols": [] },
              { "name": "create_sequence_statement$ebnf$3", "symbols": ["create_sequence_statement$ebnf$3", "create_sequence_option"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "create_sequence_statement", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "create_sequence_statement$ebnf$1", "kw_sequence", "create_sequence_statement$ebnf$2", "qualified_name", "create_sequence_statement$ebnf$3"], "postprocess": (x) => {
                const ret = {
                  type: "create sequence",
                  ...x[1] && { temp: true },
                  ...x[3] && { ifNotExists: true },
                  name: unwrap(x[4]),
                  options: {}
                };
                setSeqOpts(ret.options, x[5]);
                return (0, lexer_2.track)(x, ret);
              } },
              { "name": "create_sequence_option", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "data_type"], "postprocess": (x) => (0, lexer_2.box)(x, ["as", x[1]]) },
              { "name": "create_sequence_option$ebnf$1", "symbols": ["kw_by"], "postprocess": id },
              { "name": "create_sequence_option$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_sequence_option", "symbols": ["kw_increment", "create_sequence_option$ebnf$1", "int"], "postprocess": (x) => (0, lexer_2.box)(x, ["incrementBy", x[2]]) },
              { "name": "create_sequence_option", "symbols": ["create_sequence_minvalue"], "postprocess": (x) => (0, lexer_2.box)(x, ["minValue", x[0]]) },
              { "name": "create_sequence_option", "symbols": ["create_sequence_maxvalue"], "postprocess": (x) => (0, lexer_2.box)(x, ["maxValue", x[0]]) },
              { "name": "create_sequence_option$ebnf$2", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with], "postprocess": id },
              { "name": "create_sequence_option$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "create_sequence_option", "symbols": ["kw_start", "create_sequence_option$ebnf$2", "int"], "postprocess": (x) => (0, lexer_2.box)(x, ["startWith", x[2]]) },
              { "name": "create_sequence_option", "symbols": ["kw_cache", "int"], "postprocess": (x) => (0, lexer_2.box)(x, ["cache", x[1]]) },
              { "name": "create_sequence_option$ebnf$3", "symbols": ["kw_no"], "postprocess": id },
              { "name": "create_sequence_option$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "create_sequence_option", "symbols": ["create_sequence_option$ebnf$3", "kw_cycle"], "postprocess": (x) => (0, lexer_2.box)(x, ["cycle", toStr(x, " ")]) },
              { "name": "create_sequence_option", "symbols": ["create_sequence_owned_by"], "postprocess": (x) => (0, lexer_2.box)(x, ["ownedBy", unwrap(x)]) },
              { "name": "create_sequence_minvalue", "symbols": ["kw_minvalue", "int"], "postprocess": last },
              { "name": "create_sequence_minvalue", "symbols": ["kw_no", "kw_minvalue"], "postprocess": (x) => (0, lexer_2.box)(x, "no minvalue") },
              { "name": "create_sequence_maxvalue", "symbols": ["kw_maxvalue", "int"], "postprocess": last },
              { "name": "create_sequence_maxvalue", "symbols": ["kw_no", "kw_maxvalue"], "postprocess": (x) => (0, lexer_2.box)(x, "no maxvalue") },
              { "name": "create_sequence_owned_by$subexpression$1", "symbols": ["kw_none"] },
              { "name": "create_sequence_owned_by$subexpression$1", "symbols": ["qcolumn"] },
              { "name": "create_sequence_owned_by", "symbols": ["kw_owned", "kw_by", "create_sequence_owned_by$subexpression$1"], "postprocess": (x) => (0, lexer_2.box)(x, unwrap(last(x))) },
              { "name": "alter_sequence_statement$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id },
              { "name": "alter_sequence_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "alter_sequence_statement", "symbols": ["kw_alter", "kw_sequence", "alter_sequence_statement$ebnf$1", "qualified_name", "alter_sequence_statement_body"], "postprocess": (x) => {
                const ret = {
                  type: "alter sequence",
                  ...x[2] && { ifExists: true },
                  name: unwrap(x[3]),
                  change: x[4]
                };
                return (0, lexer_2.track)(x, ret);
              } },
              { "name": "alter_sequence_statement_body$ebnf$1", "symbols": ["alter_sequence_option"] },
              { "name": "alter_sequence_statement_body$ebnf$1", "symbols": ["alter_sequence_statement_body$ebnf$1", "alter_sequence_option"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "alter_sequence_statement_body", "symbols": ["alter_sequence_statement_body$ebnf$1"], "postprocess": (x) => {
                const ret = {
                  type: "set options"
                };
                setSeqOpts(ret, x[0]);
                return (0, lexer_2.track)(x, ret);
              } },
              { "name": "alter_sequence_statement_body$subexpression$1", "symbols": ["ident"] },
              { "name": "alter_sequence_statement_body$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_session_user") ? { type: "kw_session_user" } : kw_session_user] },
              { "name": "alter_sequence_statement_body$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_current_user") ? { type: "kw_current_user" } : kw_current_user] },
              { "name": "alter_sequence_statement_body", "symbols": ["kw_owner", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "alter_sequence_statement_body$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "owner to", owner: asName(last(x)) }) },
              { "name": "alter_sequence_statement_body", "symbols": ["kw_rename", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "ident"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "rename", newName: asName(last(x)) }) },
              { "name": "alter_sequence_statement_body", "symbols": ["kw_set", "kw_schema", "ident"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "set schema", newSchema: asName(last(x)) }) },
              { "name": "alter_sequence_option", "symbols": ["create_sequence_option"], "postprocess": unwrap },
              { "name": "alter_sequence_option$ebnf$1$subexpression$1$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with], "postprocess": id },
              { "name": "alter_sequence_option$ebnf$1$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "alter_sequence_option$ebnf$1$subexpression$1", "symbols": ["alter_sequence_option$ebnf$1$subexpression$1$ebnf$1", "int"], "postprocess": last },
              { "name": "alter_sequence_option$ebnf$1", "symbols": ["alter_sequence_option$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "alter_sequence_option$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "alter_sequence_option", "symbols": ["kw_restart", "alter_sequence_option$ebnf$1"], "postprocess": (x) => (0, lexer_2.box)(x, ["restart", typeof (0, lexer_2.unbox)(x[1]) === "number" ? (0, lexer_2.unbox)(x[1]) : true]) },
              { "name": "drop_statement$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id },
              { "name": "drop_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "drop_statement$macrocall$2", "symbols": ["qualified_name"] },
              { "name": "drop_statement$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "drop_statement$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "drop_statement$macrocall$2"], "postprocess": last },
              { "name": "drop_statement$macrocall$1$ebnf$1", "symbols": ["drop_statement$macrocall$1$ebnf$1", "drop_statement$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "drop_statement$macrocall$1", "symbols": ["drop_statement$macrocall$2", "drop_statement$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "drop_statement$ebnf$2$subexpression$1", "symbols": ["kw_cascade"] },
              { "name": "drop_statement$ebnf$2$subexpression$1", "symbols": ["kw_restrict"] },
              { "name": "drop_statement$ebnf$2", "symbols": ["drop_statement$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "drop_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "drop_statement", "symbols": ["kw_drop", "drop_what", "drop_statement$ebnf$1", "drop_statement$macrocall$1", "drop_statement$ebnf$2"], "postprocess": (x, rej) => {
                const v = unwrap(x[1]);
                return (0, lexer_2.track)(x, {
                  ...v,
                  ...x[2] && { ifExists: true },
                  names: x[3],
                  ...x[4] && { cascade: toStr(x[4]) }
                });
              } },
              { "name": "drop_what", "symbols": [lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table], "postprocess": (x) => (0, lexer_2.track)(x, { type: "drop table" }) },
              { "name": "drop_what", "symbols": ["kw_sequence"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "drop sequence" }) },
              { "name": "drop_what", "symbols": ["kw_type"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "drop type" }) },
              { "name": "drop_what", "symbols": ["kw_trigger"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "drop trigger" }) },
              { "name": "drop_what$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_concurrently") ? { type: "kw_concurrently" } : kw_concurrently], "postprocess": id },
              { "name": "drop_what$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "drop_what", "symbols": ["kw_index", "drop_what$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "drop index",
                ...x[1] && { concurrently: true }
              }) },
              { "name": "with_statement", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "with_statement_bindings", "with_statement_statement"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "with",
                bind: x[1],
                in: unwrap(x[2])
              }) },
              { "name": "with_recursive_statement$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "kw_recursive"] },
              { "name": "with_recursive_statement", "symbols": ["with_recursive_statement$subexpression$1", "ident", "collist_paren", lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "lparen", "union_statement", "rparen", "with_statement_statement"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "with recursive",
                alias: asName(x[1]),
                columnNames: x[2].map(asName),
                bind: x[5],
                in: unwrap(x[7])
              }) },
              { "name": "with_statement_bindings$ebnf$1", "symbols": [] },
              { "name": "with_statement_bindings$ebnf$1$subexpression$1", "symbols": ["comma", "with_statement_binding"], "postprocess": last },
              { "name": "with_statement_bindings$ebnf$1", "symbols": ["with_statement_bindings$ebnf$1", "with_statement_bindings$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "with_statement_bindings", "symbols": ["with_statement_binding", "with_statement_bindings$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "with_statement_binding", "symbols": ["word", lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "lparen", "with_statement_statement", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                alias: asName(x[0]),
                statement: unwrap(x[3])
              }) },
              { "name": "with_statement_statement", "symbols": ["selection"] },
              { "name": "with_statement_statement", "symbols": ["insert_statement"] },
              { "name": "with_statement_statement", "symbols": ["update_statement"] },
              { "name": "with_statement_statement", "symbols": ["delete_statement"] },
              { "name": "createtype_statement$subexpression$1", "symbols": ["createtype_enum"] },
              { "name": "createtype_statement$subexpression$1", "symbols": ["createtype_composite"] },
              { "name": "createtype_statement", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "kw_type", "qualified_name", "createtype_statement$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                name: x[2],
                ...unwrap(x[3])
              }) },
              { "name": "createtype_enum$macrocall$2", "symbols": ["enum_value"] },
              { "name": "createtype_enum$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "createtype_enum$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "createtype_enum$macrocall$2"], "postprocess": last },
              { "name": "createtype_enum$macrocall$1$ebnf$1", "symbols": ["createtype_enum$macrocall$1$ebnf$1", "createtype_enum$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtype_enum$macrocall$1", "symbols": ["createtype_enum$macrocall$2", "createtype_enum$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "createtype_enum", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "kw_enum", "lparen", "createtype_enum$macrocall$1", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "create enum",
                values: x[3]
              }) },
              { "name": "enum_value", "symbols": ["string"], "postprocess": (x) => (0, lexer_2.track)(x, { value: toStr(x) }) },
              { "name": "createtype_composite$macrocall$2", "symbols": ["createtype_composite_attr"] },
              { "name": "createtype_composite$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "createtype_composite$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "createtype_composite$macrocall$2"], "postprocess": last },
              { "name": "createtype_composite$macrocall$1$ebnf$1", "symbols": ["createtype_composite$macrocall$1$ebnf$1", "createtype_composite$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtype_composite$macrocall$1", "symbols": ["createtype_composite$macrocall$2", "createtype_composite$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "createtype_composite", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "lparen", "createtype_composite$macrocall$1", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "create composite type",
                attributes: x[2]
              }) },
              { "name": "createtype_composite_attr$ebnf$1", "symbols": ["createtable_collate"], "postprocess": id },
              { "name": "createtype_composite_attr$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createtype_composite_attr", "symbols": ["word", "data_type", "createtype_composite_attr$ebnf$1"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  name: asName(x[0]),
                  dataType: x[1],
                  ...x[2] ? { collate: x[2][1] } : {}
                });
              } },
              { "name": "union_left", "symbols": ["select_statement"] },
              { "name": "union_left", "symbols": ["select_values"] },
              { "name": "union_left", "symbols": ["selection_paren"] },
              { "name": "union_right", "symbols": ["selection"] },
              { "name": "union_right", "symbols": ["selection_paren"] },
              { "name": "union_statement$subexpression$1$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_all") ? { type: "kw_all" } : kw_all], "postprocess": id },
              { "name": "union_statement$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "union_statement$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_union") ? { type: "kw_union" } : kw_union, "union_statement$subexpression$1$ebnf$1"] },
              { "name": "union_statement", "symbols": ["union_left", "union_statement$subexpression$1", "union_right"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  type: toStr(x[1], " "),
                  left: unwrap(x[0]),
                  right: unwrap(x[2])
                });
              } },
              { "name": "prepare$ebnf$1$subexpression$1", "symbols": ["lparen", "data_type_list", "rparen"], "postprocess": get2(1) },
              { "name": "prepare$ebnf$1", "symbols": ["prepare$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "prepare$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "prepare", "symbols": ["kw_prepare", "ident", "prepare$ebnf$1", lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "statement_noprep"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "prepare",
                name: asName(x[1]),
                ...x[2] && { args: x[2] },
                statement: unwrap(last(x))
              }) },
              { "name": "deallocate$ebnf$1", "symbols": ["kw_prepare"], "postprocess": id },
              { "name": "deallocate$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "deallocate", "symbols": ["kw_deallocate", "deallocate$ebnf$1", "deallocate_target"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "deallocate",
                target: x[2]
              }) },
              { "name": "deallocate_target", "symbols": ["deallocate_all"], "postprocess": unwrap },
              { "name": "deallocate_target", "symbols": ["deallocate_name"], "postprocess": unwrap },
              { "name": "deallocate_name", "symbols": ["ident"], "postprocess": (x) => (0, lexer_2.track)(x, asName(x[0])) },
              { "name": "deallocate_all", "symbols": [lexer_1.lexerAny.has("kw_all") ? { type: "kw_all" } : kw_all], "postprocess": (x) => (0, lexer_2.track)(x, { option: "all" }) },
              { "name": "create_view_statements", "symbols": ["create_view"] },
              { "name": "create_view_statements", "symbols": ["create_materialized_view"] },
              { "name": "create_view$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_or") ? { type: "kw_or" } : kw_or, "kw_replace"] },
              { "name": "create_view$ebnf$1", "symbols": ["create_view$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "create_view$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_view$ebnf$2$subexpression$1", "symbols": ["kw_temp"] },
              { "name": "create_view$ebnf$2$subexpression$1", "symbols": ["kw_temporary"] },
              { "name": "create_view$ebnf$2", "symbols": ["create_view$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "create_view$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "create_view$ebnf$3", "symbols": ["kw_recursive"], "postprocess": id },
              { "name": "create_view$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "create_view$ebnf$4$subexpression$1$macrocall$2", "symbols": ["ident"] },
              { "name": "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "create_view$ebnf$4$subexpression$1$macrocall$2"], "postprocess": last },
              { "name": "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1", "symbols": ["create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1", "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "create_view$ebnf$4$subexpression$1$macrocall$1", "symbols": ["create_view$ebnf$4$subexpression$1$macrocall$2", "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "create_view$ebnf$4$subexpression$1", "symbols": ["lparen", "create_view$ebnf$4$subexpression$1$macrocall$1", "rparen"], "postprocess": get2(1) },
              { "name": "create_view$ebnf$4", "symbols": ["create_view$ebnf$4$subexpression$1"], "postprocess": id },
              { "name": "create_view$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "create_view$ebnf$5", "symbols": ["create_view_opts"], "postprocess": id },
              { "name": "create_view$ebnf$5", "symbols": [], "postprocess": () => null },
              { "name": "create_view$ebnf$6$subexpression$1$subexpression$1", "symbols": ["kw_local"] },
              { "name": "create_view$ebnf$6$subexpression$1$subexpression$1", "symbols": ["kw_cascaded"] },
              { "name": "create_view$ebnf$6$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "create_view$ebnf$6$subexpression$1$subexpression$1", lexer_1.lexerAny.has("kw_check") ? { type: "kw_check" } : kw_check, "kw_option"], "postprocess": get2(1) },
              { "name": "create_view$ebnf$6", "symbols": ["create_view$ebnf$6$subexpression$1"], "postprocess": id },
              { "name": "create_view$ebnf$6", "symbols": [], "postprocess": () => null },
              { "name": "create_view", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "create_view$ebnf$1", "create_view$ebnf$2", "create_view$ebnf$3", "kw_view", "qualified_name", "create_view$ebnf$4", "create_view$ebnf$5", lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "selection", "create_view$ebnf$6"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  type: "create view",
                  ...x[1] && { orReplace: true },
                  ...x[2] && { temp: true },
                  ...x[3] && { recursive: true },
                  name: x[5],
                  ...x[6] && { columnNames: x[6].map(asName) },
                  ...x[7] && { parameters: fromEntries(x[7]) },
                  query: x[9],
                  ...x[10] && { checkOption: toStr(x[10]) }
                });
              } },
              { "name": "create_view_opt", "symbols": ["ident", lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq, "ident"], "postprocess": ([a, _, b]) => [toStr(a), toStr(b)] },
              { "name": "create_view_opts$macrocall$2", "symbols": ["create_view_opt"] },
              { "name": "create_view_opts$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "create_view_opts$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "create_view_opts$macrocall$2"], "postprocess": last },
              { "name": "create_view_opts$macrocall$1$ebnf$1", "symbols": ["create_view_opts$macrocall$1$ebnf$1", "create_view_opts$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "create_view_opts$macrocall$1", "symbols": ["create_view_opts$macrocall$2", "create_view_opts$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "create_view_opts", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "create_view_opts$macrocall$1"], "postprocess": last },
              { "name": "create_materialized_view$ebnf$1", "symbols": ["kw_ifnotexists"], "postprocess": id },
              { "name": "create_materialized_view$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$2", "symbols": ["ident"] },
              { "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "create_materialized_view$ebnf$2$subexpression$1$macrocall$2"], "postprocess": last },
              { "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1", "symbols": ["create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1", "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1", "symbols": ["create_materialized_view$ebnf$2$subexpression$1$macrocall$2", "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "create_materialized_view$ebnf$2$subexpression$1", "symbols": ["lparen", "create_materialized_view$ebnf$2$subexpression$1$macrocall$1", "rparen"], "postprocess": get2(1) },
              { "name": "create_materialized_view$ebnf$2", "symbols": ["create_materialized_view$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "create_materialized_view$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "create_materialized_view$ebnf$3", "symbols": ["create_view_opts"], "postprocess": id },
              { "name": "create_materialized_view$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "create_materialized_view$ebnf$4$subexpression$1", "symbols": ["kw_tablespace", "ident"], "postprocess": last },
              { "name": "create_materialized_view$ebnf$4", "symbols": ["create_materialized_view$ebnf$4$subexpression$1"], "postprocess": id },
              { "name": "create_materialized_view$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "create_materialized_view$ebnf$5$subexpression$1$ebnf$1", "symbols": ["kw_no"], "postprocess": id },
              { "name": "create_materialized_view$ebnf$5$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_materialized_view$ebnf$5$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "create_materialized_view$ebnf$5$subexpression$1$ebnf$1", "kw_data"] },
              { "name": "create_materialized_view$ebnf$5", "symbols": ["create_materialized_view$ebnf$5$subexpression$1"], "postprocess": id },
              { "name": "create_materialized_view$ebnf$5", "symbols": [], "postprocess": () => null },
              { "name": "create_materialized_view", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "kw_materialized", "kw_view", "create_materialized_view$ebnf$1", "qualified_name", "create_materialized_view$ebnf$2", "create_materialized_view$ebnf$3", "create_materialized_view$ebnf$4", lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "selection", "create_materialized_view$ebnf$5"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  type: "create materialized view",
                  ...x[3] && { ifNotExists: true },
                  name: x[4],
                  ...x[5] && { columnNames: x[6].map(asName) },
                  ...x[6] && { parameters: fromEntries(x[6]) },
                  ...x[7] && { tablespace: asName(x[7]) },
                  query: x[9],
                  ...x[10] && { withData: toStr(x[10][1]) !== "no" }
                });
              } },
              { "name": "refresh_view_statements$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_concurrently") ? { type: "kw_concurrently" } : kw_concurrently], "postprocess": id },
              { "name": "refresh_view_statements$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "refresh_view_statements$ebnf$2$subexpression$1$ebnf$1", "symbols": ["kw_no"], "postprocess": id },
              { "name": "refresh_view_statements$ebnf$2$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "refresh_view_statements$ebnf$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "refresh_view_statements$ebnf$2$subexpression$1$ebnf$1", "kw_data"] },
              { "name": "refresh_view_statements$ebnf$2", "symbols": ["refresh_view_statements$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "refresh_view_statements$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "refresh_view_statements", "symbols": ["kw_refresh", "kw_materialized", "kw_view", "refresh_view_statements$ebnf$1", "qname", "refresh_view_statements$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "refresh materialized view",
                ...!!x[3] ? { concurrently: true } : {},
                name: x[4],
                ...!!x[5] ? { withData: toStr(x[5][1]) !== "no" } : {}
              }) },
              { "name": "functions_statements", "symbols": ["create_func"] },
              { "name": "functions_statements", "symbols": ["do_stm"] },
              { "name": "functions_statements", "symbols": ["drop_func"] },
              { "name": "create_func$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_or") ? { type: "kw_or" } : kw_or, "kw_replace"] },
              { "name": "create_func$ebnf$1", "symbols": ["create_func$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "create_func$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_func$subexpression$1$ebnf$1$macrocall$2", "symbols": ["func_argdef"] },
              { "name": "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "create_func$subexpression$1$ebnf$1$macrocall$2"], "postprocess": last },
              { "name": "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1", "symbols": ["create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1", "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "create_func$subexpression$1$ebnf$1$macrocall$1", "symbols": ["create_func$subexpression$1$ebnf$1$macrocall$2", "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "create_func$subexpression$1$ebnf$1", "symbols": ["create_func$subexpression$1$ebnf$1$macrocall$1"], "postprocess": id },
              { "name": "create_func$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_func$subexpression$1", "symbols": ["lparen", "create_func$subexpression$1$ebnf$1", "rparen"], "postprocess": get2(1) },
              { "name": "create_func$ebnf$2", "symbols": ["func_spec"] },
              { "name": "create_func$ebnf$2", "symbols": ["create_func$ebnf$2", "func_spec"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "create_func", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "create_func$ebnf$1", "kw_function", "qname", "create_func$subexpression$1", "create_func$ebnf$2"], "postprocess": (x, rej) => {
                var _a;
                const specs = {};
                for (const s of x[5]) {
                  for (const k in s) {
                    if (k[0] !== "_" && k in specs) {
                      throw new Error("conflicting or redundant options " + k);
                    }
                  }
                  Object.assign(specs, s);
                }
                return (0, lexer_2.track)(x, {
                  type: "create function",
                  ...x[1] && { orReplace: true },
                  name: x[3],
                  arguments: (_a = x[4]) !== null && _a !== void 0 ? _a : [],
                  ...specs
                });
              } },
              { "name": "func_argdef$ebnf$1", "symbols": ["func_argopts"], "postprocess": id },
              { "name": "func_argdef$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "func_argdef$ebnf$2", "symbols": ["func_argdefault"], "postprocess": id },
              { "name": "func_argdef$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "func_argdef", "symbols": ["func_argdef$ebnf$1", "data_type", "func_argdef$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                default: x[2],
                type: x[1],
                ...x[0]
              }) },
              {
                "name": "func_argdefault",
                "symbols": [lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default, "expr"],
                "postprocess": (x) => x[1]
              },
              { "name": "func_argdefault", "symbols": [lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq, "expr"], "postprocess": (x) => x[1] },
              { "name": "func_argopts$ebnf$1", "symbols": ["word"], "postprocess": id },
              { "name": "func_argopts$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "func_argopts", "symbols": ["func_argmod", "func_argopts$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                mode: toStr(x[0]),
                ...x[1] && { name: asName(x[1]) }
              }) },
              { "name": "func_argopts", "symbols": ["word"], "postprocess": (x, rej) => {
                const name2 = asName(x);
                if (name2 === "out" || name2 === "inout" || name2 === "variadic") {
                  return rej;
                }
                return (0, lexer_2.track)(x, { name: name2 });
              } },
              { "name": "func_argmod", "symbols": [lexer_1.lexerAny.has("kw_in") ? { type: "kw_in" } : kw_in] },
              { "name": "func_argmod", "symbols": ["kw_out"] },
              { "name": "func_argmod", "symbols": ["kw_inout"] },
              { "name": "func_argmod", "symbols": ["kw_variadic"] },
              { "name": "func_spec", "symbols": ["kw_language", "word"], "postprocess": (x) => (0, lexer_2.track)(x, { language: asName(last(x)) }) },
              { "name": "func_spec", "symbols": ["func_purity"], "postprocess": (x) => (0, lexer_2.track)(x, { purity: toStr(x) }) },
              { "name": "func_spec$subexpression$1", "symbols": [lexer_1.lexerAny.has("codeblock") ? { type: "codeblock" } : codeblock] },
              { "name": "func_spec$subexpression$1", "symbols": ["string"] },
              { "name": "func_spec", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "func_spec$subexpression$1"], "postprocess": (x) => ({ code: toStr(last(x)) }) },
              { "name": "func_spec$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not], "postprocess": id },
              { "name": "func_spec$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "func_spec$subexpression$2", "symbols": ["word"], "postprocess": kw("leakproof") },
              { "name": "func_spec", "symbols": ["func_spec$ebnf$1", "func_spec$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, { leakproof: !x[0] }) },
              { "name": "func_spec", "symbols": ["func_returns"], "postprocess": (x) => (0, lexer_2.track)(x, { returns: unwrap(x) }) },
              { "name": "func_spec$subexpression$3", "symbols": ["word"], "postprocess": kw("called") },
              { "name": "func_spec", "symbols": ["func_spec$subexpression$3", "oninp"], "postprocess": () => ({ onNullInput: "call" }) },
              { "name": "func_spec$subexpression$4", "symbols": ["word"], "postprocess": kw("returns") },
              { "name": "func_spec", "symbols": ["func_spec$subexpression$4", lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null, "oninp"], "postprocess": () => ({ onNullInput: "null" }) },
              { "name": "func_spec$subexpression$5", "symbols": ["word"], "postprocess": kw("strict") },
              { "name": "func_spec", "symbols": ["func_spec$subexpression$5"], "postprocess": () => ({ onNullInput: "strict" }) },
              { "name": "func_purity", "symbols": ["word"], "postprocess": kw("immutable") },
              { "name": "func_purity", "symbols": ["word"], "postprocess": kw("stable") },
              { "name": "func_purity", "symbols": ["word"], "postprocess": kw("volatile") },
              { "name": "oninp$subexpression$1", "symbols": ["word"], "postprocess": kw("input") },
              { "name": "oninp", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null, "oninp$subexpression$1"] },
              { "name": "func_returns", "symbols": ["kw_returns", "data_type"], "postprocess": last },
              { "name": "func_returns$macrocall$2", "symbols": ["func_ret_table_col"] },
              { "name": "func_returns$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "func_returns$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "func_returns$macrocall$2"], "postprocess": last },
              { "name": "func_returns$macrocall$1$ebnf$1", "symbols": ["func_returns$macrocall$1$ebnf$1", "func_returns$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "func_returns$macrocall$1", "symbols": ["func_returns$macrocall$2", "func_returns$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "func_returns", "symbols": ["kw_returns", lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table, "lparen", "func_returns$macrocall$1", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                kind: "table",
                columns: x[3]
              }) },
              { "name": "func_ret_table_col", "symbols": ["word", "data_type"], "postprocess": (x) => (0, lexer_2.track)(x, { name: asName(x[0]), type: x[1] }) },
              { "name": "do_stm$ebnf$1$subexpression$1", "symbols": ["kw_language", "word"], "postprocess": last },
              { "name": "do_stm$ebnf$1", "symbols": ["do_stm$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "do_stm$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "do_stm", "symbols": [lexer_1.lexerAny.has("kw_do") ? { type: "kw_do" } : kw_do, "do_stm$ebnf$1", lexer_1.lexerAny.has("codeblock") ? { type: "codeblock" } : codeblock], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "do",
                ...x[1] && { language: asName(x[1]) },
                code: x[2].value
              }) },
              { "name": "drop_func$ebnf$1$subexpression$1", "symbols": ["kw_if", "kw_exists"] },
              { "name": "drop_func$ebnf$1", "symbols": ["drop_func$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "drop_func$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "drop_func$ebnf$2", "symbols": ["drop_func_overload"], "postprocess": id },
              { "name": "drop_func$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "drop_func", "symbols": ["kw_drop", "kw_function", "drop_func$ebnf$1", "qname", "drop_func$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "drop function",
                ...x[2] && { ifExists: true },
                name: x[3],
                ...x[4] && { arguments: x[4] }
              }) },
              { "name": "drop_func_overload$macrocall$2", "symbols": ["drop_func_overload_col"] },
              { "name": "drop_func_overload$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "drop_func_overload$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "drop_func_overload$macrocall$2"], "postprocess": last },
              { "name": "drop_func_overload$macrocall$1$ebnf$1", "symbols": ["drop_func_overload$macrocall$1$ebnf$1", "drop_func_overload$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "drop_func_overload$macrocall$1", "symbols": ["drop_func_overload$macrocall$2", "drop_func_overload$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "drop_func_overload", "symbols": ["lparen", "drop_func_overload$macrocall$1", "rparen"], "postprocess": get2(1) },
              { "name": "drop_func_overload_col$ebnf$1", "symbols": ["word"], "postprocess": id },
              { "name": "drop_func_overload_col$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "drop_func_overload_col", "symbols": ["drop_func_overload_col$ebnf$1", "qname"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: x[1],
                ...x[0] && { name: asName(x[0]) }
              }) },
              { "name": "main$ebnf$1", "symbols": [] },
              { "name": "main$ebnf$1", "symbols": ["main$ebnf$1", "statement_separator"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "main$ebnf$2", "symbols": [] },
              { "name": "main$ebnf$2$subexpression$1$ebnf$1", "symbols": ["statement_separator"] },
              { "name": "main$ebnf$2$subexpression$1$ebnf$1", "symbols": ["main$ebnf$2$subexpression$1$ebnf$1", "statement_separator"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "main$ebnf$2$subexpression$1", "symbols": ["main$ebnf$2$subexpression$1$ebnf$1", "statement"] },
              { "name": "main$ebnf$2", "symbols": ["main$ebnf$2", "main$ebnf$2$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "main$ebnf$3", "symbols": [] },
              { "name": "main$ebnf$3", "symbols": ["main$ebnf$3", "statement_separator"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "main", "symbols": ["main$ebnf$1", "statement", "main$ebnf$2", "main$ebnf$3"], "postprocess": ([_, head, _tail]) => {
                const tail = _tail;
                const ret = [unwrap(head), ...tail.map((x) => unwrap(x[1]))];
                return ret.length === 1 ? ret[0] : ret;
              } },
              { "name": "statement_separator", "symbols": [lexer_1.lexerAny.has("semicolon") ? { type: "semicolon" } : semicolon] },
              { "name": "statement", "symbols": ["statement_noprep"] },
              { "name": "statement", "symbols": ["prepare"] },
              { "name": "statement", "symbols": ["deallocate"] },
              { "name": "statement_noprep", "symbols": ["selection"] },
              { "name": "statement_noprep", "symbols": ["createtable_statement"] },
              { "name": "statement_noprep", "symbols": ["createextension_statement"] },
              { "name": "statement_noprep", "symbols": ["createindex_statement"] },
              { "name": "statement_noprep", "symbols": ["simplestatements_all"] },
              { "name": "statement_noprep", "symbols": ["insert_statement"] },
              { "name": "statement_noprep", "symbols": ["update_statement"] },
              { "name": "statement_noprep", "symbols": ["altertable_statement"] },
              { "name": "statement_noprep", "symbols": ["alterindex_statement"] },
              { "name": "statement_noprep", "symbols": ["delete_statement"] },
              { "name": "statement_noprep", "symbols": ["create_sequence_statement"] },
              { "name": "statement_noprep", "symbols": ["alter_sequence_statement"] },
              { "name": "statement_noprep", "symbols": ["drop_statement"] },
              { "name": "statement_noprep", "symbols": ["createtype_statement"] },
              { "name": "statement_noprep", "symbols": ["create_view_statements"] },
              { "name": "statement_noprep", "symbols": ["refresh_view_statements"] },
              { "name": "statement_noprep", "symbols": ["create_schema"] },
              { "name": "statement_noprep", "symbols": ["raise_statement"] },
              { "name": "statement_noprep", "symbols": ["comment_statement"] },
              { "name": "statement_noprep", "symbols": ["functions_statements"] },
              { "name": "selection", "symbols": ["select_statement"], "postprocess": unwrap },
              { "name": "selection", "symbols": ["select_values"], "postprocess": unwrap },
              { "name": "selection", "symbols": ["with_statement"], "postprocess": unwrap },
              { "name": "selection", "symbols": ["with_recursive_statement"], "postprocess": unwrap },
              { "name": "selection", "symbols": ["union_statement"], "postprocess": unwrap },
              { "name": "selection_paren", "symbols": ["lparen", "selection", "rparen"], "postprocess": get2(1) }
            ],
            ParserStart: "main"
          };
          exports2.default = grammar;
        },
        /* 11 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function id(d) {
            return d[0];
          }
          const array_lexer_1 = __webpack_require__(12);
          const get2 = (i) => (x) => x[i];
          const last = (x) => x && x[x.length - 1];
          ;
          ;
          ;
          ;
          const grammar = {
            Lexer: array_lexer_1.lexerAny,
            ParserRules: [
              { "name": "main$ebnf$1", "symbols": ["elements"], "postprocess": id },
              { "name": "main$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "main", "symbols": [array_lexer_1.lexerAny.has("start_list") ? { type: "start_list" } : start_list, "main$ebnf$1", array_lexer_1.lexerAny.has("end_list") ? { type: "end_list" } : end_list], "postprocess": (x) => x[1] || [] },
              { "name": "elements$ebnf$1", "symbols": [] },
              { "name": "elements$ebnf$1$subexpression$1", "symbols": [array_lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "elt"], "postprocess": last },
              { "name": "elements$ebnf$1", "symbols": ["elements$ebnf$1", "elements$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "elements", "symbols": ["elt", "elements$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "elt", "symbols": [array_lexer_1.lexerAny.has("value") ? { type: "value" } : value], "postprocess": (x) => x[0].value },
              { "name": "elt", "symbols": ["main"], "postprocess": (x) => x[0] }
            ],
            ParserStart: "main"
          };
          exports2.default = grammar;
        },
        /* 12 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.lexerAny = exports2.lexer = void 0;
          const moo_1 = __webpack_require__(0);
          exports2.lexer = (0, moo_1.compile)({
            valueString: {
              match: /"(?:\\["\\]|[^\n"\\])*"/,
              value: (x) => JSON.parse(x),
              type: (x) => "value"
            },
            valueRaw: {
              match: /[^\s,\{\}"](?:[^,\{\}"]*[^\s,\{\}"])?/,
              type: () => "value"
            },
            comma: ",",
            space: { match: /[\s\t\n\v\f\r]+/, lineBreaks: true },
            start_list: "{",
            end_list: "}"
          });
          exports2.lexer.next = /* @__PURE__ */ ((next) => () => {
            let tok;
            while ((tok = next.call(exports2.lexer)) && tok.type === "space") {
            }
            return tok;
          })(exports2.lexer.next);
          exports2.lexerAny = exports2.lexer;
        },
        /* 13 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function id(d) {
            return d[0];
          }
          const geometric_lexer_1 = __webpack_require__(14);
          const get2 = (i) => (x) => x[i];
          const last = (x) => x && x[x.length - 1];
          function unwrap(e) {
            if (Array.isArray(e) && e.length === 1) {
              e = unwrap(e[0]);
            }
            if (Array.isArray(e) && !e.length) {
              return null;
            }
            return e;
          }
          ;
          ;
          ;
          ;
          const grammar = {
            Lexer: geometric_lexer_1.lexerAny,
            ParserRules: [
              { "name": "number$subexpression$1", "symbols": ["float"] },
              { "name": "number$subexpression$1", "symbols": ["int"] },
              { "name": "number", "symbols": ["number$subexpression$1"], "postprocess": unwrap },
              { "name": "float", "symbols": [geometric_lexer_1.lexerAny.has("float") ? { type: "float" } : float], "postprocess": (args) => parseFloat(unwrap(args)) },
              { "name": "int", "symbols": [geometric_lexer_1.lexerAny.has("int") ? { type: "int" } : int], "postprocess": (arg) => parseInt(unwrap(arg), 10) },
              { "name": "comma", "symbols": [geometric_lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma], "postprocess": id },
              { "name": "point$macrocall$2", "symbols": ["point_content"] },
              { "name": "point$macrocall$1$subexpression$1", "symbols": ["point$macrocall$2"] },
              { "name": "point$macrocall$1$subexpression$1", "symbols": [geometric_lexer_1.lexerAny.has("lparen") ? { type: "lparen" } : lparen, "point$macrocall$2", geometric_lexer_1.lexerAny.has("rparen") ? { type: "rparen" } : rparen], "postprocess": get2(1) },
              { "name": "point$macrocall$1", "symbols": ["point$macrocall$1$subexpression$1"], "postprocess": unwrap },
              { "name": "point", "symbols": ["point$macrocall$1"], "postprocess": unwrap },
              { "name": "point_content", "symbols": ["number", "comma", "number"], "postprocess": (x) => ({ x: x[0], y: x[2] }) },
              { "name": "line", "symbols": [geometric_lexer_1.lexerAny.has("lcurl") ? { type: "lcurl" } : lcurl, "number", "comma", "number", "comma", "number", geometric_lexer_1.lexerAny.has("rcurl") ? { type: "rcurl" } : rcurl], "postprocess": (x) => ({
                a: x[1],
                b: x[3],
                c: x[5]
              }) },
              { "name": "box", "symbols": ["closed_path"], "postprocess": ([x], rej) => {
                if (x.length !== 2) {
                  return rej;
                }
                return x;
              } },
              { "name": "lseg", "symbols": ["path"], "postprocess": ([x], rej) => {
                if (x.path.length !== 2) {
                  return rej;
                }
                return x.path;
              } },
              { "name": "path", "symbols": ["open_path"], "postprocess": ([path]) => ({ closed: false, path }) },
              { "name": "path", "symbols": ["closed_path"], "postprocess": ([path]) => ({ closed: true, path }) },
              { "name": "open_path$macrocall$2", "symbols": [geometric_lexer_1.lexerAny.has("lbracket") ? { type: "lbracket" } : lbracket] },
              { "name": "open_path$macrocall$3", "symbols": [geometric_lexer_1.lexerAny.has("rbracket") ? { type: "rbracket" } : rbracket] },
              { "name": "open_path$macrocall$1$macrocall$2", "symbols": ["point"] },
              { "name": "open_path$macrocall$1$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "open_path$macrocall$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [geometric_lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "open_path$macrocall$1$macrocall$2"], "postprocess": last },
              { "name": "open_path$macrocall$1$macrocall$1$ebnf$1", "symbols": ["open_path$macrocall$1$macrocall$1$ebnf$1", "open_path$macrocall$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "open_path$macrocall$1$macrocall$1", "symbols": ["open_path$macrocall$1$macrocall$2", "open_path$macrocall$1$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "open_path$macrocall$1", "symbols": ["open_path$macrocall$2", "open_path$macrocall$1$macrocall$1", "open_path$macrocall$3"], "postprocess": get2(1) },
              { "name": "open_path", "symbols": ["open_path$macrocall$1"], "postprocess": last },
              { "name": "closed_path$subexpression$1$macrocall$2", "symbols": [geometric_lexer_1.lexerAny.has("lparen") ? { type: "lparen" } : lparen] },
              { "name": "closed_path$subexpression$1$macrocall$3", "symbols": [geometric_lexer_1.lexerAny.has("rparen") ? { type: "rparen" } : rparen] },
              { "name": "closed_path$subexpression$1$macrocall$1$macrocall$2", "symbols": ["point"] },
              { "name": "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [geometric_lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "closed_path$subexpression$1$macrocall$1$macrocall$2"], "postprocess": last },
              { "name": "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1", "symbols": ["closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1", "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "closed_path$subexpression$1$macrocall$1$macrocall$1", "symbols": ["closed_path$subexpression$1$macrocall$1$macrocall$2", "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "closed_path$subexpression$1$macrocall$1", "symbols": ["closed_path$subexpression$1$macrocall$2", "closed_path$subexpression$1$macrocall$1$macrocall$1", "closed_path$subexpression$1$macrocall$3"], "postprocess": get2(1) },
              { "name": "closed_path$subexpression$1", "symbols": ["closed_path$subexpression$1$macrocall$1"], "postprocess": last },
              { "name": "closed_path$subexpression$1$macrocall$5", "symbols": ["point"] },
              { "name": "closed_path$subexpression$1$macrocall$4$ebnf$1", "symbols": [] },
              { "name": "closed_path$subexpression$1$macrocall$4$ebnf$1$subexpression$1", "symbols": [geometric_lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "closed_path$subexpression$1$macrocall$5"], "postprocess": last },
              { "name": "closed_path$subexpression$1$macrocall$4$ebnf$1", "symbols": ["closed_path$subexpression$1$macrocall$4$ebnf$1", "closed_path$subexpression$1$macrocall$4$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "closed_path$subexpression$1$macrocall$4", "symbols": ["closed_path$subexpression$1$macrocall$5", "closed_path$subexpression$1$macrocall$4$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "closed_path$subexpression$1", "symbols": ["closed_path$subexpression$1$macrocall$4"], "postprocess": last },
              { "name": "closed_path", "symbols": ["closed_path$subexpression$1"], "postprocess": get2(0) },
              { "name": "polygon", "symbols": ["closed_path"], "postprocess": get2(0) },
              { "name": "circle_body", "symbols": ["point", "comma", "number"], "postprocess": (x) => ({ c: x[0], r: x[2] }) },
              { "name": "circle$subexpression$1$macrocall$2", "symbols": [geometric_lexer_1.lexerAny.has("lcomp") ? { type: "lcomp" } : lcomp] },
              { "name": "circle$subexpression$1$macrocall$3", "symbols": [geometric_lexer_1.lexerAny.has("rcomp") ? { type: "rcomp" } : rcomp] },
              { "name": "circle$subexpression$1$macrocall$1", "symbols": ["circle$subexpression$1$macrocall$2", "circle_body", "circle$subexpression$1$macrocall$3"], "postprocess": get2(1) },
              { "name": "circle$subexpression$1", "symbols": ["circle$subexpression$1$macrocall$1"] },
              { "name": "circle$subexpression$1$macrocall$5", "symbols": [geometric_lexer_1.lexerAny.has("lparen") ? { type: "lparen" } : lparen] },
              { "name": "circle$subexpression$1$macrocall$6", "symbols": [geometric_lexer_1.lexerAny.has("rparen") ? { type: "rparen" } : rparen] },
              { "name": "circle$subexpression$1$macrocall$4", "symbols": ["circle$subexpression$1$macrocall$5", "circle_body", "circle$subexpression$1$macrocall$6"], "postprocess": get2(1) },
              { "name": "circle$subexpression$1", "symbols": ["circle$subexpression$1$macrocall$4"] },
              { "name": "circle$subexpression$1", "symbols": ["circle_body"] },
              { "name": "circle", "symbols": ["circle$subexpression$1"], "postprocess": unwrap }
            ],
            ParserStart: "number"
          };
          exports2.default = grammar;
        },
        /* 14 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.lexerAny = exports2.lexer = void 0;
          const moo_1 = __webpack_require__(0);
          exports2.lexer = (0, moo_1.compile)({
            comma: ",",
            space: { match: /[\s\t\n\v\f\r]+/, lineBreaks: true },
            int: /\-?\d+(?![\.\d])/,
            float: /\-?(?:(?:\d*\.\d+)|(?:\d+\.\d*))/,
            lcurl: "{",
            rcurl: "}",
            lparen: "(",
            rparen: ")",
            lbracket: "[",
            rbracket: "]",
            lcomp: "<",
            rcomp: ">"
          });
          exports2.lexer.next = /* @__PURE__ */ ((next) => () => {
            let tok;
            while ((tok = next.call(exports2.lexer)) && tok.type === "space") {
            }
            return tok;
          })(exports2.lexer.next);
          exports2.lexerAny = exports2.lexer;
        },
        /* 15 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function id(d) {
            return d[0];
          }
          const interval_lexer_1 = __webpack_require__(16);
          ;
          ;
          ;
          ;
          const grammar = {
            Lexer: interval_lexer_1.lexerAny,
            ParserRules: [
              { "name": "main$ebnf$1", "symbols": ["elt"] },
              { "name": "main$ebnf$1", "symbols": ["main$ebnf$1", "elt"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "main", "symbols": ["main$ebnf$1"], "postprocess": ([elts]) => {
                const s = /* @__PURE__ */ new Set();
                for (const e of elts) {
                  const k = typeof e[1] === "number" ? e[0] : "time";
                  if (s.has(k)) {
                    return "invalid";
                  }
                  s.add(k);
                }
                return elts;
              } },
              { "name": "elt", "symbols": ["time"] },
              { "name": "elt", "symbols": ["num", "unit"], "postprocess": ([[n], u]) => {
                u = u[0].type;
                return [u, n];
              } },
              { "name": "unit", "symbols": [interval_lexer_1.lexerAny.has("years") ? { type: "years" } : years] },
              { "name": "unit", "symbols": [interval_lexer_1.lexerAny.has("months") ? { type: "months" } : months] },
              { "name": "unit", "symbols": [interval_lexer_1.lexerAny.has("days") ? { type: "days" } : days] },
              { "name": "unit", "symbols": [interval_lexer_1.lexerAny.has("hours") ? { type: "hours" } : hours] },
              { "name": "unit", "symbols": [interval_lexer_1.lexerAny.has("minutes") ? { type: "minutes" } : minutes] },
              { "name": "unit", "symbols": [interval_lexer_1.lexerAny.has("seconds") ? { type: "seconds" } : seconds] },
              { "name": "unit", "symbols": [interval_lexer_1.lexerAny.has("milliseconds") ? { type: "milliseconds" } : milliseconds] },
              { "name": "num", "symbols": ["int"] },
              { "name": "num", "symbols": ["float"] },
              { "name": "uint", "symbols": [interval_lexer_1.lexerAny.has("int") ? { type: "int" } : int], "postprocess": ([x]) => parseInt(x, 10) },
              { "name": "int$ebnf$1$subexpression$1", "symbols": [interval_lexer_1.lexerAny.has("neg") ? { type: "neg" } : neg] },
              { "name": "int$ebnf$1", "symbols": ["int$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "int$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "int", "symbols": ["int$ebnf$1", interval_lexer_1.lexerAny.has("int") ? { type: "int" } : int], "postprocess": ([neg2, x]) => parseInt(x, 10) * (neg2 ? -1 : 1) },
              { "name": "float$ebnf$1$subexpression$1", "symbols": [interval_lexer_1.lexerAny.has("neg") ? { type: "neg" } : neg] },
              { "name": "float$ebnf$1", "symbols": ["float$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "float$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "float$ebnf$2", "symbols": [interval_lexer_1.lexerAny.has("int") ? { type: "int" } : int], "postprocess": id },
              { "name": "float$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "float", "symbols": ["float$ebnf$1", "float$ebnf$2", interval_lexer_1.lexerAny.has("dot") ? { type: "dot" } : dot, interval_lexer_1.lexerAny.has("int") ? { type: "int" } : int], "postprocess": ([neg2, ...v]) => parseFloat(v.map((v2) => v2 ? v2.text : "0").join("")) * (neg2 ? -1 : 1) },
              { "name": "time$ebnf$1$subexpression$1", "symbols": [interval_lexer_1.lexerAny.has("colon") ? { type: "colon" } : colon, "uint"] },
              { "name": "time$ebnf$1", "symbols": ["time$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "time$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "time$ebnf$2$subexpression$1", "symbols": [interval_lexer_1.lexerAny.has("dot") ? { type: "dot" } : dot, interval_lexer_1.lexerAny.has("int") ? { type: "int" } : int] },
              { "name": "time$ebnf$2", "symbols": ["time$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "time$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "time", "symbols": ["uint", interval_lexer_1.lexerAny.has("colon") ? { type: "colon" } : colon, "uint", "time$ebnf$1", "time$ebnf$2"], "postprocess": ([a, _, b, c, d]) => {
                c = c && c[1];
                d = d && d[1];
                const ret = typeof c === "number" ? [
                  ["hours", a],
                  ["minutes", b],
                  ["seconds", c]
                ] : [
                  ["minutes", a],
                  ["seconds", b]
                ];
                if (d) {
                  ret.push(["milliseconds", parseFloat("0." + d) * 1e3]);
                }
                return ret;
              } }
            ],
            ParserStart: "main"
          };
          exports2.default = grammar;
        },
        /* 16 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.lexerAny = exports2.lexer = void 0;
          const moo_1 = __webpack_require__(0);
          exports2.lexer = (0, moo_1.compile)({
            int: /\d+/,
            neg: "-",
            dot: ".",
            years: /(?:y|yrs?|years?)\b/,
            months: /(?:mon(?:th)?s?)\b/,
            days: /(?:d|days?)\b/,
            hours: /(?:h|hrs?|hours?)\b/,
            minutes: /(?:m|mins?|minutes?)\b/,
            seconds: /(?:s|secs?|seconds?)\b/,
            milliseconds: /(?:ms|milliseconds?)\b/,
            space: { match: /[\s\t\n\v\f\r]+/, lineBreaks: true },
            colon: ":"
          });
          exports2.lexer.next = /* @__PURE__ */ ((next) => () => {
            let tok;
            while ((tok = next.call(exports2.lexer)) && tok.type === "space") {
            }
            return tok;
          })(exports2.lexer.next);
          exports2.lexerAny = exports2.lexer;
        },
        /* 17 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function id(d) {
            return d[0];
          }
          const interval_iso_lexer_1 = __webpack_require__(18);
          ;
          ;
          ;
          ;
          const grammar = {
            Lexer: interval_iso_lexer_1.lexerAny,
            ParserRules: [
              { "name": "num", "symbols": [interval_iso_lexer_1.lexerAny.has("int") ? { type: "int" } : int] },
              { "name": "num", "symbols": [interval_iso_lexer_1.lexerAny.has("float") ? { type: "float" } : float] },
              { "name": "main$ebnf$1", "symbols": [] },
              { "name": "main$ebnf$1", "symbols": ["main$ebnf$1", "long"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "main$ebnf$2$subexpression$1$ebnf$1", "symbols": ["short"] },
              { "name": "main$ebnf$2$subexpression$1$ebnf$1", "symbols": ["main$ebnf$2$subexpression$1$ebnf$1", "short"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "main$ebnf$2$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("T") ? { type: "T" } : T, "main$ebnf$2$subexpression$1$ebnf$1"] },
              { "name": "main$ebnf$2", "symbols": ["main$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "main$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "main", "symbols": [interval_iso_lexer_1.lexerAny.has("P") ? { type: "P" } : P, "main$ebnf$1", "main$ebnf$2"], "postprocess": ([_, a, b], rej) => {
                b = !b ? [] : b[1];
                {
                }
                if (!a.length && !b.length) {
                  return rej;
                }
                return !a.length ? b : !b.length ? a : [...a, ...b];
              } },
              { "name": "long$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("Y") ? { type: "Y" } : Y] },
              { "name": "long$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("M") ? { type: "M" } : M] },
              { "name": "long$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("W") ? { type: "W" } : W] },
              { "name": "long$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("D") ? { type: "D" } : D] },
              { "name": "long", "symbols": ["num", "long$subexpression$1"], "postprocess": ([n, u]) => {
                n = parseFloat(n[0].value);
                u = u[0].type;
                switch (u) {
                  case "Y":
                    return ["years", n];
                  case "M":
                    return ["months", n];
                  case "W":
                    return ["days", n * 7];
                  case "D":
                    return ["days", n];
                  default:
                    throw new Error("Unexpected unit " + u);
                }
              } },
              { "name": "short$ebnf$1", "symbols": [interval_iso_lexer_1.lexerAny.has("T") ? { type: "T" } : T], "postprocess": id },
              { "name": "short$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "short$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("H") ? { type: "H" } : H] },
              { "name": "short$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("M") ? { type: "M" } : M] },
              { "name": "short$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("S") ? { type: "S" } : S] },
              { "name": "short", "symbols": ["short$ebnf$1", "num", "short$subexpression$1"], "postprocess": ([_, n, u]) => {
                n = parseFloat(n[0].value);
                u = u[0].type;
                switch (u) {
                  case "H":
                    return ["hours", n];
                  case "M":
                    return ["minutes", n];
                  case "S":
                    return ["seconds", n];
                  default:
                    throw new Error("Unexpected unit " + u);
                }
              } }
            ],
            ParserStart: "num"
          };
          exports2.default = grammar;
        },
        /* 18 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.lexerAny = exports2.lexer = void 0;
          const moo_1 = __webpack_require__(0);
          exports2.lexer = (0, moo_1.compile)({
            int: /\-?\d+(?![\.\d])/,
            float: /\-?(?:(?:\d*\.\d+)|(?:\d+\.\d*))/,
            P: "P",
            Y: "Y",
            M: "M",
            W: "W",
            D: "D",
            H: "H",
            S: "S",
            T: "T"
          });
          exports2.lexerAny = exports2.lexer;
        },
        /* 19 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.toSql = void 0;
          const ast_mapper_1 = __webpack_require__(2);
          const ast_visitor_1 = __webpack_require__(5);
          const utils_1 = __webpack_require__(6);
          const pg_escape_1 = __webpack_require__(20);
          const keywords_1 = __webpack_require__(3);
          const kwSet = new Set(keywords_1.sqlKeywords.map((x) => x.toLowerCase()));
          let ret = [];
          function name2(nm) {
            return ident(nm.name);
          }
          function ident(nm, forceDoubleQuote) {
            if (!forceDoubleQuote) {
              const low = nm.toLowerCase();
              if (low === nm && !kwSet.has(low) && /^[a-z][a-z0-9_]*$/.test(low)) {
                return nm;
              }
            }
            return '"' + nm + '"';
          }
          function list(elems, act, addParen) {
            if (addParen) {
              ret.push("(");
            }
            let first = true;
            for (const e of elems) {
              if (!first) {
                ret.push(", ");
              }
              first = false;
              act(e);
            }
            if (addParen) {
              ret.push(")");
            }
          }
          function addConstraint(c, m) {
            switch (c.type) {
              case "foreign key":
                ret.push(" foreign key (", ...c.localColumns.map(name2).join(", "), ")");
              case "reference":
                ret.push(" REFERENCES ");
                m.tableRef(c.foreignTable);
                ret.push("(", ...c.foreignColumns.map(name2).join(", "), ") ");
                if (c.match) {
                  ret.push(" MATCH ", c.match.toUpperCase());
                }
                if (c.onDelete) {
                  ret.push(" ON DELETE ", c.onDelete);
                }
                if (c.onUpdate) {
                  ret.push(" ON UPDATE ", c.onUpdate);
                }
                break;
              case "primary key":
              case "unique":
                ret.push(" ", c.type, " ");
                if ("columns" in c) {
                  ret.push("(", ...c.columns.map(name2).join(", "), ") ");
                }
                break;
              case "check":
                ret.push(" check ");
                m.expr(c.expr);
                break;
              case "not null":
              case "null":
                ret.push(" ", c.type, " ");
                break;
              case "default":
                ret.push(" default ");
                m.expr(c.default);
                break;
              case "add generated":
                ret.push(" GENERATED ");
                visitGenerated(m, c);
                break;
              default:
                throw utils_1.NotSupported.never(c);
            }
            ret.push(" ");
          }
          function visitQualifiedName(cs, forceDoubleQuote) {
            if (cs.schema) {
              ret.push(ident(cs.schema), ".");
            }
            ret.push(ident(cs.name, forceDoubleQuote), " ");
          }
          function visitQualifiedNameAliased(cs) {
            visitQualifiedName(cs);
            if (cs.alias) {
              ret.push(" AS ", ident(cs.alias), " ");
            }
          }
          function visitOrderBy(m, orderBy) {
            ret.push(" ORDER BY ");
            list(orderBy, (e) => {
              m.expr(e.by);
              if (e.order) {
                ret.push(" ", e.order, " ");
              }
              if (e.nulls) {
                ret.push(" NULLS ", e.nulls, " ");
              }
            }, false);
          }
          function visitSetVal(set) {
            switch (set.type) {
              case "default":
                ret.push("DEFAULT ");
                break;
              case "identifier":
                ret.push(set.name);
                break;
              case "list":
                let first = true;
                for (const v of set.values) {
                  if (!first) {
                    ret.push(", ");
                  }
                  first = false;
                  visitSetVal(v);
                }
                break;
              case "value":
                ret.push(typeof set.value === "number" ? set.value.toString() : (0, pg_escape_1.literal)(set.value));
                break;
              default:
                throw utils_1.NotSupported.never(set);
            }
          }
          function visitGenerated(m, alter) {
            if (alter.always) {
              ret.push(alter.always.toUpperCase(), " ");
            }
            ret.push("AS IDENTITY ");
            if (alter.sequence) {
              ret.push("(");
              if (alter.sequence.name) {
                ret.push("SEQUENCE NAME ");
                visitQualifiedName(alter.sequence.name);
                ret.push(" ");
              }
              visitSeqOpts(m, alter.sequence);
              ret.push(") ");
            }
          }
          function visitSeqOpts(m, cs) {
            if (cs.as) {
              ret.push("AS ");
              m.dataType(cs.as);
              ret.push(" ");
            }
            if (typeof cs.incrementBy === "number") {
              ret.push("INCREMENT BY ", cs.incrementBy.toString(), " ");
            }
            if (cs.minValue === "no minvalue") {
              ret.push("NO MINVALUE ");
            }
            if (typeof cs.minValue === "number") {
              ret.push("MINVALUE ", cs.minValue.toString(), " ");
            }
            if (cs.maxValue === "no maxvalue") {
              ret.push("NO MAXVALUE ");
            }
            if (typeof cs.maxValue === "number") {
              ret.push("MAXVALUE ", cs.maxValue.toString(), " ");
            }
            if (typeof cs.startWith === "number") {
              ret.push("START WITH ", cs.startWith.toString(), " ");
            }
            if (typeof cs.cache === "number") {
              ret.push("CACHE ", cs.cache.toString(), " ");
            }
            if (cs.cycle) {
              ret.push(cs.cycle, " ");
            }
            if (cs.ownedBy === "none") {
              ret.push("OWNED BY NONE ");
            } else if (cs.ownedBy) {
              ret.push("OWNED BY ");
              visitQColumn(cs.ownedBy);
            }
            if ("restart" in cs) {
              if (cs.restart === true) {
                ret.push("RESTART ");
              } else if (cs.restart) {
                ret.push("RESTART WITH ", cs.restart.toString(), " ");
              }
            }
          }
          function visitQColumn(col) {
            if (col.schema) {
              ret.push(ident(col.schema), ".");
            }
            ret.push(ident(col.table), ".", ident(col.column), " ");
          }
          function join(m, j, tbl) {
            if (!j) {
              tbl();
              return;
            }
            ret.push(j.type, " ");
            tbl();
            if (j.on) {
              ret.push("ON ");
              m.expr(j.on);
            }
            if (j.using) {
              ret.push("USING (");
              list(j.using, (x) => ret.push(name2(x)), false);
              ret.push(") ");
            }
            ret.push(" ");
          }
          function visitOp(v) {
            if (v.opSchema) {
              ret.push(" operator(", ident(v.opSchema), ".", v.op, ") ");
            } else {
              ret.push(" ", v.op, " ");
            }
          }
          const visitor = (0, ast_visitor_1.astVisitor)((m) => ({
            addColumn: (...args) => {
              ret.push(" ADD COLUMN ");
              if (args[0].ifNotExists) {
                ret.push("IF NOT EXISTS ");
              }
              m.super().addColumn(...args);
            },
            createExtension: (e) => {
              ret.push("CREATE EXTENSION ");
              if (e.ifNotExists) {
                ret.push(" IF NOT EXISTS ");
              }
              ret.push(name2(e.extension));
              if (!e.from && !e.version && !e.schema) {
                return;
              }
              ret.push(" WITH");
              if (e.schema) {
                ret.push(" SCHEMA ", name2(e.schema));
              }
              if (e.version) {
                ret.push(" VERSION ", (0, pg_escape_1.literal)(e.version.value));
              }
              if (e.from) {
                ret.push(" FROM ", (0, pg_escape_1.literal)(e.from.value));
              }
            },
            tablespace: (t) => {
              ret.push("TABLESPACE ", name2(t.tablespace));
            },
            addConstraint: (c) => {
              ret.push(" ADD ");
              const cname = c.constraint.constraintName;
              if (cname) {
                ret.push(" CONSTRAINT ", name2(cname), " ");
              }
              addConstraint(c.constraint, m);
            },
            alterColumn: (c, t) => {
              ret.push(" ALTER COLUMN ", name2(c.column), " ");
              m.super().alterColumn(c, t);
            },
            setColumnDefault: (a, t, c) => {
              ret.push(" SET DEFAULT ");
              m.expr(a.default);
              if (a.updateExisting) {
                throw new Error("Not implemented: updateExisting on set column default");
              }
            },
            createEnum: (t) => {
              ret.push("CREATE TYPE ");
              visitQualifiedName(t.name);
              ret.push(" AS ENUM ");
              list(t.values, (x) => ret.push((0, pg_escape_1.literal)(x.value)), true);
              ret.push(" ");
            },
            createCompositeType: (c) => {
              ret.push("CREATE TYPE ");
              visitQualifiedName(c.name);
              ret.push(" AS ");
              list(c.attributes, (x) => {
                ret.push(name2(x.name), " ");
                m.dataType(x.dataType);
                if (x.collate) {
                  ret.push("COLLATE ");
                  visitQualifiedName(x.collate);
                }
              }, true);
              ret.push(" ");
            },
            setTableOwner: (o) => {
              ret.push(" OWNER TO ", name2(o.to));
            },
            alterColumnSimple: (c) => ret.push(c.type),
            alterColumnAddGenerated: (alter) => {
              ret.push(" ADD GENERATED ");
              visitGenerated(m, alter);
            },
            setColumnType: (t) => {
              ret.push(" SET DATA TYPE ");
              m.dataType(t.dataType);
              ret.push(" ");
            },
            alterTable: (t) => {
              ret.push("ALTER TABLE ");
              if (t.ifExists) {
                ret.push(" IF EXISTS ");
              }
              if (t.only) {
                ret.push(" ONLY ");
              }
              visitQualifiedNameAliased(t.table);
              list(t.changes, (change) => m.tableAlteration(change, t.table), false);
            },
            alterIndex: (t) => {
              ret.push("ALTER INDEX ");
              if (t.ifExists) {
                ret.push(" IF EXISTS ");
              }
              visitQualifiedNameAliased(t.index);
              switch (t.change.type) {
                case "rename":
                  ret.push(" RENAME TO ");
                  visitQualifiedName(t.change.to);
                  ret.push(" ");
                  break;
                case "set tablespace":
                  ret.push(" SET TABLESPACE ");
                  visitQualifiedName(t.change.tablespace);
                  ret.push(" ");
                  break;
                default:
                  throw utils_1.NotSupported.never(t.change, "Alter index type not supported: ");
              }
            },
            tableAlteration: (change, table) => {
              switch (change.type) {
                case "add column":
                  return m.addColumn(change, table);
                case "add constraint":
                  return m.addConstraint(change, table);
                case "alter column":
                  return m.alterColumn(change, table);
                case "rename":
                  return m.renameTable(change, table);
                case "rename column":
                  return m.renameColumn(change, table);
                case "rename constraint":
                  return m.renameConstraint(change, table);
                case "drop column":
                  return m.dropColumn(change, table);
                case "drop constraint":
                  return m.dropConstraint(change, table);
                case "owner":
                  return m.setTableOwner(change, table);
                default:
                  throw utils_1.NotSupported.never(change);
              }
            },
            array: (v) => {
              ret.push(v.type === "array" ? "ARRAY[" : "(");
              list(v.expressions, (e) => m.expr(e), false);
              ret.push(v.type === "array" ? "]" : ")");
            },
            arrayIndex: (v) => {
              m.expr(v.array);
              ret.push("[");
              m.expr(v.index);
              ret.push("] ");
            },
            expr: (e) => {
              if (e.type === "ref") {
                m.ref(e);
                return;
              }
              if (e.type === "list") {
                m.super().expr(e);
                return;
              }
              ret.push("(");
              m.super().expr(e);
              ret.push(")");
            },
            callOverlay: (o) => {
              ret.push("OVERLAY(");
              m.expr(o.value);
              ret.push(" PLACING ");
              m.expr(o.placing);
              ret.push(" FROM ");
              m.expr(o.from);
              if (o.for) {
                ret.push(" FOR ");
                m.expr(o.for);
              }
              ret.push(")");
            },
            callSubstring: (s) => {
              ret.push("SUBSTRING(");
              m.expr(s.value);
              if (s.from) {
                ret.push(" FROM ");
                m.expr(s.from);
              }
              if (s.for) {
                ret.push(" FOR ");
                m.expr(s.for);
              }
              ret.push(")");
            },
            binary: (v) => {
              m.expr(v.left);
              visitOp(v);
              m.expr(v.right);
            },
            call: (v) => {
              visitQualifiedName(v.function);
              ret.push("(");
              if (v.distinct) {
                ret.push(v.distinct, " ");
              }
              list(v.args, (e) => m.expr(e), false);
              if (v.orderBy) {
                visitOrderBy(m, v.orderBy);
              }
              ret.push(") ");
              if (v.filter) {
                ret.push("filter (where ");
                m.expr(v.filter);
                ret.push(") ");
              }
              if (v.over) {
                ret.push("over (");
                if (v.over.partitionBy) {
                  ret.push("PARTITION BY ");
                  list(v.over.partitionBy, (x) => m.expr(x), false);
                  ret.push(" ");
                }
                if (v.over.orderBy) {
                  visitOrderBy(m, v.over.orderBy);
                  ret.push(" ");
                }
                ret.push(") ");
              }
            },
            case: (c) => {
              ret.push("CASE ");
              if (c.value) {
                m.expr(c.value);
              }
              for (const e of c.whens) {
                ret.push(" WHEN ");
                m.expr(e.when);
                ret.push(" THEN ");
                m.expr(e.value);
              }
              if (c.else) {
                ret.push(" ELSE ");
                m.expr(c.else);
              }
              ret.push(" END ");
            },
            cast: (c) => {
              m.expr(c.operand);
              ret.push("::");
              m.dataType(c.to);
            },
            constant: (c) => {
              switch (c.type) {
                case "boolean":
                  ret.push(c.value ? "true" : "false");
                  break;
                case "integer":
                  ret.push(c.value.toString(10));
                  break;
                case "numeric":
                  ret.push(c.value.toString());
                  if (Number.isInteger(c.value)) {
                    ret.push(".");
                  }
                  break;
                case "null":
                  ret.push("null");
                  break;
                case "constant":
                  break;
                case "string":
                  ret.push((0, pg_escape_1.literal)(c.value));
                  break;
                default:
                  throw utils_1.NotSupported.never(c);
              }
            },
            valueKeyword: (v) => {
              ret.push(v.keyword, " ");
            },
            comment: (c) => {
              ret.push("COMMENT ON ", c.on.type.toUpperCase(), " ");
              switch (c.on.type) {
                case "column":
                  visitQColumn(c.on.column);
                  break;
                default:
                  visitQualifiedName(c.on.name);
                  break;
              }
              ret.push(" IS ", (0, pg_escape_1.literal)(c.comment), " ");
            },
            extract: (v) => {
              ret.push("EXTRACT (", v.field.name.toUpperCase(), " FROM ");
              m.expr(v.from);
              ret.push(") ");
            },
            createColumn: (c) => {
              var _a;
              ret.push(name2(c.name), " ");
              m.dataType(c.dataType);
              ret.push(" ");
              if (c.collate) {
                ret.push("COLLATE ");
                visitQualifiedName(c.collate);
              }
              for (const cst of (_a = c.constraints) !== null && _a !== void 0 ? _a : []) {
                m.constraint(cst);
              }
            },
            begin: (beg) => {
              ret.push("BEGIN ");
              if (beg.isolationLevel) {
                ret.push("ISOLATION LEVEL ", beg.isolationLevel.toUpperCase(), " ");
              }
              if (beg.writeable) {
                ret.push(beg.writeable.toUpperCase(), " ");
              }
              if (typeof beg.deferrable === "boolean") {
                if (!beg.deferrable) {
                  ret.push("NOT ");
                }
                ret.push("DEFERRABLE ");
              }
            },
            alterSequence: (cs) => {
              ret.push("ALTER SEQUENCE ");
              if (cs.ifExists) {
                ret.push("IF EXISTS ");
              }
              visitQualifiedName(cs.name);
              switch (cs.change.type) {
                case "set options":
                  visitSeqOpts(m, cs.change);
                  break;
                case "rename":
                  ret.push("RENAME TO ", name2(cs.change.newName), " ");
                  break;
                case "set schema":
                  ret.push("SET SCHEMA ", name2(cs.change.newSchema), " ");
                  break;
                case "owner to":
                  const own = cs.change.owner;
                  ret.push("OWNER TO ", name2(cs.change.owner), " ");
                  break;
                default:
                  throw utils_1.NotSupported.never(cs.change);
              }
            },
            createSequence: (cs) => {
              ret.push("CREATE ");
              if (cs.temp) {
                ret.push("TEMPORARY ");
              }
              ret.push("SEQUENCE ");
              if (cs.ifNotExists) {
                ret.push("IF NOT EXISTS ");
              }
              visitQualifiedName(cs.name);
              visitSeqOpts(m, cs.options);
            },
            drop: (val) => {
              ret.push(val.type.toUpperCase(), " ");
              if (val.concurrently) {
                ret.push("CONCURRENTLY ");
              }
              if (val.ifExists) {
                ret.push("IF EXISTS ");
              }
              list(val.names, (x) => m.tableRef(x), false);
              if (val.cascade) {
                ret.push(val.cascade.toUpperCase(), " ");
              }
            },
            constraint: (cst) => {
              if (cst.constraintName) {
                ret.push(" CONSTRAINT ", name2(cst.constraintName), " ");
              }
              addConstraint(cst, m);
            },
            do: (d) => {
              ret.push("DO");
              if (d.language) {
                ret.push(" LANGUAGE ", d.language.name);
              }
              ret.push(" $$", d.code, "$$");
            },
            createFunction: (c) => {
              var _a;
              ret.push(c.orReplace ? "CREATE OR REPLACE FUNCTION " : "CREATE FUNCTION ");
              visitQualifiedName(c.name);
              list(c.arguments, (a) => {
                if (a.mode) {
                  ret.push(a.mode, " ");
                }
                if (a.name) {
                  ret.push(name2(a.name), " ");
                }
                m.dataType(a.type);
                if (a.default) {
                  ret.push(" = ");
                  m.expr(a.default);
                }
              }, true);
              if (c.returns) {
                switch (c.returns.kind) {
                  case "table":
                    ret.push(" RETURNS TABLE ");
                    list(c.returns.columns, (t) => {
                      ret.push(name2(t.name), " ");
                      m.dataType(t.type);
                    }, true);
                    break;
                  case void 0:
                  case null:
                  case "array":
                    ret.push(" RETURNS ");
                    m.dataType(c.returns);
                    break;
                  default:
                    throw utils_1.NotSupported.never(c.returns);
                }
              }
              ret.push(" AS $$", (_a = c.code) !== null && _a !== void 0 ? _a : "", "$$");
              if (c.language) {
                ret.push("LANGUAGE ", c.language.name, " ");
              }
              if (c.purity) {
                ret.push(c.purity.toUpperCase(), " ");
              }
              if (typeof c.leakproof === "boolean") {
                ret.push(c.leakproof ? "LEAKPROOF " : "NOT LEAKPROOF ");
              }
              switch (c.onNullInput) {
                case "call":
                  ret.push("CALLED ON NULL INPUT ");
                  break;
                case "null":
                  ret.push("RETURNS NULL ON NULL INPUT ");
                  break;
                case "strict":
                  ret.push("STRICT ");
                  break;
                case null:
                case void 0:
                  break;
                default:
                  throw utils_1.NotSupported.never(c.onNullInput);
              }
            },
            dropFunction: (d) => {
              ret.push("DROP FUNCTION ");
              if (d.ifExists) {
                ret.push("IF EXISTS ");
              }
              visitQualifiedName(d.name);
              if (d.arguments) {
                list(d.arguments, (a) => {
                  if (a.name) {
                    visitQualifiedName(a.name);
                    ret.push(" ");
                  }
                  m.dataType(a.type);
                }, true);
              }
              ret.push(" ");
            },
            with: (w) => {
              ret.push("WITH ");
              list(w.bind, (b) => {
                ret.push(name2(b.alias), " AS (");
                m.statement(b.statement);
                ret.push(") ");
              }, false);
              m.statement(w.in);
            },
            withRecursive: (val) => {
              ret.push("WITH RECURSIVE ", name2(val.alias), "(", ...val.columnNames.map(name2).join(", "), ") AS (");
              m.union(val.bind);
              ret.push(") ");
              m.statement(val.in);
            },
            setGlobal: (g) => {
              ret.push("SET ", name2(g.variable), " = ");
              visitSetVal(g.set);
            },
            setTimezone: (g) => {
              ret.push("SET TIME ZONE ");
              switch (g.to.type) {
                case "default":
                case "local":
                  ret.push(g.to.type.toUpperCase(), " ");
                  break;
                case "value":
                  ret.push(typeof g.to.value === "string" ? (0, pg_escape_1.literal)(g.to.value) : g.to.value.toString(10));
                  break;
                case "interval":
                  ret.push("INTERVAL ", (0, pg_escape_1.literal)(g.to.value), " HOUR TO MINUTE");
                  break;
                default:
                  throw utils_1.NotSupported.never(g.to);
              }
            },
            dataType: (d) => {
              var _a, _b;
              if ((d === null || d === void 0 ? void 0 : d.kind) === "array") {
                m.dataType(d.arrayOf);
                ret.push("[]");
                return;
              }
              if (!(d === null || d === void 0 ? void 0 : d.name)) {
                ret.push("unkown");
                return;
              }
              let appendConfig = true;
              if (d.schema) {
                visitQualifiedName(d, d.doubleQuoted);
              } else {
                if (d.doubleQuoted) {
                  visitQualifiedName(d, true);
                } else {
                  switch (d.name) {
                    case "double precision":
                    case "character varying":
                    case "bit varying":
                      ret.push(d.name, " ");
                      break;
                    case "time without time zone":
                    case "timestamp without time zone":
                    case "time with time zone":
                    case "timestamp with time zone":
                      const parts = d.name.split(" ");
                      ret.push(parts.shift());
                      if ((_a = d.config) === null || _a === void 0 ? void 0 : _a.length) {
                        list(d.config, (v) => ret.push(v.toString(10)), true);
                      }
                      ret.push(" ");
                      ret.push(parts.join(" "), " ");
                      appendConfig = false;
                      break;
                    default:
                      visitQualifiedName(d);
                      break;
                  }
                }
              }
              if (appendConfig && ((_b = d.config) === null || _b === void 0 ? void 0 : _b.length)) {
                list(d.config, (v) => ret.push(v.toString(10)), true);
              }
            },
            createIndex: (c) => {
              ret.push(c.unique ? "CREATE UNIQUE INDEX " : "CREATE INDEX ");
              if (c.ifNotExists) {
                ret.push(" IF NOT EXISTS ");
              }
              if (c.indexName) {
                ret.push(name2(c.indexName), " ");
              }
              ret.push("ON ");
              m.tableRef(c.table);
              if (c.using) {
                ret.push("USING ", name2(c.using), " ");
              }
              list(c.expressions, (e) => {
                m.expr(e.expression);
                ret.push(" ");
                if (e.collate) {
                  ret.push("COLLATE ");
                  visitQualifiedName(e.collate);
                }
                if (e.opclass) {
                  visitQualifiedName(e.opclass);
                }
                if (e.order) {
                  ret.push(e.order, " ");
                }
                if (e.nulls) {
                  ret.push("nulls ", e.nulls, " ");
                }
              }, true);
              if (c.with) {
                ret.push("WITH ");
                list(c.with, (w) => {
                  ret.push(w.parameter, " = ", (0, pg_escape_1.literal)(w.value));
                }, true);
              }
              if (c.tablespace) {
                ret.push("TABLESPACE ", ident(c.tablespace));
              }
              if (c.where) {
                ret.push(" WHERE ");
                m.expr(c.where);
              }
              ret.push(" ");
            },
            createTable: (t) => {
              var _a;
              ret.push("CREATE ");
              if (t.locality) {
                ret.push(t.locality.toUpperCase(), " ");
              }
              if (t.temporary) {
                ret.push("TEMPORARY ");
              }
              if (t.unlogged) {
                ret.push("UNLOGGED ");
              }
              ret.push(t.ifNotExists ? "TABLE IF NOT EXISTS " : "TABLE ");
              m.tableRef(t.name);
              ret.push("(");
              list(t.columns, (c) => {
                switch (c.kind) {
                  case "column":
                    return m.createColumn(c);
                  case "like table":
                    return m.likeTable(c);
                  default:
                    throw utils_1.NotSupported.never(c);
                }
              }, false);
              if (t.constraints) {
                ret.push(", ");
                list(t.constraints, (c) => {
                  const cname = c.constraintName;
                  if (cname) {
                    ret.push("CONSTRAINT ", name2(cname), " ");
                  }
                  addConstraint(c, m);
                }, false);
              }
              ret.push(") ");
              if ((_a = t.inherits) === null || _a === void 0 ? void 0 : _a.length) {
                ret.push(" INHERITS ");
                list(t.inherits, (i) => visitQualifiedName(i), true);
              }
            },
            likeTable: (l) => {
              ret.push(" LIKE ");
              m.tableRef(l.like);
              ret.push(" ");
              for (const { verb, option } of l.options) {
                ret.push(verb.toUpperCase(), " ", option.toUpperCase(), " ");
              }
            },
            createSchema: (s) => {
              ret.push(s.ifNotExists ? "CREATE SCHEMA IF NOT EXISTS " : "CREATE SCHEMA ");
              ret.push(name2(s.name));
            },
            truncateTable: (t) => {
              ret.push("TRUNCATE TABLE ");
              let first = true;
              for (const tbl of t.tables) {
                if (!first) {
                  ret.push(", ");
                }
                first = false;
                m.tableRef(tbl);
              }
              if (t.identity) {
                switch (t.identity) {
                  case "restart":
                    ret.push(" RESTART IDENTITY ");
                    break;
                  case "continue":
                    ret.push(" CONTINUE IDENTITY ");
                    break;
                }
              }
              if (t.cascade) {
                ret.push(" ", t.cascade, " ");
              }
            },
            delete: (t) => {
              ret.push("DELETE FROM ");
              m.tableRef(t.from);
              if (t.where) {
                ret.push(" WHERE ");
                m.expr(t.where);
              }
              if (t.returning) {
                ret.push(" RETURNING ");
                list(t.returning, (r) => m.selectionColumn(r), false);
              }
              ret.push(" ");
            },
            dropColumn: (t) => {
              ret.push(" DROP COLUMN ");
              if (t.ifExists) {
                ret.push(" IF EXISTS ");
              }
              ret.push(name2(t.column));
              if (t.behaviour) {
                ret.push(" ", t.behaviour);
              }
              ret.push(" ");
            },
            dropConstraint: (t) => {
              ret.push(" DROP CONSTRAINT ");
              if (t.ifExists) {
                ret.push(" IF EXISTS ");
              }
              ret.push(name2(t.constraint));
              if (t.behaviour) {
                ret.push(" ", t.behaviour.toUpperCase(), " ");
              }
            },
            from: (t) => m.super().from(t),
            fromCall: (s) => {
              join(m, s.join, () => {
                var _a, _b;
                m.call(s);
                if (s.withOrdinality) {
                  ret.push(" WITH ORDINALITY");
                }
                if (s.alias) {
                  ret.push(" AS ", name2(s.alias), " ");
                  const len = (_b = (_a = s.alias.columns) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
                  if (len > 0) {
                    ret.push("(");
                    for (let ix = 0; ix < len; ++ix) {
                      if (ix !== 0) {
                        ret.push(", ");
                      }
                      ret.push(name2(s.alias.columns[ix]));
                    }
                    ret.push(")");
                  }
                }
              });
              ret.push(" ");
            },
            fromStatement: (s) => {
              join(m, s.join, () => {
                ret.push("(");
                m.select(s.statement);
                ret.push(") ");
                if (s.alias) {
                  ret.push(" AS ", ident(s.alias));
                  if (s.columnNames) {
                    list(s.columnNames, (c) => ret.push(name2(c)), true);
                  }
                  ret.push(" ");
                }
              });
              ret.push(" ");
            },
            values: (s) => {
              ret.push("VALUES ");
              list(s.values, (vlist) => {
                list(vlist, (e) => {
                  m.expr(e);
                }, true);
              }, false);
            },
            fromTable: (s) => {
              join(m, s.join, () => {
                m.tableRef(s.name);
                if (s.name.columnNames) {
                  if (!s.name.alias) {
                    throw new Error("Cannot specify aliased column names without an alias");
                  }
                  list(s.name.columnNames, (c) => ret.push(name2(c)), true);
                }
              });
            },
            join: (j) => {
              throw new Error("Should not happen \u{1F480}");
            },
            insert: (i) => {
              ret.push("INSERT INTO ");
              m.tableRef(i.into);
              if (i.columns) {
                ret.push("(", i.columns.map(name2).join(", "), ")");
              }
              ret.push(" ");
              if (i.overriding) {
                ret.push("OVERRIDING ", i.overriding.toUpperCase(), " VALUE ");
              }
              m.select(i.insert);
              ret.push(" ");
              if (i.onConflict) {
                ret.push("ON CONFLICT ");
                const on = i.onConflict.on;
                switch (on === null || on === void 0 ? void 0 : on.type) {
                  case "on expr":
                    list(on.exprs, (e) => m.expr(e), true);
                    break;
                  case "on constraint":
                    ret.push("ON CONSTRAINT ");
                    visitQualifiedName(on.constraint);
                  case null:
                  case void 0:
                    break;
                  default:
                    throw utils_1.NotSupported.never(on);
                }
                if (i.onConflict.do === "do nothing") {
                  ret.push(" DO NOTHING");
                } else {
                  ret.push(" DO UPDATE SET ");
                  list(i.onConflict.do.sets, (s) => m.set(s), false);
                  if (i.onConflict.where) {
                    ret.push(" WHERE ");
                    m.expr(i.onConflict.where);
                  }
                }
                ret.push(" ");
              }
              if (i.returning) {
                ret.push(" RETURNING ");
                list(i.returning, (r) => m.selectionColumn(r), false);
              }
            },
            raise: (r) => {
              var _a, _b;
              ret.push("RAISE ");
              if (r.level) {
                ret.push(r.level.toUpperCase(), " ");
              }
              ret.push((0, pg_escape_1.literal)(r.format), " ");
              if ((_a = r.formatExprs) === null || _a === void 0 ? void 0 : _a.length) {
                ret.push(", ");
                list(r.formatExprs, (e) => m.expr(e), false);
              }
              if ((_b = r.using) === null || _b === void 0 ? void 0 : _b.length) {
                ret.push(" USING ");
                list(r.using, ({ type, value: value2 }) => {
                  ret.push(type.toUpperCase(), "=");
                  m.expr(value2);
                }, false);
              }
              ret.push(" ");
            },
            default: () => {
              ret.push(" DEFAULT ");
            },
            member: (e) => {
              m.expr(e.operand);
              ret.push(e.op);
              ret.push(typeof e.member === "number" ? e.member.toString(10) : (0, pg_escape_1.literal)(e.member));
            },
            ref: (r) => {
              if (r.table) {
                visitQualifiedName(r.table);
                ret.push(".");
              }
              ret.push(r.name === "*" ? "*" : ident(r.name));
            },
            parameter: (p) => {
              ret.push(p.name);
            },
            renameColumn: (r) => {
              ret.push(" RENAME COLUMN ", name2(r.column), " TO ", name2(r.to));
            },
            renameConstraint: (r) => {
              ret.push(" RENAME CONSTRAINT ", name2(r.constraint), " TO ", name2(r.to));
            },
            renameTable: (r) => {
              ret.push(" RENAME TO ", name2(r.to));
            },
            createView: (c) => {
              ret.push("CREATE ");
              if (c.orReplace) {
                ret.push("OR REPLACE ");
              }
              if (c.temp) {
                ret.push("TEMP ");
              }
              if (c.recursive) {
                ret.push("RECURSIVE ");
              }
              ret.push("VIEW ");
              m.tableRef(c.name);
              if (c.columnNames) {
                list(c.columnNames, (c2) => ret.push(name2(c2)), true);
              }
              const opts = c.parameters && Object.entries(c.parameters);
              if (opts === null || opts === void 0 ? void 0 : opts.length) {
                ret.push(" WITH ");
                list(opts, ([k, v]) => ret.push(k, "=", v), false);
              }
              ret.push(" AS ");
              m.select(c.query);
              if (c.checkOption) {
                ret.push(" WITH ", c.checkOption.toUpperCase(), " CHECK OPTION");
              }
            },
            createMaterializedView: (c) => {
              ret.push("CREATE MATERIALIZED VIEW ");
              if (c.ifNotExists) {
                ret.push("IF NOT EXISTS ");
              }
              m.tableRef(c.name);
              if (c.columnNames) {
                list(c.columnNames, (c2) => ret.push(name2(c2)), true);
              }
              const opts = c.parameters && Object.entries(c.parameters);
              if (opts === null || opts === void 0 ? void 0 : opts.length) {
                ret.push(" WITH ");
                list(opts, ([k, v]) => ret.push(k, "=", v), false);
              }
              if (c.tablespace) {
                ret.push(" TABLESPACE ", name2(c.tablespace));
              }
              ret.push(" AS ");
              m.select(c.query);
              if (typeof c.withData === "boolean") {
                ret.push(c.withData ? " WITH DATA" : " WITH NO DATA");
              }
            },
            refreshMaterializedView: (val) => {
              ret.push("REFRESH MATERIALIZED VIEW ");
              if (val.concurrently) {
                ret.push("CONCURRENTLY ");
              }
              m.tableRef(val.name);
              if (typeof val.withData === "boolean") {
                ret.push(val.withData ? " WITH DATA" : " WITH NO DATA");
              }
            },
            select: (s) => m.super().select(s),
            selection: (s) => {
              ret.push("SELECT ");
              if (s.distinct) {
                if (typeof s.distinct === "string") {
                  ret.push(s.distinct.toUpperCase());
                } else {
                  ret.push(" DISTINCT ON ");
                  list(s.distinct, (v) => m.expr(v), true);
                }
                ret.push(" ");
              }
              if (s.columns) {
                list(s.columns, (c) => m.selectionColumn(c), false);
              }
              ret.push(" ");
              if (s.from) {
                ret.push("FROM ");
                const tblCnt = s.from.length;
                for (let i = 0; i < tblCnt; i++) {
                  const f = s.from[i];
                  if (i > 0 && !f.join) {
                    ret.push(",");
                  }
                  m.from(f);
                }
                ret.push(" ");
              }
              if (s.where) {
                ret.push("WHERE ");
                m.expr(s.where);
                ret.push(" ");
              }
              if (s.groupBy) {
                ret.push("GROUP BY ");
                list(s.groupBy, (e) => m.expr(e), false);
                ret.push(" ");
                if (s.having) {
                  ret.push(" HAVING ");
                  m.expr(s.having);
                  ret.push(" ");
                }
              }
              if (s.orderBy) {
                visitOrderBy(m, s.orderBy);
                ret.push(" ");
              }
              if (s.limit) {
                if (s.limit.offset) {
                  ret.push(`OFFSET `);
                  m.expr(s.limit.offset);
                }
                if (s.limit.limit) {
                  ret.push(`LIMIT `);
                  m.expr(s.limit.limit);
                }
              }
              if (s.for) {
                ret.push("FOR ", s.for.type.toUpperCase());
                if (s.skip) {
                  ret.push(" ", s.skip.type.toUpperCase());
                }
              }
            },
            show: (s) => {
              ret.push("SHOW ", name2(s.variable));
            },
            prepare: (s) => {
              var _a;
              ret.push("PREPARE ", name2(s.name));
              if ((_a = s.args) === null || _a === void 0 ? void 0 : _a.length) {
                list(s.args, (a) => m.dataType(a), true);
              }
              ret.push(" AS ");
              m.statement(s.statement);
            },
            deallocate: (s) => {
              ret.push("DEALLOCATE ");
              if ("name" in s.target) {
                ret.push(s.target.name);
                return;
              }
              ret.push("ALL");
            },
            arraySelect: (s) => {
              ret.push("array(");
              m.select(s.select);
              ret.push(")");
            },
            union: (s) => {
              ret.push("(");
              m.statement(s.left);
              ret.push(") ", s.type.toUpperCase(), " ");
              if (s.right.type === "union" || s.right.type === "union all") {
                m.union(s.right);
              } else {
                ret.push("(");
                m.statement(s.right);
                ret.push(")");
              }
            },
            selectionColumn: (c) => {
              m.expr(c.expr);
              if (c.alias) {
                ret.push(" AS ", name2(c.alias));
              }
              ret.push(" ");
            },
            set: (s) => {
              ret.push(name2(s.column), " = ");
              m.expr(s.value);
              ret.push(" ");
            },
            statement: (s) => m.super().statement(s),
            tableRef: (r) => {
              visitQualifiedName(r);
              if (r.alias) {
                ret.push(" AS ", ident(r.alias));
              }
              ret.push(" ");
            },
            ternary: (t) => {
              m.expr(t.value);
              ret.push(" ", t.op, " ");
              m.expr(t.lo);
              ret.push(" AND ");
              m.expr(t.hi);
              ret.push(" ");
            },
            transaction: (t) => {
              ret.push(t.type);
            },
            unary: (t) => {
              switch (t.op) {
                case "+":
                case "-":
                  visitOp(t);
                  m.expr(t.operand);
                  break;
                case "NOT":
                  ret.push(t.op);
                  ret.push(" ");
                  m.expr(t.operand);
                  break;
                default:
                  m.expr(t.operand);
                  ret.push(" ");
                  ret.push(t.op);
              }
            },
            update: (u) => {
              ret.push("UPDATE ");
              m.tableRef(u.table);
              ret.push(" SET ");
              list(u.sets, (s) => m.set(s), false);
              ret.push(" ");
              if (u.from) {
                ret.push("FROM ");
                m.from(u.from);
                ret.push(" ");
              }
              if (u.where) {
                ret.push("WHERE ");
                m.expr(u.where);
                ret.push(" ");
              }
              if (u.returning) {
                ret.push(" RETURNING ");
                list(u.returning, (r) => m.selectionColumn(r), false);
                ret.push(" ");
              }
            }
          }));
          exports2.toSql = {};
          const proto = ast_mapper_1.AstDefaultMapper.prototype;
          for (const k of Object.getOwnPropertyNames(proto)) {
            const orig = proto[k];
            if (k === "constructor" || k === "super" || typeof orig !== "function") {
              continue;
            }
            exports2.toSql[k] = function(...args) {
              try {
                visitor[k].apply(visitor, args);
                return ret.join("").trim();
              } finally {
                ret = [];
              }
            };
          }
        },
        /* 20 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.literal = void 0;
          function literal(val) {
            if (null == val)
              return "NULL";
            if (Array.isArray(val)) {
              var vals = val.map(literal);
              return "(" + vals.join(", ") + ")";
            }
            var backslash = ~val.indexOf("\\");
            var prefix = backslash ? "E" : "";
            val = val.replace(/'/g, "''");
            val = val.replace(/\\/g, "\\\\");
            return prefix + "'" + val + "'";
          }
          exports2.literal = literal;
          ;
        },
        /* 21 */
        /***/
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.locationOf = void 0;
          function locationOf(node) {
            const n = node._location;
            if (!n) {
              throw new Error("This statement has not been parsed using location tracking (which has a small performance hit). ");
            }
            return n;
          }
          exports2.locationOf = locationOf;
          ;
          ;
        }
        /******/
      ])
    );
  }
});

// node_modules/.pnpm/mime-db@1.53.0/node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/.pnpm/mime-db@1.53.0/node_modules/mime-db/db.json"(exports, module) {
    module.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/ace+json": {
        source: "iana",
        compressible: true
      },
      "application/ace-groupcomm+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/aif+cbor": {
        source: "iana"
      },
      "application/aif+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-cdni+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-cdnifilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-propmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-propmapparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-tips+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-tipsparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/appinstaller": {
        compressible: false,
        extensions: ["appinstaller"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/appx": {
        compressible: false,
        extensions: ["appx"]
      },
      "application/appxbundle": {
        compressible: false,
        extensions: ["appxbundle"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/automationml-aml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["aml"]
      },
      "application/automationml-amlx+zip": {
        source: "iana",
        compressible: false,
        extensions: ["amlx"]
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/bufr": {
        source: "iana"
      },
      "application/c2pa": {
        source: "iana"
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/cid-edhoc+cbor-seq": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/concise-problem-details+cbor": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cose-x509": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwl": {
        source: "iana",
        extensions: ["cwl"]
      },
      "application/cwl+json": {
        source: "iana",
        compressible: true
      },
      "application/cwl+yaml": {
        source: "iana"
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dpop+jwt": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "apache",
        compressible: true,
        extensions: ["ecma"]
      },
      "application/edhoc+cbor-seq": {
        source: "iana"
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.legacyesn+json": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+json": {
        source: "iana",
        compressible: true
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gnap-binding-jws": {
        source: "iana"
      },
      "application/gnap-binding-jwsd": {
        source: "iana"
      },
      "application/gnap-binding-rotation-jws": {
        source: "iana"
      },
      "application/gnap-binding-rotation-jwsd": {
        source: "iana"
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/grib": {
        source: "iana"
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "iana",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "apache",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/jscontact+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jsonpath": {
        source: "iana"
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/linkset": {
        source: "iana"
      },
      "application/linkset+json": {
        source: "iana",
        compressible: true
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/logout+jwt": {
        source: "iana"
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4", "mpg4", "mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msix": {
        compressible: false,
        extensions: ["msix"]
      },
      "application/msixbundle": {
        compressible: false,
        extensions: ["msixbundle"]
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/ohttp-keys": {
        source: "iana"
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["sig", "asc"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/private-token-issuer-directory": {
        source: "iana"
      },
      "application/private-token-request": {
        source: "iana"
      },
      "application/private-token-response": {
        source: "iana"
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.implied-document+xml": {
        source: "iana",
        compressible: true
      },
      "application/prs.implied-executable": {
        source: "iana"
      },
      "application/prs.implied-object+json": {
        source: "iana",
        compressible: true
      },
      "application/prs.implied-object+json-seq": {
        source: "iana"
      },
      "application/prs.implied-object+yaml": {
        source: "iana"
      },
      "application/prs.implied-structure": {
        source: "iana"
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.vcfbzip2": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsf"]
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "apache"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-checklist": {
        source: "iana"
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-signed-tal": {
        source: "iana"
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "apache"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana",
        extensions: ["sql"]
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/st2110-41": {
        source: "iana"
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/stratum": {
        source: "iana"
      },
      "application/swid+cbor": {
        source: "iana"
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tm+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vc": {
        source: "iana"
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.1ob": {
        source: "iana"
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3a+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ach+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc8+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.5gsa2x": {
        source: "iana"
      },
      "application/vnd.3gpp.5gsa2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.crs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.current-location-discovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-regroup+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-regroup+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-regroup+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.pinapp-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.seal-group-doc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-network-qos-management-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-ue-config-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-unicast-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.seal-user-profile-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.v2x": {
        source: "iana"
      },
      "application/vnd.3gpp.vae-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acm.addressxfer+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.acm.chatbot+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "apache",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "apache"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.parquet": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.apexlang": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "apache"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.belightsoft.lhzd+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.belightsoft.lhzl+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bzip3": {
        source: "iana"
      },
      "application/vnd.c3voc.schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.cncf.helm.chart.content.v1.tar+gzip": {
        source: "iana"
      },
      "application/vnd.cncf.helm.chart.provenance.v1.prov": {
        source: "iana"
      },
      "application/vnd.cncf.helm.config.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datalog": {
        source: "iana"
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.eln+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.erofs": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "apache",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.freelog.comic": {
        source: "iana"
      },
      "application/vnd.frogans.fnc": {
        source: "apache",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "apache",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.ga4gh.passport+jwt": {
        source: "iana"
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.genozip": {
        source: "iana"
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gentoo.catmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gentoo.ebuild": {
        source: "iana"
      },
      "application/vnd.gentoo.eclass": {
        source: "iana"
      },
      "application/vnd.gentoo.gpkg": {
        source: "iana"
      },
      "application/vnd.gentoo.manifest": {
        source: "iana"
      },
      "application/vnd.gentoo.pkgmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gentoo.xpak": {
        source: "iana"
      },
      "application/vnd.geo+json": {
        source: "apache",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana",
        extensions: ["ggs"]
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.gnu.taler.exchange+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gnu.taler.merchant+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdcf"]
      },
      "application/vnd.gpxsee.map+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.hsl": {
        source: "iana"
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "apache"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "apache",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "apache"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.ipfs.ipns-record": {
        source: "iana"
      },
      "application/vnd.ipld.car": {
        source: "iana"
      },
      "application/vnd.ipld.dag-cbor": {
        source: "iana"
      },
      "application/vnd.ipld.dag-json": {
        source: "iana"
      },
      "application/vnd.ipld.raw": {
        source: "iana"
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.ldev.productlicensing": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.mdl": {
        source: "iana"
      },
      "application/vnd.mdl-mbsdf": {
        source: "iana"
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.medicalholodeck.recordxr": {
        source: "iana"
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mermaid": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.modl": {
        source: "iana"
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msgpack": {
        source: "iana"
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nato.bindingdataobject+cbor": {
        source: "iana"
      },
      "application/vnd.nato.bindingdataobject+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nato.bindingdataobject+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bdo"]
      },
      "application/vnd.nato.openxmlformats-package.iepd+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "apache",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oai.workflows": {
        source: "iana"
      },
      "application/vnd.oai.workflows+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oai.workflows+yaml": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.base": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "apache",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-master-template": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.onvif.metadata": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.pt.mundusmundi": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtm"]
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.relpipe": {
        source: "iana"
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.smintio.portals.archive": {
        source: "iana"
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sybyl.mol2": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml", "uo"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.wasmflow.wafl": {
        source: "iana"
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordlift": {
        source: "iana"
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xecrets-encrypted": {
        source: "iana"
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vp": {
        source: "iana"
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yaml": {
        source: "iana"
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+cbor": {
        source: "iana"
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-sid+json": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana",
        extensions: ["adts", "aac"]
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flac": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/matroska": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/midi-clip": {
        source: "iana"
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "apache"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        source: "iana",
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp", "dib"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/dpx": {
        source: "iana",
        extensions: ["dpx"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/j2c": {
        source: "iana"
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm", "jpgm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxl": {
        source: "iana",
        extensions: ["jxl"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif", "btf"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "iana",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/bhttp": {
        source: "iana"
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/mls": {
        source: "iana"
      },
      "message/news": {
        source: "apache"
      },
      "message/ohttp-req": {
        source: "iana"
      },
      "message/ohttp-res": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "apache"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "apache"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/jt": {
        source: "iana",
        extensions: ["jt"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/prc": {
        source: "iana",
        extensions: ["prc"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/u3d": {
        source: "iana",
        extensions: ["u3d"]
      },
      "model/vnd.bary": {
        source: "iana",
        extensions: ["bary"]
      },
      "model/vnd.cld": {
        source: "iana",
        extensions: ["cld"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana",
        extensions: ["pyo", "pyox"]
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usda": {
        source: "iana",
        extensions: ["usda"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "apache"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/hl7v2": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["md", "markdown"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/prs.texi": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.exchangeable": {
        source: "iana"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "apache"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.vcf": {
        source: "iana"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vnd.zoo.kcl": {
        source: "iana"
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/wgsl": {
        source: "iana",
        extensions: ["wgsl"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/evc": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/h266": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/matroska": {
        source: "iana"
      },
      "video/matroska-3d": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts", "m2t", "m2ts", "mts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "apache"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/.pnpm/mime-db@1.53.0/node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/.pnpm/mime-db@1.53.0/node_modules/mime-db/index.js"(exports, module) {
    module.exports = require_db();
  }
});

// node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js"(exports, module) {
    "use strict";
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i = 0; i <= path.length; ++i) {
        if (i < path.length)
          code = path.charCodeAt(i);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i);
            else
              res = path.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path;
          if (i >= 0)
            path = arguments[i];
          else {
            if (cwd === void 0)
              cwd = process.cwd();
            path = cwd;
          }
          assertPath(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var isAbsolute = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute) path = ".";
        if (path.length > 0 && trailingSeparator) path += "/";
        if (isAbsolute) return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path) {
        return path;
      },
      dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path.length - 1; i >= 1; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path.slice(0, end);
      },
      basename: function basename(path, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path.length;
          return path.slice(start, end);
        } else {
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) return "";
          return path.slice(start, end);
        }
      },
      extname: function extname2(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse3(path) {
        assertPath(path);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0) return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        var preDotState = 0;
        for (; i >= start; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
            else ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module.exports = posix;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION2 = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp2 = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar2 = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array2, setter, iteratee, accumulator) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          var value2 = array2[index];
          setter(accumulator, value2, iteratee(value2), array2);
        }
        return accumulator;
      }
      function arrayEach(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (iteratee(array2[index], index, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEachRight(array2, iteratee) {
        var length = array2 == null ? 0 : array2.length;
        while (length--) {
          if (iteratee(array2[length], length, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEvery(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (!predicate(array2[index], index, array2)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value2 = array2[index];
          if (predicate(value2, index, array2)) {
            result[resIndex++] = value2;
          }
        }
        return result;
      }
      function arrayIncludes(array2, value2) {
        var length = array2 == null ? 0 : array2.length;
        return !!length && baseIndexOf(array2, value2, 0) > -1;
      }
      function arrayIncludesWith(array2, value2, comparator) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (comparator(value2, array2[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      function arrayPush(array2, values) {
        var index = -1, length = values.length, offset = array2.length;
        while (++index < length) {
          array2[offset + index] = values[index];
        }
        return array2;
      }
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
        var length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array2[length], length, array2);
        }
        return accumulator;
      }
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string3) {
        return string3.split("");
      }
      function asciiWords(string3) {
        return string3.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value2, key, collection2) {
          if (predicate(value2, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array2, predicate, fromIndex, fromRight) {
        var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array2[index], index, array2)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array2, value2, fromIndex) {
        return value2 === value2 ? strictIndexOf(array2, value2, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array2, value2, fromIndex, comparator) {
        var index = fromIndex - 1, length = array2.length;
        while (++index < length) {
          if (comparator(array2[index], value2)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value2) {
        return value2 !== value2;
      }
      function baseMean(array2, iteratee) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseSum(array2, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object2) {
          return object2 == null ? undefined2 : object2[key];
        };
      }
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? undefined2 : object2[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value2, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value2) : iteratee(accumulator, value2, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array2, comparer) {
        var length = array2.length;
        array2.sort(comparer);
        while (length--) {
          array2[length] = array2[length].value;
        }
        return array2;
      }
      function baseSum(array2, iteratee) {
        var result, index = -1, length = array2.length;
        while (++index < length) {
          var current = iteratee(array2[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object2, props) {
        return arrayMap(props, function(key) {
          return [key, object2[key]];
        });
      }
      function baseTrim(string3) {
        return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
      }
      function baseUnary(func) {
        return function(value2) {
          return func(value2);
        };
      }
      function baseValues(object2, props) {
        return arrayMap(props, function(key) {
          return object2[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array2, placeholder) {
        var length = array2.length, result = 0;
        while (length--) {
          if (array2[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object2, key) {
        return object2 == null ? undefined2 : object2[key];
      }
      function hasUnicode(string3) {
        return reHasUnicode.test(string3);
      }
      function hasUnicodeWord(string3) {
        return reHasUnicodeWord.test(string3);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value2, key) {
          result[++index] = [key, value2];
        });
        return result;
      }
      function overArg(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      function replaceHolders(array2, placeholder) {
        var index = -1, length = array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value2 = array2[index];
          if (value2 === placeholder || value2 === PLACEHOLDER) {
            array2[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value2) {
          result[++index] = value2;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value2) {
          result[++index] = [value2, value2];
        });
        return result;
      }
      function strictIndexOf(array2, value2, fromIndex) {
        var index = fromIndex - 1, length = array2.length;
        while (++index < length) {
          if (array2[index] === value2) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array2, value2, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array2[index] === value2) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string3) {
        return hasUnicode(string3) ? unicodeSize(string3) : asciiSize(string3);
      }
      function stringToArray(string3) {
        return hasUnicode(string3) ? unicodeToArray(string3) : asciiToArray(string3);
      }
      function trimmedEndIndex(string3) {
        var index = string3.length;
        while (index-- && reWhitespace.test(string3.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string3) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string3)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string3) {
        return string3.match(reUnicode) || [];
      }
      function unicodeWords(string3) {
        return string3.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error4 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value2) {
          if (isObjectLike(value2) && !isArray(value2) && !(value2 instanceof LazyWrapper)) {
            if (value2 instanceof LodashWrapper) {
              return value2;
            }
            if (hasOwnProperty.call(value2, "__wrapped__")) {
              return wrapperClone(value2);
            }
          }
          return new LodashWrapper(value2);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object2() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object2.prototype = proto;
            var result2 = new object2();
            object2.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value2, chainAll) {
          this.__wrapped__ = value2;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value2) {
          this.__wrapped__ = value2;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array2, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value2 = array2[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value2);
                if (type == LAZY_MAP_FLAG) {
                  value2 = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value2;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value2) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value2 === undefined2 ? HASH_UNDEFINED : value2;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value2) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value2]);
          } else {
            data[index][1] = value2;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value2) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value2);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value2) {
          this.__data__.set(value2, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value2) {
          return this.__data__.has(value2);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value2) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value2]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value2);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value2, inherited) {
          var isArr = isArray(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value2.length, String2) : [], length = result2.length;
          for (var key in value2) {
            if ((inherited || hasOwnProperty.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array2) {
          var length = array2.length;
          return length ? array2[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array2, n) {
          return shuffleSelf(copyArray(array2), baseClamp(n, 0, array2.length));
        }
        function arrayShuffle(array2) {
          return shuffleSelf(copyArray(array2));
        }
        function assignMergeValue(object2, key, value2) {
          if (value2 !== undefined2 && !eq(object2[key], value2) || value2 === undefined2 && !(key in object2)) {
            baseAssignValue(object2, key, value2);
          }
        }
        function assignValue(object2, key, value2) {
          var objValue = object2[key];
          if (!(hasOwnProperty.call(object2, key) && eq(objValue, value2)) || value2 === undefined2 && !(key in object2)) {
            baseAssignValue(object2, key, value2);
          }
        }
        function assocIndexOf(array2, key) {
          var length = array2.length;
          while (length--) {
            if (eq(array2[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value2, key, collection2) {
            setter(accumulator, value2, iteratee2(value2), collection2);
          });
          return accumulator;
        }
        function baseAssign(object2, source) {
          return object2 && copyObject(source, keys(source), object2);
        }
        function baseAssignIn(object2, source) {
          return object2 && copyObject(source, keysIn(source), object2);
        }
        function baseAssignValue(object2, key, value2) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object2, key, {
              "configurable": true,
              "enumerable": true,
              "value": value2,
              "writable": true
            });
          } else {
            object2[key] = value2;
          }
        }
        function baseAt(object2, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object2 == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get2(object2, paths[index]);
          }
          return result2;
        }
        function baseClamp(number2, lower, upper) {
          if (number2 === number2) {
            if (upper !== undefined2) {
              number2 = number2 <= upper ? number2 : upper;
            }
            if (lower !== undefined2) {
              number2 = number2 >= lower ? number2 : lower;
            }
          }
          return number2;
        }
        function baseClone(value2, bitmask, customizer, key, object2, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object2 ? customizer(value2, key, object2, stack) : customizer(value2);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value2)) {
            return value2;
          }
          var isArr = isArray(value2);
          if (isArr) {
            result2 = initCloneArray(value2);
            if (!isDeep) {
              return copyArray(value2, result2);
            }
          } else {
            var tag = getTag2(value2), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value2)) {
              return cloneBuffer(value2, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object2) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value2);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value2, baseAssignIn(result2, value2)) : copySymbols(value2, baseAssign(result2, value2));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object2 ? value2 : {};
              }
              result2 = initCloneByTag(value2, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value2);
          if (stacked) {
            return stacked;
          }
          stack.set(value2, result2);
          if (isSet(value2)) {
            value2.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));
            });
          } else if (isMap(value2)) {
            value2.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value2);
          arrayEach(props || value2, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value2[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object2) {
            return baseConformsTo(object2, source, props);
          };
        }
        function baseConformsTo(object2, source, props) {
          var length = props.length;
          if (object2 == null) {
            return !length;
          }
          object2 = Object2(object2);
          while (length--) {
            var key = props[length], predicate = source[key], value2 = object2[key];
            if (value2 === undefined2 && !(key in object2) || !predicate(value2)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array2, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array2.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value2 = array2[index], computed = iteratee2 == null ? value2 : iteratee2(value2);
              value2 = comparator || value2 !== 0 ? value2 : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value2);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value2);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value2, index, collection2) {
            result2 = !!predicate(value2, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array2, iteratee2, comparator) {
          var index = -1, length = array2.length;
          while (++index < length) {
            var value2 = array2[index], current = iteratee2(value2);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol2(current) : comparator(current, computed))) {
              var computed = current, result2 = value2;
            }
          }
          return result2;
        }
        function baseFill(array2, value2, start, end) {
          var length = array2.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array2[start++] = value2;
          }
          return array2;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value2, index, collection2) {
            if (predicate(value2, index, collection2)) {
              result2.push(value2);
            }
          });
          return result2;
        }
        function baseFlatten(array2, depth, predicate, isStrict, result2) {
          var index = -1, length = array2.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value2 = array2[index];
            if (depth > 0 && predicate(value2)) {
              if (depth > 1) {
                baseFlatten(value2, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value2);
              }
            } else if (!isStrict) {
              result2[result2.length] = value2;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object2, iteratee2) {
          return object2 && baseFor(object2, iteratee2, keys);
        }
        function baseForOwnRight(object2, iteratee2) {
          return object2 && baseForRight(object2, iteratee2, keys);
        }
        function baseFunctions(object2, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object2[key]);
          });
        }
        function baseGet(object2, path) {
          path = castPath2(path, object2);
          var index = 0, length = path.length;
          while (object2 != null && index < length) {
            object2 = object2[toKey2(path[index++])];
          }
          return index && index == length ? object2 : undefined2;
        }
        function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object2);
          return isArray(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
        }
        function baseGetTag(value2) {
          if (value2 == null) {
            return value2 === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value2) ? getRawTag(value2) : objectToString(value2);
        }
        function baseGt(value2, other) {
          return value2 > other;
        }
        function baseHas(object2, key) {
          return object2 != null && hasOwnProperty.call(object2, key);
        }
        function baseHasIn(object2, key) {
          return object2 != null && key in Object2(object2);
        }
        function baseInRange(number2, start, end) {
          return number2 >= nativeMin(start, end) && number2 < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches2 = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array2 = arrays[othIndex];
            if (othIndex && iteratee2) {
              array2 = arrayMap(array2, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array2.length, maxLength);
            caches2[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined2;
          }
          array2 = arrays[0];
          var index = -1, seen = caches2[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value2 = array2[index], computed = iteratee2 ? iteratee2(value2) : value2;
              value2 = comparator || value2 !== 0 ? value2 : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches2[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value2);
              }
            }
          return result2;
        }
        function baseInverter(object2, setter, iteratee2, accumulator) {
          baseForOwn(object2, function(value2, key, object3) {
            setter(accumulator, iteratee2(value2), key, object3);
          });
          return accumulator;
        }
        function baseInvoke(object2, path, args) {
          path = castPath2(path, object2);
          object2 = parent(object2, path);
          var func = object2 == null ? object2 : object2[toKey2(last(path))];
          return func == null ? undefined2 : apply(func, object2, args);
        }
        function baseIsArguments(value2) {
          return isObjectLike(value2) && baseGetTag(value2) == argsTag;
        }
        function baseIsArrayBuffer(value2) {
          return isObjectLike(value2) && baseGetTag(value2) == arrayBufferTag;
        }
        function baseIsDate(value2) {
          return isObjectLike(value2) && baseGetTag(value2) == dateTag;
        }
        function baseIsEqual(value2, other, bitmask, customizer, stack) {
          if (value2 === other) {
            return true;
          }
          if (value2 == null || other == null || !isObjectLike(value2) && !isObjectLike(other)) {
            return value2 !== value2 && other !== other;
          }
          return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag2(object2), othTag = othIsArr ? arrayTag : getTag2(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object2)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value2) {
          return isObjectLike(value2) && getTag2(value2) == mapTag;
        }
        function baseIsMatch(object2, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object2 == null) {
            return !length;
          }
          object2 = Object2(object2);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object2[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object2)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object2, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value2) {
          if (!isObject(value2) || isMasked(value2)) {
            return false;
          }
          var pattern = isFunction(value2) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value2));
        }
        function baseIsRegExp(value2) {
          return isObjectLike(value2) && baseGetTag(value2) == regexpTag;
        }
        function baseIsSet(value2) {
          return isObjectLike(value2) && getTag2(value2) == setTag;
        }
        function baseIsTypedArray(value2) {
          return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
        }
        function baseIteratee(value2) {
          if (typeof value2 == "function") {
            return value2;
          }
          if (value2 == null) {
            return identity;
          }
          if (typeof value2 == "object") {
            return isArray(value2) ? baseMatchesProperty(value2[0], value2[1]) : baseMatches(value2);
          }
          return property(value2);
        }
        function baseKeys(object2) {
          if (!isPrototype(object2)) {
            return nativeKeys(object2);
          }
          var result2 = [];
          for (var key in Object2(object2)) {
            if (hasOwnProperty.call(object2, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object2) {
          if (!isObject(object2)) {
            return nativeKeysIn(object2);
          }
          var isProto = isPrototype(object2), result2 = [];
          for (var key in object2) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object2, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value2, other) {
          return value2 < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value2, key, collection2) {
            result2[++index] = iteratee2(value2, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object2) {
            return object2 === source || baseIsMatch(object2, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey2(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey2(path), srcValue);
          }
          return function(object2) {
            var objValue = get2(object2, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object2, source, srcIndex, customizer, stack) {
          if (object2 === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object2, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object2, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object2, key, newValue);
        }
        function baseNth(array2, n) {
          var length = array2.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array2[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value2) {
                  return baseGet(value2, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value2, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value2);
            });
            return { "criteria": criteria, "index": ++index, "value": value2 };
          });
          return baseSortBy(result2, function(object2, other) {
            return compareMultiple(object2, other, orders);
          });
        }
        function basePick(object2, paths) {
          return basePickBy(object2, paths, function(value2, path) {
            return hasIn(object2, path);
          });
        }
        function basePickBy(object2, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value2 = baseGet(object2, path);
            if (predicate(value2, path)) {
              baseSet(result2, castPath2(path, object2), value2);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object2) {
            return baseGet(object2, path);
          };
        }
        function basePullAll(array2, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array2;
          if (array2 === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array2, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value2 = values2[index], computed = iteratee2 ? iteratee2(value2) : value2;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array2) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array2, fromIndex, 1);
            }
          }
          return array2;
        }
        function basePullAt(array2, indexes) {
          var length = array2 ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array2, index, 1);
              } else {
                baseUnset(array2, index);
              }
            }
          }
          return array2;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string3, n) {
          var result2 = "";
          if (!string3 || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string3;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string3 += string3;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array2 = values(collection);
          return shuffleSelf(array2, baseClamp(n, 0, array2.length));
        }
        function baseSet(object2, path, value2, customizer) {
          if (!isObject(object2)) {
            return object2;
          }
          path = castPath2(path, object2);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object2;
          while (nested != null && ++index < length) {
            var key = toKey2(path[index]), newValue = value2;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object2;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object2;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string3) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string3),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array2, start, end) {
          var index = -1, length = array2.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array2[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value2, index, collection2) {
            result2 = predicate(value2, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array2, value2, retHighest) {
          var low = 0, high = array2 == null ? low : array2.length;
          if (typeof value2 == "number" && value2 === value2 && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array2[mid];
              if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value2 : computed < value2)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array2, value2, identity, retHighest);
        }
        function baseSortedIndexBy(array2, value2, iteratee2, retHighest) {
          var low = 0, high = array2 == null ? 0 : array2.length;
          if (high === 0) {
            return 0;
          }
          value2 = iteratee2(value2);
          var valIsNaN = value2 !== value2, valIsNull = value2 === null, valIsSymbol = isSymbol2(value2), valIsUndefined = value2 === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value2 : computed < value2;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array2, iteratee2) {
          var index = -1, length = array2.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value2 = array2[index], computed = iteratee2 ? iteratee2(value2) : value2;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value2 === 0 ? 0 : value2;
            }
          }
          return result2;
        }
        function baseToNumber(value2) {
          if (typeof value2 == "number") {
            return value2;
          }
          if (isSymbol2(value2)) {
            return NAN;
          }
          return +value2;
        }
        function baseToString(value2) {
          if (typeof value2 == "string") {
            return value2;
          }
          if (isArray(value2)) {
            return arrayMap(value2, baseToString) + "";
          }
          if (isSymbol2(value2)) {
            return symbolToString ? symbolToString.call(value2) : "";
          }
          var result2 = value2 + "";
          return result2 == "0" && 1 / value2 == -INFINITY2 ? "-0" : result2;
        }
        function baseUniq(array2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array2.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array2);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value2 = array2[index], computed = iteratee2 ? iteratee2(value2) : value2;
              value2 = comparator || value2 !== 0 ? value2 : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value2);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value2);
              }
            }
          return result2;
        }
        function baseUnset(object2, path) {
          path = castPath2(path, object2);
          object2 = parent(object2, path);
          return object2 == null || delete object2[toKey2(last(path))];
        }
        function baseUpdate(object2, path, updater, customizer) {
          return baseSet(object2, path, updater(baseGet(object2, path)), customizer);
        }
        function baseWhile(array2, predicate, isDrop, fromRight) {
          var length = array2.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array2[index], index, array2)) {
          }
          return isDrop ? baseSlice(array2, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array2, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value2, actions) {
          var result2 = value2;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array2 = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array2, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value2 = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value2);
          }
          return result2;
        }
        function castArrayLikeObject(value2) {
          return isArrayLikeObject(value2) ? value2 : [];
        }
        function castFunction(value2) {
          return typeof value2 == "function" ? value2 : identity;
        }
        function castPath2(value2, object2) {
          if (isArray(value2)) {
            return value2;
          }
          return isKey2(value2, object2) ? [value2] : stringToPath2(toString(value2));
        }
        var castRest = baseRest;
        function castSlice(array2, start, end) {
          var length = array2.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array2 : baseSlice(array2, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value2, other) {
          if (value2 !== other) {
            var valIsDefined = value2 !== undefined2, valIsNull = value2 === null, valIsReflexive = value2 === value2, valIsSymbol = isSymbol2(value2);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value2 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value2 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object2, other, orders) {
          var index = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object2.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array2) {
          var index = -1, length = source.length;
          array2 || (array2 = Array2(length));
          while (++index < length) {
            array2[index] = source[index];
          }
          return array2;
        }
        function copyObject(source, props, object2, customizer) {
          var isNew = !object2;
          object2 || (object2 = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object2, key, newValue);
            } else {
              assignValue(object2, key, newValue);
            }
          }
          return object2;
        }
        function copySymbols(source, object2) {
          return copyObject(source, getSymbols(source), object2);
        }
        function copySymbolsIn(source, object2) {
          return copyObject(source, getSymbolsIn(source), object2);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object2, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object2 = Object2(object2);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object2, source, index, customizer);
              }
            }
            return object2;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object2, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object2), props = keysFunc(object2), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object2;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string3) {
            string3 = toString(string3);
            var strSymbols = hasUnicode(string3) ? stringToArray(string3) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string3.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string3.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string3) {
            return arrayReduce(words(deburr(string3).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value2 = args[0];
              if (wrapper && args.length == 1 && isArray(value2)) {
                return wrapper.plant(value2).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value2;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object2, iteratee2) {
            return baseInverter(object2, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value2, other) {
            var result2;
            if (value2 === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value2 !== undefined2) {
              result2 = value2;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value2 == "string" || typeof other == "string") {
                value2 = baseToString(value2);
                other = baseToString(other);
              } else {
                value2 = baseToNumber(value2);
                other = baseToNumber(other);
              }
              result2 = operator(value2, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value2, other) {
            if (!(typeof value2 == "string" && typeof other == "string")) {
              value2 = toNumber(value2);
              other = toNumber(other);
            }
            return operator(value2, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number2, precision) {
            number2 = toNumber(number2);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number2)) {
              var pair = (toString(number2) + "e").split("e"), value2 = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value2) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number2);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY2) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object2) {
            var tag = getTag2(object2);
            if (tag == mapTag) {
              return mapToArray(object2);
            }
            if (tag == setTag) {
              return setToPairs(object2);
            }
            return baseToPairs(object2, keysFunc(object2));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object2) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object2, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object2, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value2) {
          return isPlainObject(value2) ? undefined2 : value2;
        }
        function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array2);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array2;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array2, other);
          stack.set(other, array2);
          while (++index < arrLength) {
            var arrValue = array2[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array2);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
                return false;
              }
              object2 = object2.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object2, +other);
            case errorTag:
              return object2.name == other.name && object2.message == other.message;
            case regexpTag:
            case stringTag:
              return object2 == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object2.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object2);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object2, other);
              var result2 = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object2);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object2) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object2);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object2;
          }
          var result2 = true;
          stack.set(object2, other);
          stack.set(other, object2);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object2[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object2.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object2);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object2) {
          return baseGetAllKeys(object2, keys, getSymbols);
        }
        function getAllKeysIn(object2) {
          return baseGetAllKeys(object2, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array2 = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array2.length : 0;
          while (length--) {
            var data = array2[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object2 = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object2.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object2) {
          var result2 = keys(object2), length = result2.length;
          while (length--) {
            var key = result2[length], value2 = object2[key];
            result2[length] = [key, value2, isStrictComparable(value2)];
          }
          return result2;
        }
        function getNative(object2, key) {
          var value2 = getValue(object2, key);
          return baseIsNative(value2) ? value2 : undefined2;
        }
        function getRawTag(value2) {
          var isOwn = hasOwnProperty.call(value2, symToStringTag), tag = value2[symToStringTag];
          try {
            value2[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value2);
          if (unmasked) {
            if (isOwn) {
              value2[symToStringTag] = tag;
            } else {
              delete value2[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
          if (object2 == null) {
            return [];
          }
          object2 = Object2(object2);
          return arrayFilter(nativeGetSymbols(object2), function(symbol) {
            return propertyIsEnumerable.call(object2, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
          var result2 = [];
          while (object2) {
            arrayPush(result2, getSymbols(object2));
            object2 = getPrototype(object2);
          }
          return result2;
        };
        var getTag2 = baseGetTag;
        if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
          getTag2 = function(value2) {
            var result2 = baseGetTag(value2), Ctor = result2 == objectTag ? value2.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object2, path, hasFunc) {
          path = castPath2(path, object2);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey2(path[index]);
            if (!(result2 = object2 != null && hasFunc(object2, key))) {
              break;
            }
            object2 = object2[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object2 == null ? 0 : object2.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object2) || isArguments(object2));
        }
        function initCloneArray(array2) {
          var length = array2.length, result2 = new array2.constructor(length);
          if (length && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
            result2.index = array2.index;
            result2.input = array2.input;
          }
          return result2;
        }
        function initCloneObject(object2) {
          return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
        }
        function initCloneByTag(object2, tag, isDeep) {
          var Ctor = object2.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object2);
            case boolTag:
            case dateTag:
              return new Ctor(+object2);
            case dataViewTag:
              return cloneDataView(object2, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object2, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object2);
            case regexpTag:
              return cloneRegExp(object2);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object2);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value2) {
          return isArray(value2) || isArguments(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
        }
        function isIndex(value2, length) {
          var type = typeof value2;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
        }
        function isIterateeCall(value2, index, object2) {
          if (!isObject(object2)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type == "string" && index in object2) {
            return eq(object2[index], value2);
          }
          return false;
        }
        function isKey2(value2, object2) {
          if (isArray(value2)) {
            return false;
          }
          var type = typeof value2;
          if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol2(value2)) {
            return true;
          }
          return reIsPlainProp2.test(value2) || !reIsDeepProp2.test(value2) || object2 != null && value2 in Object2(object2);
        }
        function isKeyable(value2) {
          var type = typeof value2;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value2) {
          var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value2 === proto;
        }
        function isStrictComparable(value2) {
          return value2 === value2 && !isObject(value2);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object2) {
            if (object2 == null) {
              return false;
            }
            return object2[key] === srcValue && (srcValue !== undefined2 || key in Object2(object2));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value2 = source[3];
          if (value2) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value2, source[4]) : value2;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value2 = source[5];
          if (value2) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value2, source[6]) : value2;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value2 = source[7];
          if (value2) {
            data[7] = value2;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object2) {
          var result2 = [];
          if (object2 != null) {
            for (var key in Object2(object2)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value2) {
          return nativeObjectToString.call(value2);
        }
        function overRest(func, start, transform3) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array2 = Array2(length);
            while (++index < length) {
              array2[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform3(array2);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object2, path) {
          return path.length < 2 ? object2 : baseGet(object2, baseSlice(path, 0, -1));
        }
        function reorder(array2, indexes) {
          var arrLength = array2.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array2);
          while (length--) {
            var index = indexes[length];
            array2[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array2;
        }
        function safeGet(object2, key) {
          if (key === "constructor" && typeof object2[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object2[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array2, size2) {
          var index = -1, length = array2.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value2 = array2[rand];
            array2[rand] = array2[index];
            array2[index] = value2;
          }
          array2.length = size2;
          return array2;
        }
        var stringToPath2 = memoizeCapped(function(string3) {
          var result2 = [];
          if (string3.charCodeAt(0) === 46) {
            result2.push("");
          }
          string3.replace(rePropName2, function(match, number2, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar2, "$1") : number2 || match);
          });
          return result2;
        });
        function toKey2(value2) {
          if (typeof value2 == "string" || isSymbol2(value2)) {
            return value2;
          }
          var result2 = value2 + "";
          return result2 == "0" && 1 / value2 == -INFINITY2 ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value2 = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value2)) {
              details.push(value2);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array2, size2, guard) {
          if (guard ? isIterateeCall(array2, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array2 == null ? 0 : array2.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array2, index, index += size2);
          }
          return result2;
        }
        function compact(array2) {
          var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value2 = array2[index];
            if (value2) {
              result2[resIndex++] = value2;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array2 = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array2, values2) {
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array2, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array2, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array2, n, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array2, n < 0 ? 0 : n, length);
        }
        function dropRight(array2, n, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array2, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
        }
        function fill(array2, value2, start, end) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array2, value2, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array2, value2, start, end);
        }
        function findIndex(array2, predicate, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array2, predicate, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index, true);
        }
        function flatten(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseFlatten(array2, 1) : [];
        }
        function flattenDeep(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseFlatten(array2, INFINITY2) : [];
        }
        function flattenDepth(array2, depth) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array2, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array2) {
          return array2 && array2.length ? array2[0] : undefined2;
        }
        function indexOf(array2, value2, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array2, value2, index);
        }
        function initial(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSlice(array2, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array2, separator) {
          return array2 == null ? "" : nativeJoin.call(array2, separator);
        }
        function last(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? array2[length - 1] : undefined2;
        }
        function lastIndexOf(array2, value2, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value2 === value2 ? strictLastIndexOf(array2, value2, index) : baseFindIndex(array2, baseIsNaN, index, true);
        }
        function nth(array2, n) {
          return array2 && array2.length ? baseNth(array2, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array2, values2) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2) : array2;
        }
        function pullAllBy(array2, values2, iteratee2) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, getIteratee(iteratee2, 2)) : array2;
        }
        function pullAllWith(array2, values2, comparator) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, undefined2, comparator) : array2;
        }
        var pullAt = flatRest(function(array2, indexes) {
          var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
          basePullAt(array2, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array2, predicate) {
          var result2 = [];
          if (!(array2 && array2.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array2.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value2 = array2[index];
            if (predicate(value2, index, array2)) {
              result2.push(value2);
              indexes.push(index);
            }
          }
          basePullAt(array2, indexes);
          return result2;
        }
        function reverse(array2) {
          return array2 == null ? array2 : nativeReverse.call(array2);
        }
        function slice(array2, start, end) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array2, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array2, start, end);
        }
        function sortedIndex(array2, value2) {
          return baseSortedIndex(array2, value2);
        }
        function sortedIndexBy(array2, value2, iteratee2) {
          return baseSortedIndexBy(array2, value2, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array2, value2) {
          var length = array2 == null ? 0 : array2.length;
          if (length) {
            var index = baseSortedIndex(array2, value2);
            if (index < length && eq(array2[index], value2)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array2, value2) {
          return baseSortedIndex(array2, value2, true);
        }
        function sortedLastIndexBy(array2, value2, iteratee2) {
          return baseSortedIndexBy(array2, value2, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array2, value2) {
          var length = array2 == null ? 0 : array2.length;
          if (length) {
            var index = baseSortedIndex(array2, value2, true) - 1;
            if (eq(array2[index], value2)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array2) {
          return array2 && array2.length ? baseSortedUniq(array2) : [];
        }
        function sortedUniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSlice(array2, 1, length) : [];
        }
        function take(array2, n, guard) {
          if (!(array2 && array2.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array2, 0, n < 0 ? 0 : n);
        }
        function takeRight(array2, n, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array2, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array2) {
          return array2 && array2.length ? baseUniq(array2) : [];
        }
        function uniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array2, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array2 && array2.length ? baseUniq(array2, undefined2, comparator) : [];
        }
        function unzip(array2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var length = 0;
          array2 = arrayFilter(array2, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array2, baseProperty(index));
          });
        }
        function unzipWith(array2, iteratee2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var result2 = unzip(array2);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array2, values2) {
          return isArrayLikeObject(array2) ? baseDifference(array2, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip2 = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value2) {
          var result2 = lodash(value2);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value2, interceptor) {
          interceptor(value2);
          return value2;
        }
        function thru(value2, interceptor) {
          return interceptor(value2);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value2 = this.__wrapped__, interceptor = function(object2) {
            return baseAt(object2, paths);
          };
          if (length > 1 || this.__actions__.length || !(value2 instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value2 = value2.slice(start, +start + (length ? 1 : 0));
          value2.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value2, this.__chain__).thru(function(array2) {
            if (length && !array2.length) {
              array2.push(undefined2);
            }
            return array2;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value2 = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value2 };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value2) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value2;
          return result2;
        }
        function wrapperReverse() {
          var value2 = this.__wrapped__;
          if (value2 instanceof LazyWrapper) {
            var wrapped = value2;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value2, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY2);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value2, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value2);
          } else {
            baseAssignValue(result2, key, [value2]);
          }
        });
        function includes(collection, value2, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value2, fromIndex) > -1 : !!length && baseIndexOf(collection, value2, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value2) {
            result2[++index] = isFunc ? apply(path, value2, args) : baseInvoke(value2, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value2, key) {
          baseAssignValue(result2, key, value2);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value2, key) {
          result2[key ? 0 : 1].push(value2);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag2(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object2, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object2, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array2 = args[start], otherArgs = castSlice(args, 0, start);
            if (array2) {
              arrayPush(otherArgs, array2);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value2, wrapper) {
          return partial(castFunction(wrapper), value2);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value2 = arguments[0];
          return isArray(value2) ? value2 : [value2];
        }
        function clone(value2) {
          return baseClone(value2, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value2, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value2, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value2) {
          return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value2, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object2, source) {
          return source == null || baseConformsTo(object2, source, keys(source));
        }
        function eq(value2, other) {
          return value2 === other || value2 !== value2 && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value2, other) {
          return value2 >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value2) {
          return isObjectLike(value2) && hasOwnProperty.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value2) {
          return value2 != null && isLength(value2.length) && !isFunction(value2);
        }
        function isArrayLikeObject(value2) {
          return isObjectLike(value2) && isArrayLike(value2);
        }
        function isBoolean(value2) {
          return value2 === true || value2 === false || isObjectLike(value2) && baseGetTag(value2) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value2) {
          return isObjectLike(value2) && value2.nodeType === 1 && !isPlainObject(value2);
        }
        function isEmpty(value2) {
          if (value2 == null) {
            return true;
          }
          if (isArrayLike(value2) && (isArray(value2) || typeof value2 == "string" || typeof value2.splice == "function" || isBuffer(value2) || isTypedArray(value2) || isArguments(value2))) {
            return !value2.length;
          }
          var tag = getTag2(value2);
          if (tag == mapTag || tag == setTag) {
            return !value2.size;
          }
          if (isPrototype(value2)) {
            return !baseKeys(value2).length;
          }
          for (var key in value2) {
            if (hasOwnProperty.call(value2, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value2, other) {
          return baseIsEqual(value2, other);
        }
        function isEqualWith(value2, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value2, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value2, other, undefined2, customizer) : !!result2;
        }
        function isError(value2) {
          if (!isObjectLike(value2)) {
            return false;
          }
          var tag = baseGetTag(value2);
          return tag == errorTag || tag == domExcTag || typeof value2.message == "string" && typeof value2.name == "string" && !isPlainObject(value2);
        }
        function isFinite(value2) {
          return typeof value2 == "number" && nativeIsFinite(value2);
        }
        function isFunction(value2) {
          if (!isObject(value2)) {
            return false;
          }
          var tag = baseGetTag(value2);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value2) {
          return typeof value2 == "number" && value2 == toInteger(value2);
        }
        function isLength(value2) {
          return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
        }
        function isObject(value2) {
          var type = typeof value2;
          return value2 != null && (type == "object" || type == "function");
        }
        function isObjectLike(value2) {
          return value2 != null && typeof value2 == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object2, source) {
          return object2 === source || baseIsMatch(object2, source, getMatchData(source));
        }
        function isMatchWith(object2, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object2, source, getMatchData(source), customizer);
        }
        function isNaN2(value2) {
          return isNumber(value2) && value2 != +value2;
        }
        function isNative(value2) {
          if (isMaskable(value2)) {
            throw new Error4(CORE_ERROR_TEXT);
          }
          return baseIsNative(value2);
        }
        function isNull(value2) {
          return value2 === null;
        }
        function isNil(value2) {
          return value2 == null;
        }
        function isNumber(value2) {
          return typeof value2 == "number" || isObjectLike(value2) && baseGetTag(value2) == numberTag;
        }
        function isPlainObject(value2) {
          if (!isObjectLike(value2) || baseGetTag(value2) != objectTag) {
            return false;
          }
          var proto = getPrototype(value2);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value2) {
          return isInteger(value2) && value2 >= -MAX_SAFE_INTEGER && value2 <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value2) {
          return typeof value2 == "string" || !isArray(value2) && isObjectLike(value2) && baseGetTag(value2) == stringTag;
        }
        function isSymbol2(value2) {
          return typeof value2 == "symbol" || isObjectLike(value2) && baseGetTag(value2) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value2) {
          return value2 === undefined2;
        }
        function isWeakMap(value2) {
          return isObjectLike(value2) && getTag2(value2) == weakMapTag;
        }
        function isWeakSet(value2) {
          return isObjectLike(value2) && baseGetTag(value2) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value2, other) {
          return value2 <= other;
        });
        function toArray(value2) {
          if (!value2) {
            return [];
          }
          if (isArrayLike(value2)) {
            return isString(value2) ? stringToArray(value2) : copyArray(value2);
          }
          if (symIterator && value2[symIterator]) {
            return iteratorToArray(value2[symIterator]());
          }
          var tag = getTag2(value2), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value2);
        }
        function toFinite(value2) {
          if (!value2) {
            return value2 === 0 ? value2 : 0;
          }
          value2 = toNumber(value2);
          if (value2 === INFINITY2 || value2 === -INFINITY2) {
            var sign = value2 < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value2 === value2 ? value2 : 0;
        }
        function toInteger(value2) {
          var result2 = toFinite(value2), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value2) {
          return value2 ? baseClamp(toInteger(value2), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value2) {
          if (typeof value2 == "number") {
            return value2;
          }
          if (isSymbol2(value2)) {
            return NAN;
          }
          if (isObject(value2)) {
            var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
            value2 = isObject(other) ? other + "" : other;
          }
          if (typeof value2 != "string") {
            return value2 === 0 ? value2 : +value2;
          }
          value2 = baseTrim(value2);
          var isBinary = reIsBinary.test(value2);
          return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
        }
        function toPlainObject(value2) {
          return copyObject(value2, keysIn(value2));
        }
        function toSafeInteger(value2) {
          return value2 ? baseClamp(toInteger(value2), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value2 === 0 ? value2 : 0;
        }
        function toString(value2) {
          return value2 == null ? "" : baseToString(value2);
        }
        var assign = createAssigner(function(object2, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object2);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object2, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object2, source) {
          copyObject(source, keysIn(source), object2);
        });
        var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object2, customizer);
        });
        var assignWith = createAssigner(function(object2, source, srcIndex, customizer) {
          copyObject(source, keys(source), object2, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object2, sources) {
          object2 = Object2(object2);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value2 = object2[key];
              if (value2 === undefined2 || eq(value2, objectProto[key]) && !hasOwnProperty.call(object2, key)) {
                object2[key] = source[key];
              }
            }
          }
          return object2;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object2, iteratee2) {
          return object2 == null ? object2 : baseFor(object2, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object2, iteratee2) {
          return object2 == null ? object2 : baseForRight(object2, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object2, iteratee2) {
          return object2 && baseForOwn(object2, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object2, iteratee2) {
          return object2 && baseForOwnRight(object2, getIteratee(iteratee2, 3));
        }
        function functions(object2) {
          return object2 == null ? [] : baseFunctions(object2, keys(object2));
        }
        function functionsIn(object2) {
          return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
        }
        function get2(object2, path, defaultValue) {
          var result2 = object2 == null ? undefined2 : baseGet(object2, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object2, path) {
          return object2 != null && hasPath(object2, path, baseHas);
        }
        function hasIn(object2, path) {
          return object2 != null && hasPath(object2, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value2, key) {
          if (value2 != null && typeof value2.toString != "function") {
            value2 = nativeObjectToString.call(value2);
          }
          result2[value2] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value2, key) {
          if (value2 != null && typeof value2.toString != "function") {
            value2 = nativeObjectToString.call(value2);
          }
          if (hasOwnProperty.call(result2, value2)) {
            result2[value2].push(key);
          } else {
            result2[value2] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
        }
        function keysIn(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
        }
        function mapKeys(object2, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object2, function(value2, key, object3) {
            baseAssignValue(result2, iteratee2(value2, key, object3), value2);
          });
          return result2;
        }
        function mapValues(object2, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object2, function(value2, key, object3) {
            baseAssignValue(result2, key, iteratee2(value2, key, object3));
          });
          return result2;
        }
        var merge = createAssigner(function(object2, source, srcIndex) {
          baseMerge(object2, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object2, source, srcIndex, customizer) {
          baseMerge(object2, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object2, paths) {
          var result2 = {};
          if (object2 == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath2(path, object2);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object2, getAllKeysIn(object2), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object2, predicate) {
          return pickBy(object2, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object2, paths) {
          return object2 == null ? {} : basePick(object2, paths);
        });
        function pickBy(object2, predicate) {
          if (object2 == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object2), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object2, props, function(value2, path) {
            return predicate(value2, path[0]);
          });
        }
        function result(object2, path, defaultValue) {
          path = castPath2(path, object2);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object2 = undefined2;
          }
          while (++index < length) {
            var value2 = object2 == null ? undefined2 : object2[toKey2(path[index])];
            if (value2 === undefined2) {
              index = length;
              value2 = defaultValue;
            }
            object2 = isFunction(value2) ? value2.call(object2) : value2;
          }
          return object2;
        }
        function set(object2, path, value2) {
          return object2 == null ? object2 : baseSet(object2, path, value2);
        }
        function setWith(object2, path, value2, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object2 == null ? object2 : baseSet(object2, path, value2, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform2(object2, iteratee2, accumulator) {
          var isArr = isArray(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray(object2);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object2 && object2.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object2)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object2)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object2, function(value2, index, object3) {
            return iteratee2(accumulator, value2, index, object3);
          });
          return accumulator;
        }
        function unset(object2, path) {
          return object2 == null ? true : baseUnset(object2, path);
        }
        function update(object2, path, updater) {
          return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater));
        }
        function updateWith(object2, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater), customizer);
        }
        function values(object2) {
          return object2 == null ? [] : baseValues(object2, keys(object2));
        }
        function valuesIn(object2) {
          return object2 == null ? [] : baseValues(object2, keysIn(object2));
        }
        function clamp(number2, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number2), lower, upper);
        }
        function inRange(number2, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number2 = toNumber(number2);
          return baseInRange(number2, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word2, index) {
          word2 = word2.toLowerCase();
          return result2 + (index ? capitalize(word2) : word2);
        });
        function capitalize(string3) {
          return upperFirst(toString(string3).toLowerCase());
        }
        function deburr(string3) {
          string3 = toString(string3);
          return string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string3, target, position) {
          string3 = toString(string3);
          target = baseToString(target);
          var length = string3.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string3.slice(position, end) == target;
        }
        function escape(string3) {
          string3 = toString(string3);
          return string3 && reHasUnescapedHtml.test(string3) ? string3.replace(reUnescapedHtml, escapeHtmlChar) : string3;
        }
        function escapeRegExp(string3) {
          string3 = toString(string3);
          return string3 && reHasRegExpChar.test(string3) ? string3.replace(reRegExpChar, "\\$&") : string3;
        }
        var kebabCase = createCompounder(function(result2, word2, index) {
          return result2 + (index ? "-" : "") + word2.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word2, index) {
          return result2 + (index ? " " : "") + word2.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string3, length, chars) {
          string3 = toString(string3);
          length = toInteger(length);
          var strLength = length ? stringSize(string3) : 0;
          if (!length || strLength >= length) {
            return string3;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string3 + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string3, length, chars) {
          string3 = toString(string3);
          length = toInteger(length);
          var strLength = length ? stringSize(string3) : 0;
          return length && strLength < length ? string3 + createPadding(length - strLength, chars) : string3;
        }
        function padStart(string3, length, chars) {
          string3 = toString(string3);
          length = toInteger(length);
          var strLength = length ? stringSize(string3) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string3 : string3;
        }
        function parseInt2(string3, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string3).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string3, n, guard) {
          if (guard ? isIterateeCall(string3, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string3), n);
        }
        function replace() {
          var args = arguments, string3 = toString(args[0]);
          return args.length < 3 ? string3 : string3.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word2, index) {
          return result2 + (index ? "_" : "") + word2.toLowerCase();
        });
        function split(string3, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string3, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string3 = toString(string3);
          if (string3 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string3)) {
              return castSlice(stringToArray(string3), 0, limit);
            }
          }
          return string3.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word2, index) {
          return result2 + (index ? " " : "") + upperFirst(word2);
        });
        function startsWith(string3, target, position) {
          string3 = toString(string3);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string3.length);
          target = baseToString(target);
          return string3.slice(position, position + target.length) == target;
        }
        function template(string3, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string3, options, guard)) {
            options = undefined2;
          }
          string3 = toString(string3);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string3.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string3.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error4(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value2) {
          return toString(value2).toLowerCase();
        }
        function toUpper(value2) {
          return toString(value2).toUpperCase();
        }
        function trim(string3, chars, guard) {
          string3 = toString(string3);
          if (string3 && (guard || chars === undefined2)) {
            return baseTrim(string3);
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string3, chars, guard) {
          string3 = toString(string3);
          if (string3 && (guard || chars === undefined2)) {
            return string3.slice(0, trimmedEndIndex(string3) + 1);
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string3, chars, guard) {
          string3 = toString(string3);
          if (string3 && (guard || chars === undefined2)) {
            return string3.replace(reTrimStart, "");
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string3, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string3 = toString(string3);
          var strLength = string3.length;
          if (hasUnicode(string3)) {
            var strSymbols = stringToArray(string3);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string3;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string3.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string3.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string3.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string3) {
          string3 = toString(string3);
          return string3 && reHasEscapedHtml.test(string3) ? string3.replace(reEscapedHtml, unescapeHtmlChar) : string3;
        }
        var upperCase = createCompounder(function(result2, word2, index) {
          return result2 + (index ? " " : "") + word2.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string3, pattern, guard) {
          string3 = toString(string3);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string3) ? unicodeWords(string3) : asciiWords(string3);
          }
          return string3.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error4(e);
          }
        });
        var bindAll = flatRest(function(object2, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey2(key);
            baseAssignValue(object2, key, bind(object2[key], object2));
          });
          return object2;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value2) {
          return function() {
            return value2;
          };
        }
        function defaultTo(value2, defaultValue) {
          return value2 == null || value2 !== value2 ? defaultValue : value2;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value2) {
          return value2;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object2) {
            return baseInvoke(object2, path, args);
          };
        });
        var methodOf = baseRest(function(object2, args) {
          return function(path) {
            return baseInvoke(object2, path, args);
          };
        });
        function mixin(object2, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object2;
            object2 = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object2);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object2[methodName] = func;
            if (isFunc) {
              object2.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object2(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object2 });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object2, arrayPush([this.value()], arguments));
              };
            }
          });
          return object2;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey2(path) ? baseProperty(toKey2(path)) : basePropertyDeep(path);
        }
        function propertyOf(object2) {
          return function(path) {
            return object2 == null ? undefined2 : baseGet(object2, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value2) {
          if (isArray(value2)) {
            return arrayMap(value2, toKey2);
          }
          return isSymbol2(value2) ? [value2] : copyArray(stringToPath2(toString(value2)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity, baseGt) : undefined2;
        }
        function maxBy(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array2) {
          return baseMean(array2, identity);
        }
        function meanBy(array2, iteratee2) {
          return baseMean(array2, getIteratee(iteratee2, 2));
        }
        function min(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity, baseLt) : undefined2;
        }
        function minBy(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array2) {
          return array2 && array2.length ? baseSum(array2, identity) : 0;
        }
        function sumBy(array2, iteratee2) {
          return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform2;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip2;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get2;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol2;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION2;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value2) {
            return baseInvoke(value2, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value2 = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value2 instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value2);
            var interceptor = function(value3) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value3], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value2 = onlyLazy ? value2 : new LazyWrapper(this);
              var result2 = func.apply(value2, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value2 = this.value();
              return func.apply(isArray(value2) ? value2 : [], args);
            }
            return this[chainName](function(value3) {
              return func.apply(isArray(value3) ? value3 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// node_modules/.pnpm/promise-limit@2.7.0/node_modules/promise-limit/index.js
var require_promise_limit = __commonJS({
  "node_modules/.pnpm/promise-limit@2.7.0/node_modules/promise-limit/index.js"(exports, module) {
    function limiter(count) {
      var outstanding = 0;
      var jobs = [];
      function remove() {
        outstanding--;
        if (outstanding < count) {
          dequeue();
        }
      }
      function dequeue() {
        var job = jobs.shift();
        semaphore.queue = jobs.length;
        if (job) {
          run(job.fn).then(job.resolve).catch(job.reject);
        }
      }
      function queue(fn) {
        return new Promise(function(resolve, reject) {
          jobs.push({ fn, resolve, reject });
          semaphore.queue = jobs.length;
        });
      }
      function run(fn) {
        outstanding++;
        try {
          return Promise.resolve(fn()).then(function(result) {
            remove();
            return result;
          }, function(error) {
            remove();
            throw error;
          });
        } catch (err) {
          remove();
          return Promise.reject(err);
        }
      }
      var semaphore = function(fn) {
        if (outstanding >= count) {
          return queue(fn);
        } else {
          return run(fn);
        }
      };
      return semaphore;
    }
    function map(items, mapper) {
      var failed = false;
      var limit = this;
      return Promise.all(items.map(function() {
        var args = arguments;
        return limit(function() {
          if (!failed) {
            return mapper.apply(void 0, args).catch(function(e) {
              failed = true;
              throw e;
            });
          }
        });
      }));
    }
    function addExtras(fn) {
      fn.queue = 0;
      fn.map = map;
      return fn;
    }
    module.exports = function(count) {
      if (count) {
        return addExtras(limiter(count));
      } else {
        return addExtras(function(fn) {
          return fn();
        });
      }
    };
  }
});

// lib/const.ts
var EidosDataEventChannelName = "eidos-data-event";

// lib/fields/const.ts
var NUMBER_BASED_COMPARE_OPERATORS = [
  "=" /* Equal */,
  "!=" /* NotEqual */,
  ">" /* GreaterThan */,
  ">=" /* GreaterThanOrEqual */,
  "<" /* LessThan */,
  "<=" /* LessThanOrEqual */,
  "IsEmpty" /* IsEmpty */,
  "IsNotEmpty" /* IsNotEmpty */
];
var TEXT_BASED_COMPARE_OPERATORS = [
  "=" /* Equal */,
  "!=" /* NotEqual */,
  "Contains" /* Contains */,
  "NotContains" /* NotContains */,
  "StartsWith" /* StartsWith */,
  "EndsWith" /* EndsWith */,
  "IsEmpty" /* IsEmpty */,
  "IsNotEmpty" /* IsNotEmpty */
];

// lib/env.ts
var logger = console;
var isDevMode = Boolean(import.meta.env?.DEV);
var isSelfHosted = import.meta.env?.MODE === "self-host";
var isInkServiceMode = import.meta.env?.MODE === "ink";
var isDesktopMode = import.meta.env?.MODE === "desktop";
var isStagingMode = import.meta.env?.MODE === "staging";

// lib/sqlite/const.ts
var TreeTableName = `eidos__tree`;
var ColumnTableName = `eidos__columns`;
var FileTableName = `eidos__files`;
var DocTableName = `eidos__docs`;
var ActionTableName = `eidos__actions`;
var ScriptTableName = `eidos__scripts`;
var ViewTableName = `eidos__views`;
var EmbeddingTableName = `eidos__embeddings`;
var ReferenceTableName = `eidos__references`;
var ChatTableName = `eidos__chats`;
var MessageTableName = `eidos__messages`;

// lib/sqlite/helper.ts
var import_pgsql_ast_parser = __toESM(require_pgsql_ast_parser(), 1);
function isReadOnlySql(sql) {
  const readonlySqls = ["SELECT", "PRAGMA", "EXPLAIN", "ANALYZE"];
  return readonlySqls.some((item) => sql.trim().toUpperCase().startsWith(item));
}
function buildSql(strings, ...values) {
  const bind = [];
  let sql = strings[0];
  if (strings.filter((item) => item.trim().length > 0).length === 0) {
    return {
      sql: values.join(" "),
      bind: []
    };
  }
  for (let i = 0; i < values.length; i++) {
    const value2 = values[i];
    if (typeof value2 === "symbol") {
      sql += value2.description + strings[i + 1];
    } else if (Array.isArray(value2)) {
      sql += `(${Array.from({ length: value2.length }).fill("?").join(",")})`;
      bind.push(...value2);
    } else {
      sql += "?" + strings[i + 1];
      bind.push(value2);
    }
  }
  return {
    sql,
    bind
  };
}

// lib/sqlite/sql-formula-parser.ts
var import_pgsql_ast_parser2 = __toESM(require_pgsql_ast_parser(), 1);

// node_modules/.pnpm/uuidv7@1.0.1/node_modules/uuidv7/dist/index.js
var DIGITS = "0123456789abcdef";
var UUID = class _UUID {
  /** @param bytes - The 16-byte byte array representation. */
  constructor(bytes) {
    this.bytes = bytes;
  }
  /**
   * Creates an object from the internal representation, a 16-byte byte array
   * containing the binary UUID representation in the big-endian byte order.
   *
   * This method does NOT shallow-copy the argument, and thus the created object
   * holds the reference to the underlying buffer.
   *
   * @throws TypeError if the length of the argument is not 16.
   */
  static ofInner(bytes) {
    if (bytes.length !== 16) {
      throw new TypeError("not 128-bit length");
    } else {
      return new _UUID(bytes);
    }
  }
  /**
   * Builds a byte array from UUIDv7 field values.
   *
   * @param unixTsMs - A 48-bit `unix_ts_ms` field value.
   * @param randA - A 12-bit `rand_a` field value.
   * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.
   * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.
   * @throws RangeError if any field value is out of the specified range.
   */
  static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {
    if (!Number.isInteger(unixTsMs) || !Number.isInteger(randA) || !Number.isInteger(randBHi) || !Number.isInteger(randBLo) || unixTsMs < 0 || randA < 0 || randBHi < 0 || randBLo < 0 || unixTsMs > 281474976710655 || randA > 4095 || randBHi > 1073741823 || randBLo > 4294967295) {
      throw new RangeError("invalid field value");
    }
    const bytes = new Uint8Array(16);
    bytes[0] = unixTsMs / 2 ** 40;
    bytes[1] = unixTsMs / 2 ** 32;
    bytes[2] = unixTsMs / 2 ** 24;
    bytes[3] = unixTsMs / 2 ** 16;
    bytes[4] = unixTsMs / 2 ** 8;
    bytes[5] = unixTsMs;
    bytes[6] = 112 | randA >>> 8;
    bytes[7] = randA;
    bytes[8] = 128 | randBHi >>> 24;
    bytes[9] = randBHi >>> 16;
    bytes[10] = randBHi >>> 8;
    bytes[11] = randBHi;
    bytes[12] = randBLo >>> 24;
    bytes[13] = randBLo >>> 16;
    bytes[14] = randBLo >>> 8;
    bytes[15] = randBLo;
    return new _UUID(bytes);
  }
  /**
   * Builds a byte array from a string representation.
   *
   * This method accepts the following formats:
   *
   * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`
   * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`
   * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`
   * - RFC 9562 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`
   *
   * Leading and trailing whitespaces represents an error.
   *
   * @throws SyntaxError if the argument could not parse as a valid UUID string.
   */
  static parse(uuid) {
    var _a, _b, _c, _d;
    let hex = void 0;
    switch (uuid.length) {
      case 32:
        hex = (_a = /^[0-9a-f]{32}$/i.exec(uuid)) === null || _a === void 0 ? void 0 : _a[0];
        break;
      case 36:
        hex = (_b = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid)) === null || _b === void 0 ? void 0 : _b.slice(1, 6).join("");
        break;
      case 38:
        hex = (_c = /^\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\}$/i.exec(uuid)) === null || _c === void 0 ? void 0 : _c.slice(1, 6).join("");
        break;
      case 45:
        hex = (_d = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid)) === null || _d === void 0 ? void 0 : _d.slice(1, 6).join("");
        break;
      default:
        break;
    }
    if (hex) {
      const inner = new Uint8Array(16);
      for (let i = 0; i < 16; i += 4) {
        const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);
        inner[i + 0] = n >>> 24;
        inner[i + 1] = n >>> 16;
        inner[i + 2] = n >>> 8;
        inner[i + 3] = n;
      }
      return new _UUID(inner);
    } else {
      throw new SyntaxError("could not parse UUID string");
    }
  }
  /**
   * @returns The 8-4-4-4-12 canonical hexadecimal string representation
   * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).
   */
  toString() {
    let text = "";
    for (let i = 0; i < this.bytes.length; i++) {
      text += DIGITS.charAt(this.bytes[i] >>> 4);
      text += DIGITS.charAt(this.bytes[i] & 15);
      if (i === 3 || i === 5 || i === 7 || i === 9) {
        text += "-";
      }
    }
    return text;
  }
  /**
   * @returns The 32-digit hexadecimal representation without hyphens
   * (`0189dcd553117d408db09496a2eef37b`).
   */
  toHex() {
    let text = "";
    for (let i = 0; i < this.bytes.length; i++) {
      text += DIGITS.charAt(this.bytes[i] >>> 4);
      text += DIGITS.charAt(this.bytes[i] & 15);
    }
    return text;
  }
  /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */
  toJSON() {
    return this.toString();
  }
  /**
   * Reports the variant field value of the UUID or, if appropriate, "NIL" or
   * "MAX".
   *
   * For convenience, this method reports "NIL" or "MAX" if `this` represents
   * the Nil or Max UUID, although the Nil and Max UUIDs are technically
   * subsumed under the variants `0b0` and `0b111`, respectively.
   */
  getVariant() {
    const n = this.bytes[8] >>> 4;
    if (n < 0) {
      throw new Error("unreachable");
    } else if (n <= 7) {
      return this.bytes.every((e) => e === 0) ? "NIL" : "VAR_0";
    } else if (n <= 11) {
      return "VAR_10";
    } else if (n <= 13) {
      return "VAR_110";
    } else if (n <= 15) {
      return this.bytes.every((e) => e === 255) ? "MAX" : "VAR_RESERVED";
    } else {
      throw new Error("unreachable");
    }
  }
  /**
   * Returns the version field value of the UUID or `undefined` if the UUID does
   * not have the variant field value of `0b10`.
   */
  getVersion() {
    return this.getVariant() === "VAR_10" ? this.bytes[6] >>> 4 : void 0;
  }
  /** Creates an object from `this`. */
  clone() {
    return new _UUID(this.bytes.slice(0));
  }
  /** Returns true if `this` is equivalent to `other`. */
  equals(other) {
    return this.compareTo(other) === 0;
  }
  /**
   * Returns a negative integer, zero, or positive integer if `this` is less
   * than, equal to, or greater than `other`, respectively.
   */
  compareTo(other) {
    for (let i = 0; i < 16; i++) {
      const diff = this.bytes[i] - other.bytes[i];
      if (diff !== 0) {
        return Math.sign(diff);
      }
    }
    return 0;
  }
};
var V7Generator = class {
  /**
   * Creates a generator object with the default random number generator, or
   * with the specified one if passed as an argument. The specified random
   * number generator should be cryptographically strong and securely seeded.
   */
  constructor(randomNumberGenerator) {
    this.timestamp = 0;
    this.counter = 0;
    this.random = randomNumberGenerator !== null && randomNumberGenerator !== void 0 ? randomNumberGenerator : getDefaultRandom();
  }
  /**
   * Generates a new UUIDv7 object from the current timestamp, or resets the
   * generator upon significant timestamp rollback.
   *
   * This method returns a monotonically increasing UUID by reusing the previous
   * timestamp even if the up-to-date timestamp is smaller than the immediately
   * preceding UUID's. However, when such a clock rollback is considered
   * significant (i.e., by more than ten seconds), this method resets the
   * generator and returns a new UUID based on the given timestamp, breaking the
   * increasing order of UUIDs.
   *
   * See {@link generateOrAbort} for the other mode of generation and
   * {@link generateOrResetCore} for the low-level primitive.
   */
  generate() {
    return this.generateOrResetCore(Date.now(), 1e4);
  }
  /**
   * Generates a new UUIDv7 object from the current timestamp, or returns
   * `undefined` upon significant timestamp rollback.
   *
   * This method returns a monotonically increasing UUID by reusing the previous
   * timestamp even if the up-to-date timestamp is smaller than the immediately
   * preceding UUID's. However, when such a clock rollback is considered
   * significant (i.e., by more than ten seconds), this method aborts and
   * returns `undefined` immediately.
   *
   * See {@link generate} for the other mode of generation and
   * {@link generateOrAbortCore} for the low-level primitive.
   */
  generateOrAbort() {
    return this.generateOrAbortCore(Date.now(), 1e4);
  }
  /**
   * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the
   * generator upon significant timestamp rollback.
   *
   * This method is equivalent to {@link generate} except that it takes a custom
   * timestamp and clock rollback allowance.
   *
   * @param rollbackAllowance - The amount of `unixTsMs` rollback that is
   * considered significant. A suggested value is `10_000` (milliseconds).
   * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.
   */
  generateOrResetCore(unixTsMs, rollbackAllowance) {
    let value2 = this.generateOrAbortCore(unixTsMs, rollbackAllowance);
    if (value2 === void 0) {
      this.timestamp = 0;
      value2 = this.generateOrAbortCore(unixTsMs, rollbackAllowance);
    }
    return value2;
  }
  /**
   * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns
   * `undefined` upon significant timestamp rollback.
   *
   * This method is equivalent to {@link generateOrAbort} except that it takes a
   * custom timestamp and clock rollback allowance.
   *
   * @param rollbackAllowance - The amount of `unixTsMs` rollback that is
   * considered significant. A suggested value is `10_000` (milliseconds).
   * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.
   */
  generateOrAbortCore(unixTsMs, rollbackAllowance) {
    const MAX_COUNTER = 4398046511103;
    if (!Number.isInteger(unixTsMs) || unixTsMs < 1 || unixTsMs > 281474976710655) {
      throw new RangeError("`unixTsMs` must be a 48-bit positive integer");
    } else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {
      throw new RangeError("`rollbackAllowance` out of reasonable range");
    }
    if (unixTsMs > this.timestamp) {
      this.timestamp = unixTsMs;
      this.resetCounter();
    } else if (unixTsMs + rollbackAllowance >= this.timestamp) {
      this.counter++;
      if (this.counter > MAX_COUNTER) {
        this.timestamp++;
        this.resetCounter();
      }
    } else {
      return void 0;
    }
    return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & 2 ** 30 - 1, this.random.nextUint32());
  }
  /** Initializes the counter at a 42-bit random integer. */
  resetCounter() {
    this.counter = this.random.nextUint32() * 1024 + (this.random.nextUint32() & 1023);
  }
  /**
   * Generates a new UUIDv4 object utilizing the random number generator inside.
   *
   * @internal
   */
  generateV4() {
    const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);
    bytes[6] = 64 | bytes[6] >>> 4;
    bytes[8] = 128 | bytes[8] >>> 2;
    return UUID.ofInner(bytes);
  }
};
var getDefaultRandom = () => {
  if (typeof crypto !== "undefined" && typeof crypto.getRandomValues !== "undefined") {
    return new BufferedCryptoRandom();
  } else {
    if (typeof UUIDV7_DENY_WEAK_RNG !== "undefined" && UUIDV7_DENY_WEAK_RNG) {
      throw new Error("no cryptographically strong RNG available");
    }
    return {
      nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 + Math.trunc(Math.random() * 65536)
    };
  }
};
var BufferedCryptoRandom = class {
  constructor() {
    this.buffer = new Uint32Array(8);
    this.cursor = 65535;
  }
  nextUint32() {
    if (this.cursor >= this.buffer.length) {
      crypto.getRandomValues(this.buffer);
      this.cursor = 0;
    }
    return this.buffer[this.cursor++];
  }
};
var defaultGenerator;
var uuidv7 = () => uuidv7obj().toString();
var uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();

// lib/utils.ts
function nonNullable(value2) {
  return value2 != null;
}
var getRawTableNameById = (id) => {
  return `tb_${id}`;
};
var getTableIdByRawTableName = (rawTableName) => {
  return rawTableName.replace("tb_", "");
};
var getColumnIndexName = (tableName, columnName) => {
  return `idx__${tableName}__${columnName}`;
};
var generateColumnName = () => {
  return `cl_${Math.random().toString(36).substring(2, 6)}`;
};
var shortenId = (id) => {
  return id.replace(/-/g, "").replace(/_/g, "");
};
var extractIdFromShortId = (shortId) => {
  return `${shortId.slice(0, 8)}-${shortId.slice(8, 12)}-${shortId.slice(
    12,
    16
  )}-${shortId.slice(16, 20)}-${shortId.slice(20)}`;
};
var getUuid = () => {
  return shortenId(uuidv7());
};
var isDayPageId = (id) => {
  return /^\d{4}-\d{2}-\d{2}$/g.test(id);
};

// lib/sqlite/sql-formula-parser.ts
var getTableNameFromSql = (sql) => {
  const tableName = sql.match(/from\s+(\w+)/i);
  return tableName ? tableName[1] : "";
};
var transformQuery = (sql, fields) => {
  const ast = (0, import_pgsql_ast_parser2.parseFirst)(sql);
  const selectStatement = ast;
  const fieldNameRawIdMap = {};
  fields.forEach((field) => {
    fieldNameRawIdMap[field.name.toLowerCase()] = field.table_column_name;
  });
  const mapper = (0, import_pgsql_ast_parser2.astMapper)((map) => ({
    ref: (t) => {
      const rawName = fieldNameRawIdMap[t.name];
      if (rawName) {
        return {
          ...t,
          name: rawName
        };
      }
      return map.super().ref(t);
    }
  }));
  const modified = mapper.statement(selectStatement);
  return import_pgsql_ast_parser2.toSql.statement(modified);
};
var transformFormula2VirtualGeneratedField = (columnName, fields) => {
  const formulaFields = fields.filter((f) => f.type === "formula" /* Formula */);
  const fieldNameRawIdMap = {};
  fields.forEach((field2) => {
    fieldNameRawIdMap[field2.name.toLowerCase()] = field2.table_column_name;
  });
  const mapper = (0, import_pgsql_ast_parser2.astMapper)((map) => ({
    expr: (t) => {
      if (t && t.type === "call" && t.function.name === "props") {
        const param = t.args[0];
        const rawName = fieldNameRawIdMap[param.name.toLowerCase()];
        return {
          type: "call",
          function: {
            type: "ref",
            // props is udf function, just return the param, generated column must be a expression
            name: "props"
          },
          args: [
            {
              type: "ref",
              name: rawName
            }
          ]
        };
      }
      return map.super().expr(t);
    },
    ref: (t) => {
      const rawName = fieldNameRawIdMap[t.name];
      if (rawName) {
        return {
          ...t,
          name: rawName
        };
      }
      return map.super().ref(t);
    }
  }));
  const field = formulaFields.find((f) => f.table_column_name === columnName);
  if (!field) return null;
  const ast = (0, import_pgsql_ast_parser2.parseFirst)(`select ${field.property.formula}`);
  const modified = mapper.statement(ast);
  const sql = import_pgsql_ast_parser2.toSql.statement(modified);
  return sql.replace("SELECT", "").trim();
};

// lib/mime/mime.ts
var db = __toESM(require_mime_db(), 1);
var import_path_browserify = __toESM(require_path_browserify(), 1);
var extension = (type) => {
  if (!type || typeof type !== "string") {
    return false;
  }
  const match = /^\s*([^;\s]*)(?:;|\s|$)/.exec(type);
  const exts = match && db[match[1].toLowerCase()]?.extensions;
  if (!exts || !exts.length) {
    return false;
  }
  return exts[0];
};
var lookup = (path) => {
  if (!path || typeof path !== "string") {
    return false;
  }
  const extensionValue = (0, import_path_browserify.extname)("x." + path).toLowerCase().slice(1);
  if (!extensionValue) {
    return false;
  }
  let type = types[extensionValue] || false;
  if (type && type.startsWith("application/") && type.endsWith("mp4")) {
    type = type.replace("application/", "video/");
  }
  return type;
};
var populateMaps = (extensions2, types2) => {
  const preference = [
    "nginx",
    "apache",
    void 0,
    "iana"
  ];
  Object.keys(db).forEach((type) => {
    const mime = db[type];
    const exts = mime.extensions;
    if (!exts || !exts.length) {
      return;
    }
    extensions2[type] = exts;
    for (let i = 0; i < exts.length; i++) {
      const extension2 = exts[i];
      if (types2[extension2]) {
        const from = preference.indexOf(db[types2[extension2]].source);
        const to = preference.indexOf(mime.source);
        if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].slice(0, 12) === "application/")) {
          continue;
        }
      }
      types2[extension2] = type;
    }
  });
};
var extensions = /* @__PURE__ */ Object.create(null);
var types = /* @__PURE__ */ Object.create(null);
populateMaps(extensions, types);
var getFileType = (url) => {
  let fileType = lookup(url);
  if (!fileType) return false;
  fileType = fileType.split("/")[0];
  return fileType;
};
var videoIconUrl = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE1IDJINkM1LjQ2OTU3IDIgNC45NjA4NiAyLjIxMDcxIDQuNTg1NzkgMi41ODU3OUM0LjIxMDcxIDIuOTYwODYgNCAzLjQ2OTU3IDQgNFYyMEM0IDIwLjUzMDQgNC4yMTA3MSAyMS4wMzkxIDQuNTg1NzkgMjEuNDE0MkM0Ljk2MDg2IDIxLjc4OTMgNS40Njk1NyAyMiA2IDIySDE4QzE4LjUzMDQgMjIgMTkuMDM5MSAyMS43ODkzIDE5LjQxNDIgMjEuNDE0MkMxOS43ODkzIDIxLjAzOTEgMjAgMjAuNTMwNCAyMCAyMFY3TDE1IDJaIiBzdHJva2U9IiNBQUFBQUEiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0xNCAyVjZDMTQgNi41MzA0MyAxNC4yMTA3IDcuMDM5MTQgMTQuNTg1OCA3LjQxNDIxQzE0Ljk2MDkgNy43ODkyOSAxNS40Njk2IDggMTYgOEgyMCIgc3Ryb2tlPSIjQUFBQUFBIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMTAgMTFMMTUgMTRMMTAgMTdWMTFaIiBzdHJva2U9IiNBQUFBQUEiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPgo=";
var audioIconUrl = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE3LjUgMjJIMThDMTguNTMwNCAyMiAxOS4wMzkxIDIxLjc4OTMgMTkuNDE0MiAyMS40MTQyQzE5Ljc4OTMgMjEuMDM5MSAyMCAyMC41MzA0IDIwIDIwVjdMMTUgMkg2QzUuNDY5NTcgMiA0Ljk2MDg2IDIuMjEwNzEgNC41ODU3OSAyLjU4NTc5QzQuMjEwNzEgMi45NjA4NiA0IDMuNDY5NTcgNCA0VjciIHN0cm9rZT0iI0FBQUFBQSIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPHBhdGggZD0iTTE0IDJWNkMxNCA2LjUzMDQzIDE0LjIxMDcgNy4wMzkxNCAxNC41ODU4IDcuNDE0MjFDMTQuOTYwOSA3Ljc4OTI5IDE1LjQ2OTYgOCAxNiA4SDIwIiBzdHJva2U9IiNBQUFBQUEiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0yIDE5QzIgMTguNDY5NiAyLjIxMDcxIDE3Ljk2MDkgMi41ODU3OSAxNy41ODU4QzIuOTYwODYgMTcuMjEwNyAzLjQ2OTU3IDE3IDQgMTdDNC41MzA0MyAxNyA1LjAzOTE0IDE3LjIxMDcgNS40MTQyMSAxNy41ODU4QzUuNzg5MjkgMTcuOTYwOSA2IDE4LjQ2OTYgNiAxOVYyMEM2IDIwLjUzMDQgNS43ODkyOSAyMS4wMzkxIDUuNDE0MjEgMjEuNDE0MkM1LjAzOTE0IDIxLjc4OTMgNC41MzA0MyAyMiA0IDIyQzMuNDY5NTcgMjIgMi45NjA4NiAyMS43ODkzIDIuNTg1NzkgMjEuNDE0MkMyLjIxMDcxIDIxLjAzOTEgMiAyMC41MzA0IDIgMjBWMTZDMiAxNC40MDg3IDIuNjMyMTQgMTIuODgyNiAzLjc1NzM2IDExLjc1NzRDNC44ODI1OCAxMC42MzIxIDYuNDA4NyAxMCA4IDEwQzkuNTkxMyAxMCAxMS4xMTc0IDEwLjYzMjEgMTIuMjQyNiAxMS43NTc0QzEzLjM2NzkgMTIuODgyNiAxNCAxNC40MDg3IDE0IDE2VjIwQzE0IDIwLjUzMDQgMTMuNzg5MyAyMS4wMzkxIDEzLjQxNDIgMjEuNDE0MkMxMy4wMzkxIDIxLjc4OTMgMTIuNTMwNCAyMiAxMiAyMkMxMS40Njk2IDIyIDEwLjk2MDkgMjEuNzg5MyAxMC41ODU4IDIxLjQxNDJDMTAuMjEwNyAyMS4wMzkxIDEwIDIwLjUzMDQgMTAgMjBWMTlDMTAgMTguNDY5NiAxMC4yMTA3IDE3Ljk2MDkgMTAuNTg1OCAxNy41ODU4QzEwLjk2MDkgMTcuMjEwNyAxMS40Njk2IDE3IDEyIDE3QzEyLjUzMDQgMTcgMTMuMDM5MSAxNy4yMTA3IDEzLjQxNDIgMTcuNTg1OEMxMy43ODkzIDE3Ljk2MDkgMTQgMTguNDY5NiAxNCAxOSIgc3Ryb2tlPSIjQUFBQUFBIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8L3N2Zz4K";
var fileIconUrl = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE1IDJINkM1LjQ2OTU3IDIgNC45NjA4NiAyLjIxMDcxIDQuNTg1NzkgMi41ODU3OUM0LjIxMDcxIDIuOTYwODYgNCAzLjQ2OTU3IDQgNFYyMEM0IDIwLjUzMDQgNC4yMTA3MSAyMS4wMzkxIDQuNTg1NzkgMjEuNDE0MkM0Ljk2MDg2IDIxLjc4OTMgNS40Njk1NyAyMiA2IDIySDE4QzE4LjUzMDQgMjIgMTkuMDM5MSAyMS43ODkzIDE5LjQxNDIgMjEuNDE0MkMxOS43ODkzIDIxLjAzOTEgMjAgMjAuNTMwNCAyMCAyMFY3TDE1IDJaIiBzdHJva2U9IiNBQUFBQUEiIHN0cm9rZS1vcGFjaXR5PSIwLjgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0xNCAyVjZDMTQgNi41MzA0MyAxNC4yMTA3IDcuMDM5MTQgMTQuNTg1OCA3LjQxNDIxQzE0Ljk2MDkgNy43ODkyOSAxNS40Njk2IDggMTYgOEgyMCIgc3Ryb2tlPSIjQUFBQUFBIiBzdHJva2Utb3BhY2l0eT0iMC44IiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8L3N2Zz4K";
var getFilePreviewImage = (url) => {
  const fileType = getFileType(url);
  if (fileType !== "image") {
    switch (fileType) {
      case "audio":
        return audioIconUrl;
      case "video":
        return videoIconUrl;
      default:
        return fileIconUrl;
    }
  }
  return url;
};

// lib/storage/indexeddb.ts
var DATABASE_NAME = "eidos";
async function getIndexedDBValue(tableName, key) {
  return new Promise((resolve, reject) => {
    const openRequest = indexedDB.open(DATABASE_NAME, 1);
    openRequest.onupgradeneeded = function() {
      let db2 = openRequest.result;
      if (!db2.objectStoreNames.contains(tableName)) {
        db2.createObjectStore(tableName);
      }
    };
    openRequest.onsuccess = function() {
      const db2 = openRequest.result;
      const transaction = db2.transaction(tableName, "readonly");
      const store = transaction.objectStore(tableName);
      const getRequest = store.get(key);
      getRequest.onsuccess = function() {
        resolve(getRequest.result);
      };
      getRequest.onerror = function() {
        reject(getRequest.error);
      };
    };
    openRequest.onerror = function() {
      reject(openRequest.error);
    };
  });
}

// lib/storage/eidos-file-system.ts
var getFsRootHandle = async (fsType) => {
  let dirHandle;
  switch (fsType) {
    case "nfs" /* NFS */:
      dirHandle = await getIndexedDBValue("kv", "localPath");
      break;
    case "opfs" /* OPFS */:
    default:
      dirHandle = await navigator.storage.getDirectory();
      break;
  }
  return dirHandle;
};
var getExternalFolderHandle = async (name2) => {
  const externalFolders = await getIndexedDBValue(
    "kv",
    "externalFolders"
  );
  const dirHandle = externalFolders.find((dir) => dir.name === name2);
  return dirHandle;
};
var adapterSymbol = Symbol("adapter");
var getDirHandle = async (_paths, rootDirHandle) => {
  const paths = [..._paths];
  let dirHandle;
  if (rootDirHandle) {
    dirHandle = rootDirHandle;
  } else {
    const fsType = await getIndexedDBValue("kv", "fs");
    dirHandle = await getFsRootHandle(fsType);
  }
  for (let path of paths) {
    dirHandle = await dirHandle.getDirectoryHandle(path, { create: true });
  }
  return dirHandle;
};
var EidosFileSystemManager = class {
  constructor(rootDirHandle) {
    __publicField(this, "rootDirHandle");
    __publicField(this, "isSameEntry", async (dirHandle) => {
      return this.rootDirHandle?.isSameEntry(dirHandle);
    });
    __publicField(this, "getDirHandle", async (paths) => {
      return getDirHandle(paths, this.rootDirHandle);
    });
    __publicField(this, "walk", async (_paths) => {
      const dirHandle = await getDirHandle(_paths, this.rootDirHandle);
      const paths = [];
      const rootDirHandle = await getDirHandle([], this.rootDirHandle);
      for await (let entry of dirHandle.values()) {
        if (entry.kind === "file") {
          const path = await (this.rootDirHandle || rootDirHandle).resolve(entry);
          paths.push(path);
        } else if (entry.kind === "directory") {
          const subPaths = await this.walk([..._paths, entry.name]);
          paths.push(...subPaths);
        }
      }
      return paths;
    });
    __publicField(this, "copyFile", async (_paths, targetFs) => {
      const paths = [..._paths];
      if (paths.length === 0) {
        throw new Error("paths can't be empty");
      }
      const file = await this.getFile(paths);
      const targetPaths = paths.slice(0, -1);
      await targetFs.addFile(targetPaths, file);
    });
    __publicField(this, "copyTo", async (targetFs, options, cb) => {
      const paths = await this.walk([]);
      const targetPaths = await targetFs.walk([]);
      const targetPathsSet = new Set(targetPaths.map((p) => p.join("/")));
      const total = paths.length;
      for (let path of paths) {
        const current = paths.indexOf(path) + 1;
        if (path[0] === ".opfs-sahpool") {
          cb?.({
            current,
            total,
            msg: "ignore .opfs-sahpool"
          });
          continue;
        }
        if (path[path.length - 1] === "db.sqlite3") {
          if (options?.ignoreSqlite) {
            cb?.({
              current,
              total,
              msg: `ignore db.sqlite3`
            });
            continue;
          } else {
            await this.copyFile(path, targetFs);
            cb?.({
              current,
              total,
              msg: `copying ${path.join("/")}`
            });
          }
        }
        if (targetPathsSet.has(path.join("/"))) {
          cb?.({
            current,
            total,
            msg: `file exists ${path.join("/")}`
          });
          continue;
        }
        await this.copyFile(path, targetFs);
        cb?.({
          current,
          total,
          msg: `copying ${path.join("/")}`
        });
      }
      console.log("copy done");
    });
    __publicField(this, "getFileUrlByPath", (path, replaceSpace) => {
      const paths = path.split("/").slice(1);
      if (replaceSpace) {
        paths[0] = replaceSpace;
      }
      return "/" + paths.join("/");
    });
    __publicField(this, "getFileByURL", async (url) => {
      const path = new URL(url).pathname;
      const parentPaths = path.split("/").slice(0, -1).filter(Boolean);
      const parentDirHandle = await getDirHandle(
        ["spaces", ...parentPaths],
        this.rootDirHandle
      );
      const filename = path.split("/").pop();
      const realFilename = decodeURIComponent(filename);
      const fileHandle = await parentDirHandle.getFileHandle(realFilename);
      return fileHandle.getFile();
    });
    __publicField(this, "getFileByPath", async (path) => {
      const paths = path.split("/");
      const file = await this.getFile(paths);
      return file;
    });
    __publicField(this, "listDir", async (_paths) => {
      const dirHandle = await getDirHandle(_paths, this.rootDirHandle);
      const entries = [];
      for await (let entry of dirHandle.values()) {
        entries.push(entry);
      }
      return entries;
    });
    __publicField(this, "updateOrCreateDocFile", async (_paths, content) => {
      const paths = [..._paths];
      if (paths.length === 0) {
        throw new Error("paths can't be empty");
      }
      const filename = paths.pop();
      const dirHandle = await getDirHandle(paths, this.rootDirHandle);
      const fileHandle = await dirHandle.getFileHandle(filename, {
        create: true
      });
      const writable = await fileHandle.createWritable();
      await writable.write(content);
      await writable.close();
      console.log("update doc file", filename);
    });
    __publicField(this, "checkFileExists", async (_paths) => {
      const paths = [..._paths];
      if (paths.length === 0) {
        throw new Error("paths can't be empty");
      }
      const filename = paths.pop();
      const dirHandle = await getDirHandle(paths, this.rootDirHandle);
      try {
        await dirHandle.getFileHandle(filename);
        return true;
      } catch (e) {
        return false;
      }
    });
    __publicField(this, "getFile", async (_paths, options) => {
      const paths = [..._paths.filter(Boolean)];
      if (paths.length === 0) {
        throw new Error("paths can't be empty");
      }
      const filename = paths.pop();
      const dirHandle = await getDirHandle(paths, this.rootDirHandle);
      const fileHandle = await dirHandle.getFileHandle(filename, options);
      const file = await fileHandle.getFile();
      return file;
    });
    __publicField(this, "getFileText", async (_paths) => {
      const file = await this.getFile(_paths);
      return await file.text();
    });
    __publicField(this, "getDocContent", async (_paths) => {
      const file = await this.getFile(_paths);
      return await file.text();
    });
    __publicField(this, "addDir", async (_paths, dirName) => {
      const paths = [..._paths];
      if (paths.length === 0) {
        throw new Error("paths can't be empty");
      }
      const dirHandle = await getDirHandle(paths, this.rootDirHandle);
      const r = await dirHandle.getDirectoryHandle(dirName, { create: true });
    });
    __publicField(this, "addFile", async (_paths, file, fileId) => {
      const paths = [..._paths];
      if (paths.length === 0) {
        throw new Error("paths can't be empty");
      }
      const dirHandle = await getDirHandle(paths, this.rootDirHandle);
      console.log("dirHandle", dirHandle);
      const fileExt = extension(file.type);
      const filename = fileId ? `${fileId}.${fileExt}` : file.name;
      const fileHandle = await dirHandle.getFileHandle(filename, {
        create: true
      });
      const writable = await fileHandle.createWritable();
      await writable.write(file);
      await writable.close();
      const rootDirHandle = await getDirHandle([], this.rootDirHandle);
      const relativePath = await rootDirHandle.resolve(fileHandle);
      console.log("relativePath", { rootDirHandle, fileHandle, relativePath });
      return relativePath;
    });
    __publicField(this, "deleteEntry", async (_paths, isDir = false) => {
      const paths = [..._paths];
      if (paths.length === 0) {
        throw new Error("paths can't be empty");
      }
      if (isDir) {
        const dirHandle = await getDirHandle(paths, this.rootDirHandle);
        await dirHandle.remove({
          recursive: true
        });
      } else {
        const filename = paths.pop();
        const dirHandle = await getDirHandle(paths, this.rootDirHandle);
        await dirHandle.removeEntry(filename);
      }
    });
    __publicField(this, "renameFile", async (_paths, newName) => {
      const paths = [..._paths];
      if (paths.length === 0) {
        throw new Error("paths can't be empty");
      }
      const filename = paths.pop();
      const dirHandle = await getDirHandle(paths, this.rootDirHandle);
      const fileHandle = await dirHandle.getFileHandle(filename, {
        create: true
      });
      await fileHandle.move(newName);
    });
    if (rootDirHandle) {
      this.rootDirHandle = rootDirHandle;
    }
  }
};
var efsManager = isDesktopMode ? new EidosFileSystemManager() : new EidosFileSystemManager();
var getExternalFolderManager = async (name2) => {
  const dirHandler = await getExternalFolderHandle(name2);
  if (!dirHandler) {
    throw new Error("external folder not found");
  }
  const efsManager2 = new EidosFileSystemManager(dirHandler);
  return efsManager2;
};

// lib/sqlite/sql-merge-table-with-new-columns.ts
var import_pgsql_ast_parser3 = __toESM(require_pgsql_ast_parser(), 1);
function generateMergeTableWithNewColumnsSql(createTableSql, newColumnSql) {
  const ast = (0, import_pgsql_ast_parser3.parseFirst)(createTableSql);
  const tableName = ast.name.name;
  const tmpTableName = `tmp_${tableName}`;
  const tmpAst = (0, import_pgsql_ast_parser3.parseFirst)(`
  CREATE TABLE tb_123(
    ${newColumnSql}
  );`);
  const newColumns = tmpAst.columns;
  const oldColumns = ast.columns;
  ast.columns = [...oldColumns, ...newColumns];
  ast.name.name = tmpTableName;
  const newTmpTableSql = import_pgsql_ast_parser3.toSql.statement(ast);
  let sql = newTmpTableSql;
  sql += `
;INSERT INTO ${tmpTableName} (${oldColumns.map((item) => item.name.name).join(",")}) SELECT ${oldColumns.map((item) => item.name.name).join(",")} FROM ${tableName};`;
  sql += `DROP TABLE ${tableName};`;
  sql += `ALTER TABLE ${tmpTableName} RENAME TO ${tableName};`;
  return {
    newTmpTableSql,
    sql
  };
}

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// worker/web-worker/sdk/index-manager.ts
var IndexManager = class {
  constructor(table) {
    this.table = table;
    __publicField(this, "dataSpace");
    __publicField(this, "tableManager");
    this.dataSpace = this.table.dataSpace;
    this.tableManager = table;
  }
  async createIndex(column, onStart, onEnd) {
    const indexName = getColumnIndexName(this.table.rawTableName, column);
    const checkIndexExistsQuery = `
      SELECT name FROM sqlite_master 
      WHERE type='index' AND name='${indexName}'`;
    try {
      const indexExists = await this.dataSpace.syncExec2(checkIndexExistsQuery);
      if (indexExists.length === 0) {
        onStart && onStart();
        this.dataSpace.exec(
          `CREATE INDEX ${indexName} ON ${this.table.rawTableName} (${column})`
        );
        onEnd && onEnd();
        console.log(`Index ${indexName} created.`);
      } else {
        console.log(`Index ${indexName} already exists.`);
      }
    } catch (e) {
      console.error(e);
    }
  }
};

// lib/fields/base.ts
var BaseField = class {
  constructor(column, context) {
    /**
     * each table column has a corresponding ui column, which stored in the `${ColumnTableName}` table
     * we use the ui column to store the column's display name, type, and other ui related information
     * different field will have different property
     */
    __publicField(this, "column");
    __publicField(this, "context");
    this.column = column;
    this.context = context;
  }
  get entityFieldInstance() {
    const field = getFieldInstance(this.column);
    return field;
  }
  // is this field can be transformed to another field
  get isTransformable() {
    return false;
  }
  /**
   * every field should have a property, when you create a new field, you should implement this method
   * @returns
   */
  static getDefaultFieldProperty() {
    return {};
  }
  text2RawData(text) {
    return text ?? null;
  }
};
__publicField(BaseField, "type");

// lib/fields/checkbox.ts
var CheckboxField = class extends BaseField {
  get compareOperators() {
    return ["IsEmpty" /* IsEmpty */, "IsNotEmpty" /* IsNotEmpty */];
  }
  rawData2JSON(rawData) {
    return rawData;
  }
  getCellContent(rawData) {
    return {
      kind: "boolean" /* Boolean */,
      data: Boolean(rawData),
      allowOverlay: false
    };
  }
  cellData2RawData(cell) {
    return {
      rawData: cell.data ? 1 : null
    };
  }
};
__publicField(CheckboxField, "type", "checkbox" /* Checkbox */);

// lib/fields/created-by.ts
var CreatedByField = class extends BaseField {
  rawData2JSON(rawData) {
    return rawData;
  }
  get compareOperators() {
    return [
      "=" /* Equal */,
      "!=" /* NotEqual */,
      "IsEmpty" /* IsEmpty */,
      "IsNotEmpty" /* IsNotEmpty */
    ];
  }
  getCellContent(rawData, context) {
    const { userMap } = context || {};
    const user = userMap?.[rawData || ""] || {
      name: "unknown"
    };
    return {
      kind: "custom" /* Custom */,
      data: {
        image: user.avatar || "",
        kind: "user-profile-cell",
        initial: user.name,
        tint: "#233",
        name: user.name
      },
      copyData: rawData || "",
      allowOverlay: false,
      readonly: true
    };
  }
  cellData2RawData(cell) {
    return {
      rawData: cell.data || null
    };
  }
};
__publicField(CreatedByField, "type", "created-by" /* CreatedBy */);

// lib/fields/created-time.ts
var CreatedTimeField = class extends BaseField {
  rawData2JSON(rawData) {
    return rawData;
  }
  get compareOperators() {
    return [
      "=" /* Equal */,
      "!=" /* NotEqual */,
      ">" /* GreaterThan */,
      ">=" /* GreaterThanOrEqual */,
      "<" /* LessThan */,
      "<=" /* LessThanOrEqual */,
      "IsEmpty" /* IsEmpty */,
      "IsNotEmpty" /* IsNotEmpty */
    ];
  }
  getCellContent(rawData) {
    const str = rawData ? (/* @__PURE__ */ new Date(rawData.split(" ").join("T") + ".000Z")).toLocaleString() : "";
    return {
      kind: "text" /* Text */,
      data: str,
      displayData: str,
      allowOverlay: false,
      readonly: true
    };
  }
  cellData2RawData(cell) {
    return {
      rawData: cell.data || null
    };
  }
};
__publicField(CreatedTimeField, "type", "created-time" /* CreatedTime */);

// lib/fields/date.ts
var DateField = class extends BaseField {
  rawData2JSON(rawData) {
    return rawData;
  }
  get compareOperators() {
    return [
      "=" /* Equal */,
      "!=" /* NotEqual */,
      ">" /* GreaterThan */,
      ">=" /* GreaterThanOrEqual */,
      "<" /* LessThan */,
      "<=" /* LessThanOrEqual */,
      "IsEmpty" /* IsEmpty */,
      "IsNotEmpty" /* IsNotEmpty */
    ];
  }
  getCellContent(rawData) {
    return {
      kind: "custom" /* Custom */,
      data: {
        kind: "date-picker-cell",
        date: rawData ? new Date(rawData) : void 0,
        displayDate: rawData ? new Date(rawData).toLocaleDateString() : "",
        format: "date"
      },
      copyData: rawData ?? "",
      allowOverlay: true
    };
  }
  cellData2RawData(cell) {
    return {
      rawData: cell.data.date?.toISOString() || null
    };
  }
};
__publicField(DateField, "type", "date" /* Date */);

// lib/fields/file.ts
var FileField = class extends BaseField {
  constructor() {
    super(...arguments);
    /**
     * we need to proxy the image to avoid CORS issue. if the image is a remote url, we will proxy it
     */
    __publicField(this, "getProxyData", (data) => {
      if (this.column.property?.proxyUrl) {
        const proxyUrl = this.column.property?.proxyUrl;
        return data.map((_d) => {
          const d = _d.trim();
          const fileType = getFileType(d);
          if (fileType !== "image") {
            return getFilePreviewImage(d);
          }
          if (d.startsWith("http")) {
            return proxyUrl + d;
          }
          return d;
        });
      }
      return data.filter(Boolean).map((d) => {
        const fileType = getFileType(d);
        if (fileType !== "image") {
          return getFilePreviewImage(d);
        }
        return d;
      });
    });
  }
  rawData2JSON(rawData) {
    return rawData;
  }
  get compareOperators() {
    return ["IsEmpty" /* IsEmpty */, "IsNotEmpty" /* IsNotEmpty */];
  }
  static getDefaultFieldProperty() {
    return {
      proxyUrl: "https://proxy.eidos.space/?url="
    };
  }
  getCellContent(rawData) {
    const data = rawData?.split(",").filter(Boolean) ?? [];
    return {
      kind: "custom" /* Custom */,
      data: {
        kind: "file-cell",
        data,
        displayData: this.getProxyData(data),
        allowAdd: true,
        proxyUrl: this.column.property?.proxyUrl
      },
      copyData: rawData,
      allowOverlay: true
    };
  }
  cellData2RawData(cell) {
    return {
      rawData: cell.data.data?.join(",") || null
    };
  }
};
__publicField(FileField, "type", "file" /* File */);

// lib/fields/formula.ts
var FormulaField = class extends BaseField {
  get compareOperators() {
    return [];
  }
  rawData2JSON(rawData) {
    return rawData;
  }
  getCellContent(rawData) {
    const fieldInstance = getFieldInstance({
      ...this.column,
      type: this.column.property.displayType ?? "text" /* Text */
    });
    const content = fieldInstance.getCellContent(rawData);
    return {
      ...content,
      allowOverlay: true,
      readonly: true
    };
  }
  cellData2RawData(cell) {
    return {
      rawData: cell.data || null
    };
  }
};
__publicField(FormulaField, "type", "formula" /* Formula */);

// lib/fields/last-edited-by.ts
var LastEditedByField = class extends BaseField {
  rawData2JSON(rawData) {
    return rawData;
  }
  get compareOperators() {
    return [
      "=" /* Equal */,
      "!=" /* NotEqual */,
      "IsEmpty" /* IsEmpty */,
      "IsNotEmpty" /* IsNotEmpty */
    ];
  }
  getCellContent(rawData, context) {
    const { userMap } = context || {};
    const user = userMap?.[rawData || ""] || {
      name: "unknown"
    };
    return {
      kind: "custom" /* Custom */,
      data: {
        image: user.avatar || "",
        kind: "user-profile-cell",
        initial: user.name,
        tint: "#233",
        name: user.name
      },
      copyData: rawData || "",
      allowOverlay: false,
      readonly: true
    };
  }
  cellData2RawData(cell) {
    return {
      rawData: cell.data || null
    };
  }
};
__publicField(LastEditedByField, "type", "last-edited-by" /* LastEditedBy */);

// lib/fields/last-edited-time.ts
var LastEditedTimeField = class extends BaseField {
  rawData2JSON(rawData) {
    return rawData;
  }
  get compareOperators() {
    return [
      "=" /* Equal */,
      "!=" /* NotEqual */,
      ">" /* GreaterThan */,
      ">=" /* GreaterThanOrEqual */,
      "<" /* LessThan */,
      "<=" /* LessThanOrEqual */,
      "IsEmpty" /* IsEmpty */,
      "IsNotEmpty" /* IsNotEmpty */
    ];
  }
  getCellContent(rawData) {
    const str = rawData ? (/* @__PURE__ */ new Date(
      (rawData || "").split(" ").join("T") + ".000Z"
    )).toLocaleString() : "";
    return {
      kind: "text" /* Text */,
      data: str,
      displayData: str,
      allowOverlay: false,
      readonly: true
    };
  }
  cellData2RawData(cell) {
    return {
      rawData: cell.data || null
    };
  }
};
__publicField(LastEditedTimeField, "type", "last-edited-time" /* LastEditedTime */);

// lib/fields/link.ts
var import_lodash = __toESM(require_lodash(), 1);
var LinkField = class extends BaseField {
  rawData2JSON(rawData) {
    return rawData;
  }
  get compareOperators() {
    return [];
  }
  getCellContent(rawData, context) {
    const titleKey = `${this.column.table_column_name}__title`;
    const ids = rawData?.split(",") || [];
    const titles = context?.row?.[titleKey]?.split(",") || [];
    return {
      kind: "custom" /* Custom */,
      data: {
        kind: "link-cell",
        value: (0, import_lodash.zip)(ids, titles).map(([id, title]) => ({
          id: id || "",
          title: title || "Untitled"
        })),
        linkTable: this.column.property.linkTableName
      },
      copyData: context?.row?.[titleKey] || "",
      allowOverlay: true
    };
  }
  cellData2RawData(cell) {
    return {
      rawData: cell.data.value.map((item) => item.id).join(",") || null
    };
  }
};
__publicField(LinkField, "type", "link" /* Link */);

// lib/fields/lookup.ts
var LookupField = class extends BaseField {
  /**
   * get target field instance, no matter it is a lookup field or not
   * we will store all lookup cell data in database, if we want to get lookup cell data, we just need to get the target field
   * do not need to get the entity field instance
   * @returns
   */
  getTargetFieldInstance() {
    const { lookupTargetFieldId } = this.column.property;
    const linkTable = this.context?.linkField?.property?.linkTableName;
    const linkTableId = getTableIdByRawTableName(linkTable || "");
    const target = this.context?.lookupTargetFieldsMap[linkTableId]?.[lookupTargetFieldId];
    if (!target) return null;
    return getFieldInstance(target.field, target.context);
  }
  /**
   * for render, we need to get the entity field instance
   * a->b->c->d
   * maybe a&b&c are lookup field, but d is not a lookup field
   * we will get the target field recursively until the target field is not a lookup field
   * @returns
   */
  get entityFieldInstance() {
    const targetField = this.getTargetFieldInstance();
    if (!targetField) return null;
    if (targetField.column.type === "lookup" /* Lookup */) {
      return targetField.entityFieldInstance;
    }
    return targetField;
  }
  rawData2JSON(rawData) {
    const field = this.entityFieldInstance;
    return field?.rawData2JSON(rawData) || null;
  }
  get compareOperators() {
    const field = this.entityFieldInstance;
    return field?.compareOperators || [];
  }
  getCellContent(rawData, context) {
    const field = this.entityFieldInstance;
    if (!field) {
      return {
        kind: "text" /* Text */,
        data: "",
        displayData: "",
        allowOverlay: false
      };
    }
    let cellData;
    if ("getCellContentViaLookup" in field) {
      cellData = field.getCellContentViaLookup(rawData);
    } else {
      cellData = field?.getCellContent(rawData, context);
    }
    return {
      ...cellData,
      allowOverlay: false
      // lookup field should not be editable
    };
  }
  cellData2RawData(cell) {
    return {
      rawData: null
    };
  }
};
__publicField(LookupField, "type", "link" /* Link */);

// lib/fields/select.ts
var _SelectField = class _SelectField extends BaseField {
  /**
   * @param colorName name of the color. eg "default" | "gray"
   * @param theme theme of the color. eg "light" | "dark"
   * @returns hex value of the color. eg "#cccccc"
   */
  static getColorValue(colorName, theme = "light") {
    return `#${_SelectField.colorNameValueMap[theme][colorName]}`;
  }
  get compareOperators() {
    return [
      "=" /* Equal */,
      "!=" /* NotEqual */,
      "IsEmpty" /* IsEmpty */,
      "IsNotEmpty" /* IsNotEmpty */
    ];
  }
  get options() {
    return this.column.property?.options ?? [];
  }
  rawData2JSON(rawData) {
    const options = this.column.property?.options ?? [];
    const option = options.find((o) => o.id === rawData);
    return option?.name || "";
  }
  getCellContent(rawData) {
    const options = this.column.property?.options ?? [];
    return {
      kind: "custom" /* Custom */,
      data: {
        kind: "select-cell",
        value: rawData,
        allowedValues: options
      },
      copyData: rawData,
      allowOverlay: true
    };
  }
  /**
   * getCellContentViaLookup is used when the field is used as a lookup target field. 
   * lookup will convert the raw data to a multi-select cell, value split by comma. 
   * @param rawData 
   * @returns 
   */
  getCellContentViaLookup(rawData) {
    const multiSelectField = new MultiSelectField(this.column);
    return multiSelectField.getCellContent(rawData);
  }
  cellData2RawData(cell) {
    if (cell.data.value == null) return { rawData: null };
    if (cell.data.kind !== "select-cell") {
      throw new Error("invalid cell data");
    }
    if (cell.data.value.length === 0) {
      return {
        rawData: cell.data.value
      };
    }
    if (this.options.map((i) => i.id).includes(cell.data.value)) {
      return {
        rawData: cell.data.value
      };
    } else {
      const newOption = this.addOption(cell.data.value);
      return {
        rawData: newOption[0].id || null,
        shouldUpdateColumnProperty: true
      };
    }
  }
  static getDefaultFieldProperty() {
    return {
      options: []
    };
  }
  static generateOptionsByNames(names) {
    return names.map((name2, index) => {
      return {
        id: name2,
        name: name2,
        color: _SelectField.colors.light[index % _SelectField.colors.light.length].name
      };
    });
  }
  changeOptionName(id, newName) {
    const options = this.column.property?.options ?? [];
    const option = options.find((o) => o.id === id);
    if (option) {
      option.name = newName;
      option.id = newName;
    }
    this.column.property.options = options;
  }
  changeOptionColor(id, newColor) {
    const options = this.column.property?.options ?? [];
    const option = options.find((o) => o.id === id);
    if (option) {
      option.color = newColor;
    }
    this.column.property.options = options;
  }
  static getNextAvailableColor(existingOptions) {
    const allColors = _SelectField.colors.light.map((c) => c.name);
    const usedColors = new Set(existingOptions.map((o) => o.color));
    return allColors.find((color) => !usedColors.has(color)) || allColors[existingOptions.length % allColors.length];
  }
  addOption(name2) {
    const options = this.column.property?.options ?? [];
    const nextColor = _SelectField.getNextAvailableColor(options);
    const newOptions = [
      { id: name2, name: name2, color: nextColor },
      ...options
    ];
    this.column.property.options = newOptions;
    return newOptions;
  }
  deleteOption(id) {
    const options = this.column.property?.options ?? [];
    const index = options.findIndex((o) => o.id === id);
    if (index >= 0) {
      options.splice(index, 1);
    }
    this.column.property.options = options;
  }
  /**
   * @param text tag1
   * return tag1id
   */
  // text2RawData(text: string | undefined) {
  //   // if text is isUuid
  //   if (
  //     text?.length === 36 &&
  //     text[8] === "-" &&
  //     this.options.find((i) => i.id === text)
  //   ) {
  //     return text
  //   }
  //   const option = this.options.find((i) => i.name === text)
  //   if (option) {
  //     return option.id
  //   } else {
  //     // a new option name is entered, create a new option
  //     return ""
  //     // const newOption = this.addOption(text)
  //     // return newOption[0].id
  //   }
  // }
};
__publicField(_SelectField, "type", "select" /* Select */);
__publicField(_SelectField, "colors", {
  light: [
    {
      name: "default",
      value: "cccccc"
    },
    {
      name: "gray",
      value: "eeeeee"
    },
    {
      name: "brown",
      value: "e6c9a8"
    },
    {
      name: "pink",
      value: "ffd3e6"
    },
    {
      name: "red",
      value: "ffadad"
    },
    {
      name: "orange",
      value: "ffd6a5"
    },
    {
      name: "yellow",
      value: "fdffb6"
    },
    {
      name: "green",
      value: "caffbf"
    },
    {
      name: "cyan",
      value: "9bf6ff"
    },
    {
      name: "blue",
      value: "a0c4ff"
    },
    {
      name: "purple",
      value: "bdb2ff"
    }
  ],
  dark: [
    {
      name: "default",
      value: "333333"
    },
    {
      name: "gray",
      value: "555555"
    },
    {
      name: "brown",
      value: "5b4d3d"
    },
    {
      name: "pink",
      value: "9a3f5e"
    },
    {
      name: "red",
      value: "a63232"
    },
    {
      name: "orange",
      value: "ff9f4d"
    },
    {
      name: "yellow",
      value: "6e6620"
    },
    {
      name: "green",
      value: "23563b"
    },
    {
      name: "cyan",
      value: "1c5858"
    },
    {
      name: "blue",
      value: "3168a8"
    },
    {
      name: "purple",
      value: "6e33b4"
    }
  ]
});
__publicField(_SelectField, "defaultColor", _SelectField.colors.light[0].name);
__publicField(_SelectField, "colorNameValueMap", {
  light: _SelectField.colors.light.reduce((acc, color) => {
    acc[color.name] = color.value;
    return acc;
  }, {}),
  dark: _SelectField.colors.dark.reduce((acc, color) => {
    acc[color.name] = color.value;
    return acc;
  }, {})
});
var SelectField = _SelectField;

// lib/fields/multi-select.ts
var _MultiSelectField = class _MultiSelectField extends BaseField {
  get compareOperators() {
    return [
      "Contains" /* Contains */,
      "NotContains" /* NotContains */,
      "IsEmpty" /* IsEmpty */,
      "IsNotEmpty" /* IsNotEmpty */
    ];
  }
  get type() {
    return _MultiSelectField.type;
  }
  get options() {
    return this.column.property?.options ?? [];
  }
  // TODO: refactor multi-select and select to use the same code
  addOption(name2) {
    const options = this.column.property?.options ?? [];
    const nextColorName = SelectField.getNextAvailableColor(options);
    const newOptions = [
      { id: name2, name: name2, color: nextColorName },
      ...options
    ];
    this.column.property.options = newOptions;
    return newOptions;
  }
  rawData2JSON(rawData) {
    const options = this.column.property?.options ?? [];
    const ids = rawData ? rawData.split(",").map((s) => s.trim()) : [];
    const names = ids.map((id) => {
      const option = options.find((i) => i.id === id);
      return option?.name || "";
    });
    return names;
  }
  /**
   * in database we store the tags as a string, so we need to convert it to an array of strings
   * e.g. 
   * "tag1,tag2,tag3" => ["tag1", "tag2", "tag3"]
   * "tag1, tag2 with space" => ["tag1", "tag2 with space"]
   * @param rawData
   * @returns
   */
  getCellContent(rawData) {
    return {
      kind: "custom" /* Custom */,
      data: {
        kind: "multi-select-cell",
        allowedValues: this.column.property?.options ?? [],
        values: rawData ? rawData.split(",").map((s) => s.trim()) : []
      },
      copyData: rawData,
      allowOverlay: true
    };
  }
  /**
   * @param text tag1,tag2
   * return tag1id,tag2id
   */
  // text2RawData(text: string) {
  //   // text can be a uuid or a name
  //   return text
  //     ?.split(/[\s,]+/)
  //     .map((value) => {
  //       const option = this.options.find((i) => i.id === value)
  //       if (option) {
  //         return option.id
  //       } else {
  //         // a new option name is entered, create a new option
  //         return
  //         const newOption = this.addOption(value)
  //         return newOption[0].id
  //       }
  //     })
  //     .filter(Boolean)
  //     .join(",")
  // }
  cellData2RawData(cell) {
    if (cell.data.values == null) return { rawData: null };
    const allowedOptionIds = new Set(this.options.map((i) => i.id));
    const newValues = [];
    let shouldUpdateColumnProperty = false;
    for (const value2 of cell.data.values) {
      if (allowedOptionIds.has(value2)) {
        newValues.push(value2);
      } else {
        const newOption = this.addOption(value2);
        newValues.push(newOption[0].id);
        shouldUpdateColumnProperty = true;
      }
    }
    return {
      rawData: newValues.join(",") || null,
      shouldUpdateColumnProperty
    };
  }
  createFieldProperty() {
    return {
      options: []
    };
  }
};
__publicField(_MultiSelectField, "type", "multi-select" /* MultiSelect */);
var MultiSelectField = _MultiSelectField;

// lib/fields/number.ts
var NumberField = class extends BaseField {
  get compareOperators() {
    return NUMBER_BASED_COMPARE_OPERATORS;
  }
  rawData2JSON(rawData) {
    return rawData;
  }
  getCellContent(rawData) {
    if (rawData == null) {
      return {
        kind: "number" /* Number */,
        data: void 0,
        displayData: "",
        allowOverlay: true
      };
    }
    if (this.column.property?.showAs === "bar") {
      return {
        kind: "custom" /* Custom */,
        data: {
          kind: "range-cell",
          min: 0,
          max: this.column.property?.divideBy || 100,
          step: 1,
          label: this.column.property?.showNumber ? rawData?.toString() ?? "" : "",
          value: rawData ?? 0,
          color: this.column.property?.color
        },
        copyData: rawData?.toString() ?? "",
        allowOverlay: true
      };
    }
    return {
      kind: "number" /* Number */,
      data: rawData,
      displayData: rawData == null ? "" : `${rawData}`,
      allowOverlay: true
    };
  }
  cellData2RawData(cell) {
    if (cell.kind === "custom" /* Custom */) {
      return {
        rawData: cell.data.value
      };
    }
    return {
      rawData: cell.data ?? null
    };
  }
};
__publicField(NumberField, "type", "number" /* Number */);

// lib/fields/rating.ts
var RatingField = class extends BaseField {
  get compareOperators() {
    return NUMBER_BASED_COMPARE_OPERATORS;
  }
  rawData2JSON(rawData) {
    return rawData;
  }
  getCellContent(rawData) {
    return {
      kind: "custom" /* Custom */,
      data: {
        kind: "rating-cell",
        rating: rawData
      },
      copyData: `${rawData}`,
      allowOverlay: true
    };
  }
  cellData2RawData(cell) {
    return {
      rawData: cell.data.rating ?? null
    };
  }
};
__publicField(RatingField, "type", "rating" /* Rating */);

// lib/fields/text.ts
var TextField = class extends BaseField {
  get compareOperators() {
    return TEXT_BASED_COMPARE_OPERATORS;
  }
  rawData2JSON(rawData) {
    return rawData;
  }
  getCellContent(rawData) {
    return {
      kind: "text" /* Text */,
      data: rawData ? rawData + "" : "",
      displayData: rawData ? rawData + "" : "",
      allowOverlay: true
    };
  }
  cellData2RawData(cell) {
    return {
      rawData: cell.data || null
    };
  }
};
__publicField(TextField, "type", "text" /* Text */);

// lib/fields/title.ts
var TitleField = class extends BaseField {
  get compareOperators() {
    return TEXT_BASED_COMPARE_OPERATORS;
  }
  rawData2JSON(rawData) {
    return rawData;
  }
  getCellContent(rawData) {
    return {
      kind: "text" /* Text */,
      data: rawData ?? "",
      displayData: rawData ?? "",
      allowOverlay: true
    };
  }
  cellData2RawData(cell) {
    return {
      rawData: cell.data || null
    };
  }
};
__publicField(TitleField, "type", "title" /* Title */);

// lib/fields/url.ts
var URLField = class extends BaseField {
  get compareOperators() {
    return TEXT_BASED_COMPARE_OPERATORS;
  }
  rawData2JSON(rawData) {
    return rawData;
  }
  getCellContent(rawData) {
    return {
      kind: "uri" /* Uri */,
      data: rawData ?? "",
      allowOverlay: true,
      hoverEffect: true,
      onClickUri: (args) => {
        window.open(rawData, "_blank");
      }
    };
  }
  cellData2RawData(cell) {
    return {
      rawData: cell.data || null
    };
  }
};
__publicField(URLField, "type", "url" /* URL */);

// lib/fields/index.ts
var baseFieldTypes = [
  CheckboxField,
  DateField,
  FileField,
  MultiSelectField,
  NumberField,
  RatingField,
  SelectField,
  TextField,
  TitleField,
  URLField,
  FormulaField,
  LinkField,
  CreatedTimeField,
  LastEditedTimeField,
  CreatedByField,
  LastEditedByField
];
var allFieldTypesMap = baseFieldTypes.reduce(
  (acc, fieldType) => {
    acc[fieldType.type] = fieldType;
    return acc;
  },
  {
    ["lookup" /* Lookup */]: LookupField
  }
);
function getFieldInstance(field, context) {
  const FieldCls = allFieldTypesMap[field.type];
  return new FieldCls(field, context);
}

// worker/web-worker/store.ts
var workerStore = {
  currentCallUserId: null
};

// lib/sqlite/interface.ts
var BaseServerDatabase = class {
  constructor() {
    __publicField(this, "filename");
  }
};

// worker/web-worker/sdk/rows.ts
var RowsManager = class _RowsManager {
  constructor(table) {
    this.table = table;
    __publicField(this, "dataSpace");
    __publicField(this, "fieldMap");
    __publicField(this, "tableManager");
    __publicField(this, "updateCellSideEffect", async (field, rowId, value2) => {
      switch (field?.type) {
        case "select" /* Select */:
          await this.tableManager.fields.select.updateFieldPropertyIfNeed(
            field,
            value2
          );
          break;
        case "multi-select" /* MultiSelect */:
          await this.tableManager.fields.multiSelect.updateFieldPropertyIfNeed(
            field,
            value2
          );
          break;
        case "link" /* Link */:
          const row = await this.tableManager.rows.get(rowId, { raw: true });
          const oldValue = row?.[field.table_column_name];
          await this.tableManager.fields.link.updateLinkRelation(
            field,
            rowId,
            value2,
            oldValue
          );
          break;
        default:
          break;
      }
    });
    this.dataSpace = this.table.dataSpace;
    this.tableManager = table;
  }
  static getReadableRows(rows, fields) {
    const fieldMap = fields.reduce((acc, cur) => {
      acc[cur.table_column_name] = cur;
      return acc;
    }, {});
    return rows.map((row) => {
      const data = {};
      Object.entries(row).forEach(([key, value2]) => {
        const field = fieldMap[key];
        if (key.startsWith("cl_") && field) {
          const readableFieldName = field.name;
          data[readableFieldName] = value2;
        } else {
          data[key] = value2;
        }
      });
      return data;
    });
  }
  async getFieldMap() {
    if (this.fieldMap) {
      return this.fieldMap;
    }
    const uiColumns = await this.dataSpace.column.list({
      table_name: this.table.rawTableName
    });
    const fieldRawColumnNameFieldMap = uiColumns.reduce((acc, cur) => {
      acc[cur.table_column_name] = cur;
      return acc;
    }, {});
    const fieldNameRawColumnNameMap = uiColumns.reduce((acc, cur) => {
      acc[cur.name] = cur.table_column_name;
      return acc;
    }, {});
    this.fieldMap = {
      fieldRawColumnNameFieldMap,
      fieldNameRawColumnNameMap
    };
    return this.fieldMap;
  }
  static rawData2Json(row, fieldRawColumnNameFieldMap) {
    const data = {};
    Object.entries(row).forEach(([key, value2]) => {
      if (key === "rowid") {
      } else if (key === "_id") {
        data[key] = value2;
      } else {
        const uiColumn = fieldRawColumnNameFieldMap[key];
        if (!uiColumn) {
          return;
        }
        const field = getFieldInstance(uiColumn);
        data[uiColumn.name] = field.rawData2JSON(value2);
      }
    });
    return data;
  }
  transformData(data, context, options) {
    const { fieldRawColumnNameFieldMap, fieldNameRawColumnNameMap } = context;
    const notExistKeys = [];
    Object.keys(data).forEach((key) => {
      const rawColumnName = options?.useFieldId ? key : fieldNameRawColumnNameMap[key];
      if (key === "_id" || key.startsWith("cl_") && key.length > 7) {
      } else if (!rawColumnName) {
        delete data[key];
        notExistKeys.push(key);
      } else {
        const uiColumn = fieldRawColumnNameFieldMap[rawColumnName];
        const field = getFieldInstance(uiColumn);
        data[key] = field.text2RawData(data[key]);
      }
    });
    const kvTuple = [];
    Object.entries(data).forEach(([key, value2]) => {
      if (key === "_id") {
        kvTuple.push([key, value2]);
      } else {
        const rawColumnName = options?.useFieldId ? key : fieldNameRawColumnNameMap[key];
        kvTuple.push([rawColumnName, value2]);
      }
    });
    return {
      notExistKeys,
      rawData: Object.fromEntries(kvTuple)
    };
  }
  /**
   * get row by id
   * @param id
   * @returns
   */
  async get(id, options) {
    const { fieldRawColumnNameFieldMap } = await this.getFieldMap();
    let sql = `SELECT * FROM ${this.table.rawTableName} WHERE _id = ?`;
    if (options?.withRowId) {
      sql = `SELECT rowid, * FROM ${this.table.rawTableName} WHERE _id = ?`;
    }
    const rows = await this.dataSpace.exec2(sql, [id]);
    if (rows.length === 0) {
      return null;
    }
    if (options?.raw) {
      return rows[0];
    }
    return _RowsManager.rawData2Json(rows[0], fieldRawColumnNameFieldMap);
  }
  /**
   * @param filter a filter object, the key is field name, the value is field value
   * @param options
   * @returns
   */
  async query(filter = {}, options) {
    const { fieldRawColumnNameFieldMap, fieldNameRawColumnNameMap } = await this.getFieldMap();
    let rows = [];
    if (options?.rawQuery) {
      rows = await this.dataSpace.exec2(options.rawQuery);
    } else if (options?.viewId) {
      const view = await this.dataSpace.view.get(options.viewId);
      if (!view) {
        throw new Error("view not found");
      }
      rows = await this.dataSpace.exec2(view.query);
    } else {
      const { rawData, notExistKeys } = this.transformData(filter || {}, {
        fieldNameRawColumnNameMap,
        fieldRawColumnNameFieldMap
      });
      if (notExistKeys.length > 0) {
        throw new Error(`not exist keys: ${notExistKeys.join(",")}`);
      }
      const hasFilter = Object.keys(rawData).length > 0;
      const sql = `SELECT * FROM ${this.table.rawTableName} ${hasFilter ? "WHERE" : ""} ${Object.keys(rawData).map((key) => `${key} = ?`).join(" AND ")} ${options?.limit ? `LIMIT ${options.limit}` : ""} ${options?.offset ? `OFFSET ${options.offset}` : ""}`;
      const bind = Object.values(rawData);
      rows = await this.dataSpace.exec2(sql, bind);
    }
    if (options?.raw) {
      return rows;
    }
    return rows.map(
      (row) => _RowsManager.rawData2Json(row, fieldRawColumnNameFieldMap)
    );
  }
  getCreateData(data) {
    return {
      _id: uuidv7(),
      _created_by: workerStore.currentCallUserId,
      _last_edited_by: workerStore.currentCallUserId,
      ...data
    };
  }
  getUpdateData(data) {
    const { _id, _created_by, _created_time, ...restData } = data;
    return {
      ...restData,
      _last_edited_time: (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ").replace("Z", ""),
      _last_edited_by: workerStore.currentCallUserId
    };
  }
  /**
   * for high performance, use transaction
   * @param datas
   * @param fieldMap
   * @param options
   * @returns
   */
  batchSyncCreate(datas, fieldMap, options) {
    const { fieldRawColumnNameFieldMap, fieldNameRawColumnNameMap } = fieldMap;
    const createDatas = datas.map((data) => {
      const { rawData, notExistKeys } = this.transformData(
        data,
        {
          fieldNameRawColumnNameMap,
          fieldRawColumnNameFieldMap
        },
        {
          useFieldId: options?.useFieldId
        }
      );
      if (notExistKeys.length > 0) {
        throw new Error(`not exist keys: ${notExistKeys.join(",")}`);
      }
      return this.getCreateData(rawData);
    });
    const keys = Object.keys(createDatas[0]).join(",");
    const values = createDatas.map((data) => Object.values(data));
    const _values = Array(values[0].length).fill("?").join(",");
    const stmt = this.dataSpace.db.prepare(`
      INSERT INTO ${this.table.rawTableName} (${keys}) VALUES (${_values})`);
    if (this.dataSpace.db instanceof BaseServerDatabase) {
      for (const value2 of values) {
        stmt.run(value2);
      }
    } else {
      this.dataSpace.db.transaction(async () => {
        for (const value2 of values) {
          stmt.bind(value2).step();
          stmt.reset();
        }
        stmt.finalize();
      });
    }
    return createDatas;
  }
  async create(data, options) {
    const { fieldRawColumnNameFieldMap, fieldNameRawColumnNameMap } = await this.getFieldMap();
    const { rawData, notExistKeys } = this.transformData(
      data,
      {
        fieldNameRawColumnNameMap,
        fieldRawColumnNameFieldMap
      },
      {
        useFieldId: options?.useFieldId
      }
    );
    if (notExistKeys.length > 0) {
      throw new Error(`not exist keys: ${notExistKeys.join(",")}`);
    }
    const createData = this.getCreateData(rawData);
    const keys = Object.keys(createData).join(",");
    const values = Object.values(createData);
    const _values = Array(values.length).fill("?").join(",");
    const sql = `INSERT INTO ${this.table.rawTableName} (${keys}) VALUES (${_values})`;
    await this.dataSpace.exec2(sql, values);
    this.dataSpace.undoRedoManager.event();
    return createData;
  }
  async delete(id) {
    try {
      await this.dataSpace.exec2(
        `DELETE FROM ${this.table.rawTableName} WHERE _id = ?`,
        [id]
      );
      return true;
    } catch (error) {
      return false;
    }
  }
  async batchDelete(ids) {
    try {
      const sql = `DELETE FROM ${this.table.rawTableName} WHERE _id IN (${ids.map(() => "?").join(",")})`;
      console.log(sql);
      await this.dataSpace.exec2(sql, ids);
      return true;
    } catch (error) {
      return false;
    }
  }
  async update(id, data, options) {
    const { fieldRawColumnNameFieldMap, fieldNameRawColumnNameMap } = await this.getFieldMap();
    const { rawData, notExistKeys } = this.transformData(
      data,
      {
        fieldNameRawColumnNameMap,
        fieldRawColumnNameFieldMap
      },
      {
        useFieldId: options?.useFieldId
      }
    );
    if (notExistKeys.length > 0) {
      throw new Error(`not exist keys: ${notExistKeys.join(",")}`);
    }
    const updateData = this.getUpdateData(rawData);
    for (const [key, value2] of Object.entries(updateData)) {
      const field = fieldRawColumnNameFieldMap[key];
      if (field) {
        await this.updateCellSideEffect(field, id, value2);
      }
    }
    const values = Object.values(updateData);
    const sql = `UPDATE ${this.table.rawTableName} SET ${Object.keys(updateData).map((key) => `${key} = ?`).join(",")} WHERE _id = ?`;
    const bind = [...values, id];
    await this.dataSpace.exec2(sql, bind);
    this.dataSpace.undoRedoManager.event();
    return {
      id,
      ...updateData
    };
  }
  /**
   * highlight the row if it is in the current view
   * @param id row id
   */
  async highlight(id) {
    postMessage({
      type: "HighlightRow" /* HighlightRow */,
      payload: {
        tableId: this.table.id,
        rowId: id
      }
    });
  }
};

// worker/web-worker/sdk/service/link.ts
var LinkFieldService = class {
  constructor(table) {
    this.table = table;
    __publicField(this, "dataSpace");
    __publicField(this, "db");
    __publicField(this, "getEffectRowsByRelationDeleted", async (relationTableName, relation, db2 = this.dataSpace.db) => {
      const [selfTable, refTable] = relationTableName.replace("lk_", "").split("__", 2);
      const res1 = await this.dataSpace.syncExec2(
        `SELECT * FROM ${relationTableName} WHERE self = ? AND link_field_id = ?`,
        [relation.self, relation.link_field_id],
        db2
      );
      return {
        // group by link_field_id
        [selfTable]: res1.reduce(
          (acc, item) => {
            const linkFieldId = item.link_field_id;
            if (!acc[linkFieldId]) {
              acc[linkFieldId] = /* @__PURE__ */ new Set();
            }
            acc[linkFieldId].add(item.self);
            return acc;
          },
          {
            [relation.link_field_id]: /* @__PURE__ */ new Set([relation.self])
          }
        )
      };
    });
    /**
     * get diff between new value and old value
     * eg: new value is "1,2,3", old value is "1,2,3,4" => added: [], removed: [4]
     * eg: new value is "1,2,3,4", old value is "1,3" => added: [2,4], removed: []
     * eg: new value is "1,2,3,4", old value is "1,2,3,4" => added: [], removed: []
     * eg: new value is null, old value is "1,2,3,4" => added: [], removed: [1,2,3,4]
     * eg: new value is "1,2,3,4", old value is null => added: [1,2,3,4], removed: []
     * eg: new value is "1,3,4,5", old value is "1,2,3,4" => added: [5], removed: [2]
     * eg: new value is "1", old value is "2" => added: [1], removed: [2]
     * @param newValue
     * @param oldValue
     */
    __publicField(this, "getDiff", (newValue, oldValue) => {
      const newList = newValue?.split(/,/) || [];
      const oldList = oldValue?.split(/,/) || [];
      const added = newList?.filter((item) => !oldList?.includes(item)) || [];
      const removed = oldList?.filter((item) => !newList?.includes(item)) || [];
      return {
        added,
        removed
      };
    });
    __publicField(this, "getEffectRows", async (table_name, rowIds, db2 = this.dataSpace.db) => {
      const allLinkTables = await db2.selectObjects(
        `SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'lk_tb_%${table_name}%'`
      );
      const allLinkRelationTableNames = allLinkTables.map(
        (item) => item.name
      );
      const effectRows = {};
      allLinkRelationTableNames.forEach(async (relationTableName) => {
        const sql = `SELECT self FROM ${relationTableName} WHERE ref IN (${rowIds.map(() => "?").join(",")})`;
        const bind = [...rowIds];
        const res = await db2.selectObjects(sql, bind);
        const effectTableName = relationTableName.replace(`__${table_name}`, "").replace("lk_", "");
        const rows = res.map((item) => item.self);
        if (!effectRows[effectTableName]) {
          effectRows[effectTableName] = [];
        }
        effectRows[effectTableName] = [...effectRows[effectTableName], ...rows];
      });
      return effectRows;
    });
    __publicField(this, "getTableNodeName", async (tableName) => {
      const nodeId = getTableIdByRawTableName(tableName);
      const node = await this.dataSpace.tree.get(nodeId);
      return node?.name || "Untitled";
    });
    __publicField(this, "getPairedLinkField", async (data) => {
      const { table_name, table_column_name } = data;
      const pairedFieldProperty = {
        linkTableName: table_name,
        linkColumnName: table_column_name
      };
      const tableName = await this.getTableNodeName(table_name);
      const randomId = Math.random().toString(36).slice(2, 8);
      return {
        name: `${tableName}_${randomId}`,
        type: "link" /* Link */,
        table_name: data.property.linkTableName,
        table_column_name: data.property.linkColumnName,
        property: pairedFieldProperty
      };
    });
    __publicField(this, "getRelationTableName", (field) => {
      const { table_name, property } = field;
      return `lk_${table_name}__${property.linkTableName}`;
    });
    __publicField(this, "getParentRelationTableName", (field) => {
      const { table_name, property } = field;
      return `lk_${property.linkTableName}__${table_name}`;
    });
    __publicField(this, "getLinkCellTitle", async (field, value2) => {
      const { property } = field;
      if (!value2) {
        return null;
      }
      const rowIds = value2?.split(",") || [];
      const sql = `SELECT _id,title FROM ${property.linkTableName} WHERE _id IN (${rowIds.map(() => "?").join(",")})`;
      const bind = [...rowIds];
      const rows = await this.dataSpace.exec2(sql, bind);
      const idTitleMap = rows.reduce((acc, item) => {
        acc[item._id] = item.title;
        return acc;
      }, {});
      return rows.map((item) => idTitleMap[item._id]).join(",");
    });
    __publicField(this, "getLinkCellValue", async (field, rowIds, db2 = this.dataSpace.db) => {
      const relationTableName = this.getRelationTableName(field);
      const sql = `SELECT * FROM ${relationTableName} WHERE link_field_id = ? AND self IN (${rowIds.map(() => "?").join(",")}) ORDER BY rowid ASC`;
      const bind = [field.table_column_name, ...rowIds];
      const res = await this.dataSpace.syncExec2(sql, bind, db2);
      const groupBySelf = res.reduce(
        (acc, item) => {
          const self2 = item.self;
          if (!acc[self2]) {
            acc[self2] = [];
          }
          acc[self2].push(item.ref);
          return acc;
        },
        {}
      );
      return groupBySelf;
    });
    __publicField(this, "updateLinkCell", async (tableName, tableColumnName, rowIds) => {
      const field = await this.dataSpace.column.getColumn(
        tableName,
        tableColumnName
      );
      if (!field) return;
      const values = await this.getLinkCellValue(field, rowIds);
      rowIds.forEach(async (rowId) => {
        const value2 = values[rowId]?.join(",") || null;
        const title = await this.getLinkCellTitle(field, value2);
        this.dataSpace.db.exec({
          sql: `UPDATE ${tableName} SET ${tableColumnName} = ?, ${tableColumnName}__title = ? WHERE _id = ?`,
          bind: [value2, title, rowId]
        });
      });
      const effectFields = await this.dataSpace.reference.getEffectedFields(
        tableName,
        tableColumnName
      );
      effectFields.forEach(async (field2) => {
        this.table.fields.lookup.updateColumn({
          tableName: field2.table_name,
          tableColumnName: field2.table_column_name,
          rowIds
        });
      });
    });
    /**
     * when user setCell, we also need to update the paired link field and update relation table
     * @param field
     * @param rowId
     * @param value
     * @param oldValue
     */
    __publicField(this, "updateLinkRelation", async (field, rowId, value2, oldValue) => {
      const { added, removed } = this.getDiff(value2, oldValue);
      const relationTableName = this.getRelationTableName(field);
      const reverseRelationTableName = this.getParentRelationTableName(field);
      this.dataSpace.db.transaction(async (db2) => {
        removed.length && db2.exec({
          sql: `DELETE FROM ${relationTableName} WHERE self = ? AND ref IN (${removed.map(() => "?").join(",")})`,
          bind: [rowId, ...removed]
        });
        removed.forEach((item) => {
          db2.exec({
            sql: `DELETE FROM ${reverseRelationTableName} WHERE self = ? AND ref = ? AND link_field_id = ?`,
            bind: [item, rowId, field.property.linkColumnName]
          });
        });
        added.forEach((item) => {
          db2.exec({
            sql: `INSERT INTO ${relationTableName} (self,ref,link_field_id) VALUES (?,?,?)`,
            bind: [rowId, item, field.table_column_name]
          });
          db2.exec({
            sql: `INSERT INTO ${reverseRelationTableName} (self,ref,link_field_id) VALUES (?,?,?)`,
            bind: [item, rowId, field.property.linkColumnName]
          });
        });
      });
    });
    /**
     * when user add a link field, we also need to add a paired link field and create relation table and set trigger
     * @param data
     * @param db
     * @returns
     */
    __publicField(this, "addField", async (data, db2 = this.dataSpace.db) => {
      const { table_name, table_column_name } = data;
      const pairedField = await this.getPairedLinkField(data);
      console.log("pairedField", pairedField, data);
      this.dataSpace.syncExec2(
        `INSERT INTO ${ColumnTableName} (name,type,table_name,table_column_name,property) VALUES (?,?,?,?,?)`,
        [
          pairedField.name,
          pairedField.type,
          pairedField.table_name,
          pairedField.table_column_name,
          JSON.stringify(pairedField.property)
        ],
        db2
      );
      db2.exec(
        `ALTER TABLE ${table_name} ADD COLUMN ${table_column_name} TEXT;
        ALTER TABLE ${table_name} ADD COLUMN ${table_column_name}__title TEXT;
        ALTER TABLE ${pairedField.table_name} ADD COLUMN ${pairedField.table_column_name} TEXT;
        ALTER TABLE ${pairedField.table_name} ADD COLUMN ${pairedField.table_column_name}__title TEXT;
        `
      );
      db2.exec("PRAGMA foreign_keys = OFF;");
      await this.dataSpace.reference.add(
        {
          self_table_name: table_name,
          self_table_column_name: `${table_column_name}__title`,
          ref_table_name: pairedField.table_name,
          ref_table_column_name: "title",
          link_table_name: table_name,
          link_table_column_name: table_column_name
        },
        db2
      );
      await this.dataSpace.reference.add(
        {
          self_table_name: pairedField.table_name,
          self_table_column_name: `${pairedField.table_column_name}__title`,
          ref_table_name: table_name,
          ref_table_column_name: "title",
          link_table_name: pairedField.table_name,
          link_table_column_name: pairedField.table_column_name
        },
        db2
      );
      db2.exec("PRAGMA foreign_keys = ON;");
      const relationTableName = `lk_${table_name}__${pairedField.table_name}`;
      const reverseRelationTableName = `lk_${pairedField.table_name}__${table_name}`;
      db2.exec(
        `CREATE TABLE IF NOT EXISTS ${relationTableName} (
          self TEXT,
          ref TEXT,
          link_field_id TEXT,
          PRIMARY KEY (self,ref,link_field_id),
          FOREIGN KEY (self) REFERENCES ${table_name}(_id) ON DELETE CASCADE,
          FOREIGN KEY (ref) REFERENCES ${pairedField.table_name}(_id) ON DELETE CASCADE
        );

        CREATE TRIGGER IF NOT EXISTS data_delete_trigger_${relationTableName}
        AFTER DELETE ON ${relationTableName}
        FOR EACH ROW
        BEGIN
            SELECT eidos_data_event_delete('${relationTableName}', json_object('self',OLD.self,'ref',OLD.ref,'link_field_id',OLD.link_field_id));
        END;

        CREATE TRIGGER IF NOT EXISTS data_insert_trigger_${relationTableName}
        AFTER INSERT ON ${relationTableName}
        FOR EACH ROW
        BEGIN
            SELECT eidos_data_event_insert('${relationTableName}', json_object('self',NEW.self,'ref',NEW.ref,'link_field_id',NEW.link_field_id));
        END;

        CREATE TABLE IF NOT EXISTS ${reverseRelationTableName} (
          self TEXT,
          ref TEXT,
          link_field_id TEXT,
          PRIMARY KEY (self,ref,link_field_id),
          FOREIGN KEY (self) REFERENCES ${pairedField.table_name}(_id) ON DELETE CASCADE,
          FOREIGN KEY (ref) REFERENCES ${table_name}(_id) ON DELETE CASCADE
        );

        CREATE TRIGGER IF NOT EXISTS data_delete_trigger_${reverseRelationTableName}
        AFTER DELETE ON ${reverseRelationTableName}
        FOR EACH ROW
        BEGIN
            SELECT eidos_data_event_delete('${reverseRelationTableName}', json_object('self',OLD.self,'ref',OLD.ref,'link_field_id',OLD.link_field_id));
        END;

        CREATE TRIGGER IF NOT EXISTS data_insert_trigger_${reverseRelationTableName}
        AFTER INSERT ON ${reverseRelationTableName}
        FOR EACH ROW
        BEGIN
            SELECT eidos_data_event_insert('${reverseRelationTableName}', json_object('self',NEW.self,'ref',NEW.ref,'link_field_id',NEW.link_field_id));
        END;
        `
      );
      return db2;
    });
    this.dataSpace = this.table.dataSpace;
    this.db = this.table.db || this.dataSpace.db;
  }
  /**
   * when user delete a table, we need check if there are link fields in the table, if so, we need to delete the paired link field and delete relation table and delete trigger
   */
  async beforeDeleteTable(tableName, db2 = this.dataSpace.db) {
    const allLinkTables = await db2.selectObjects(
      `SELECT name FROM sqlite_master WHERE type='table' AND (name LIKE 'lk_${tableName}__%' OR name LIKE 'lk_%__${tableName}')`
    );
    allLinkTables.forEach(async (item) => {
      const { name: relationTableName } = item;
      const triggers = await db2.selectObjects(
        `SELECT name FROM sqlite_master WHERE type='trigger' AND tbl_name = ?`,
        [relationTableName]
      );
      triggers.forEach((item2) => {
        db2.exec(`DROP TRIGGER ${item2.name}`);
      });
      db2.exec(`DROP TABLE ${relationTableName}`);
    });
    await this.dataSpace.reference.delBy(
      {
        self_table_name: tableName
      },
      db2
    );
  }
  /**
   * when user delete a link field, we also need to delete the paired link field and delete relation data
   */
  async beforeDeleteColumn(tableName, columnName, db2 = this.dataSpace.db) {
    const field = await this.dataSpace.column.getColumn(tableName, columnName);
    if (!field) return;
    const pairedField = await this.getPairedLinkField(field);
    const relationTableName = `lk_${tableName}__${pairedField.table_name}`;
    const reverseRelationTableName = `lk_${pairedField.table_name}__${tableName}`;
    db2.exec({
      sql: `DELETE FROM ${relationTableName} WHERE link_field_id = ?`,
      bind: [columnName]
    });
    db2.exec({
      sql: `DELETE FROM ${reverseRelationTableName} WHERE link_field_id = ?`,
      bind: [pairedField.table_column_name]
    });
  }
};

// worker/web-worker/sdk/service/lookup.ts
var LookupFieldService = class {
  constructor(table) {
    this.table = table;
    __publicField(this, "dataSpace");
    /**
     * find all fields that lookup field depends on
     */
    __publicField(this, "getLookupContext", async (tableName, tableColumnName) => {
      const column = await this.dataSpace.column.getColumn(
        tableName,
        tableColumnName
      );
      if (!column) return null;
      const field = column;
      const { linkFieldId, lookupTargetFieldId } = field.property;
      const linkField = await this.dataSpace.column.getColumn(
        tableName,
        linkFieldId
      );
      if (!linkField) {
        return null;
      }
      const lookupTargetField = await this.dataSpace.column.getColumn(
        linkField.property.linkTableName,
        lookupTargetFieldId
      );
      if (!lookupTargetField) {
        return null;
      }
      let context = null;
      if (lookupTargetField.type === "lookup" /* Lookup */) {
        context = await this.getLookupContext(
          linkField.property.linkTableName,
          lookupTargetFieldId
        );
      }
      return {
        linkField,
        lookupTargetFieldsMap: {
          [getTableIdByRawTableName(linkField.property.linkTableName)]: {
            [lookupTargetFieldId]: {
              field: lookupTargetField,
              context
            }
          }
        }
      };
    });
    __publicField(this, "onPropertyChange", async (field, newProperty) => {
      if (!field) return;
      const { table_name, table_column_name } = field;
      const { linkFieldId, lookupTargetFieldId } = field.property;
      if (linkFieldId === newProperty.linkFieldId && lookupTargetFieldId === newProperty.lookupTargetFieldId) {
        return;
      }
      const oldLinkField = await this.dataSpace.column.getColumn(
        table_name,
        linkFieldId
      );
      if (!oldLinkField) return;
      let newLinkField = oldLinkField;
      if (linkFieldId !== newProperty.linkFieldId) {
        const _newLinkField = await this.dataSpace.column.getColumn(
          table_name,
          newProperty.linkFieldId
        );
        if (!_newLinkField) return;
        newLinkField = _newLinkField;
      }
      if (linkFieldId === newProperty.linkFieldId && lookupTargetFieldId !== newProperty.lookupTargetFieldId) {
        await this.dataSpace.reference.delBy({
          self_table_name: table_name,
          self_table_column_name: table_column_name,
          ref_table_name: oldLinkField.property.linkTableName,
          ref_table_column_name: lookupTargetFieldId,
          link_table_name: table_name,
          link_table_column_name: linkFieldId
        });
      }
      await this.dataSpace.reference.add({
        self_table_name: table_name,
        self_table_column_name: table_column_name,
        ref_table_name: newLinkField.property.linkTableName,
        ref_table_column_name: newProperty.lookupTargetFieldId,
        link_table_name: newLinkField.table_name,
        link_table_column_name: newLinkField.table_column_name
      });
    });
    /**
     * <linkField>__title field can be treated as a lookup field and the lookupTargetField is the title field
     */
    __publicField(this, "getLinkTitleContext", async (tableName, tableColumnName) => {
      const linkField = await this.dataSpace.column.getColumn(
        tableName,
        tableColumnName.replace("__title", "")
      );
      if (!linkField) return;
      return {
        targetTableColumnName: "title",
        targetTableName: linkField.property.linkTableName,
        linkFieldId: linkField.table_column_name
      };
    });
    __publicField(this, "_getLookupContext", async (tableName, tableColumnName) => {
      const column = await this.dataSpace.column.getColumn(
        tableName,
        tableColumnName
      );
      if (!column) return;
      const context = await this.getLookupContext(tableName, tableColumnName);
      const field = getFieldInstance(column, context);
      const targetField = field.getTargetFieldInstance();
      if (!targetField) return;
      const {
        table_column_name: targetTableColumnName,
        table_name: targetTableName
      } = targetField.column;
      return {
        targetTableColumnName,
        targetTableName,
        linkFieldId: column.property.linkFieldId
      };
    });
    __publicField(this, "getFieldContext", (tableName, tableColumnName) => {
      if (tableColumnName.endsWith("__title")) {
        return this.getLinkTitleContext(tableName, tableColumnName);
      }
      return this._getLookupContext(tableName, tableColumnName);
    });
    /**
     *
     * @param id table_column_name
     */
    __publicField(this, "updateColumn", async (data) => {
      const { tableName, tableColumnName, db: db2 = this.dataSpace.db, rowIds } = data;
      const context = await this.getFieldContext(tableName, tableColumnName);
      if (!context) return;
      const { targetTableColumnName, targetTableName, linkFieldId } = context;
      let sql = `
    UPDATE ${tableName}
    SET ${tableColumnName} = (
        SELECT GROUP_CONCAT(b.${targetTableColumnName})
        FROM ${targetTableName} as b
        WHERE ',' || ${tableName}.${linkFieldId} || ',' LIKE '%,' || b._id || ',%'
    )`;
      if (rowIds?.length) {
        sql += ` WHERE ${tableName}._id IN (${rowIds.map(() => "?").join(",")})`;
        this.dataSpace.syncExec2(sql, [...rowIds], db2);
      } else {
        this.dataSpace.syncExec2(sql, [], db2);
      }
    });
    this.dataSpace = this.table.dataSpace;
  }
};

// worker/web-worker/sdk/service/multi-select.ts
var MultiSelectFieldService = class {
  constructor(table) {
    this.table = table;
    __publicField(this, "dataSpace");
    __publicField(this, "updateFieldPropertyIfNeed", async (field, value2) => {
      const selectFieldInstance = new MultiSelectField(field);
      const cellValue = selectFieldInstance.getCellContent(value2);
      const { shouldUpdateColumnProperty } = selectFieldInstance.cellData2RawData(cellValue);
      if (shouldUpdateColumnProperty) {
        await this.dataSpace.updateColumnProperty({
          tableColumnName: field.table_column_name,
          tableName: field.table_name,
          property: selectFieldInstance.column.property,
          type: field.type
        });
      }
    });
    __publicField(this, "updateSelectOptionName", async (field, update) => {
      const { from, to } = update;
      const { table_column_name, table_name } = field;
      this.dataSpace.exec(`
    UPDATE ${table_name}
    SET ${table_column_name} = 
      CASE
        WHEN ${table_column_name} = '${from}' THEN '${to}'
        ELSE
          CASE
            WHEN instr(${table_column_name}, ',${from},') > 0 THEN replace(${table_column_name}, ',${from},', ',${to},')
            WHEN substr(${table_column_name}, 1, length('${from}')) = '${from}' THEN replace(${table_column_name}, '${from},', '${to},')
            WHEN substr(${table_column_name}, -length('${from}')) = '${from}' THEN replace(${table_column_name}, ',${from}', ',${to}')
          END
      END
    WHERE ${table_column_name} LIKE '%${from}%'
  `);
    });
    __publicField(this, "deleteSelectOption", async (field, option) => {
      const { table_column_name, table_name } = field;
      this.dataSpace.exec(`
    UPDATE ${table_name}
    SET ${table_column_name} = 
      CASE
        WHEN ${table_column_name} = '${option}' THEN NULL
        ELSE
          CASE
            WHEN instr(${table_column_name}, ',${option},') > 0 THEN replace(${table_column_name}, ',${option},', ',')
            WHEN substr(${table_column_name}, 1, length('${option}')) = '${option}' THEN replace(${table_column_name}, '${option},', '')
            WHEN substr(${table_column_name}, -length('${option}')) = '${option}' THEN replace(${table_column_name}, ',${option}', '')
          END
      END
    WHERE ${table_column_name} LIKE '%${option}%'
  `);
    });
    this.dataSpace = this.table.dataSpace;
  }
};

// worker/web-worker/sdk/service/select.ts
var _SelectFieldService = class _SelectFieldService {
  constructor(table) {
    this.table = table;
    __publicField(this, "dataSpace");
    __publicField(this, "updateFieldPropertyIfNeed", async (field, value2) => {
      const selectFieldInstance = new SelectField(field);
      const cellValue = selectFieldInstance.getCellContent(value2);
      const { shouldUpdateColumnProperty } = selectFieldInstance.cellData2RawData(cellValue);
      if (shouldUpdateColumnProperty) {
        await this.dataSpace.updateColumnProperty({
          tableColumnName: field.table_column_name,
          tableName: field.table_name,
          property: selectFieldInstance.column.property,
          type: field.type
        });
      }
    });
    __publicField(this, "updateSelectOptionName", async (field, update) => {
      const { from, to } = update;
      const { table_column_name, table_name } = field;
      this.dataSpace.exec(
        `UPDATE ${table_name} SET ${table_column_name} = '${to}' WHERE ${table_column_name} = '${from}'`
      );
    });
    __publicField(this, "deleteSelectOption", async (field, option) => {
      const { table_column_name, table_name } = field;
      this.dataSpace.exec(
        `UPDATE ${table_name} SET ${table_column_name} = NULL WHERE ${table_column_name} = '${option}'`
      );
    });
    __publicField(this, "beforeConvert", async (field, db2 = this.dataSpace.db) => {
      const { table_column_name, table_name } = field;
      const textList = await this.dataSpace.syncExec2(
        `SELECT DISTINCT ${table_column_name} FROM ${table_name}`,
        [],
        db2
      );
      const textList2 = textList.map((item) => item[table_column_name]).filter(nonNullable);
      if (textList2.length > _SelectFieldService.MAX_SELECT_OPTIONS) {
        const error = new Error(
          `The select field \u300C${field.name}\u300D in table ${table_name} has more than ${_SelectFieldService.MAX_SELECT_OPTIONS} options(${textList2.length}), please reduce the options first.`
        );
        postMessage({
          type: "Error" /* Error */,
          data: {
            message: error.message
          }
        });
        throw error;
      }
      const options = SelectField.generateOptionsByNames(textList2);
      return options;
    });
    this.dataSpace = this.table.dataSpace;
  }
};
__publicField(_SelectFieldService, "MAX_SELECT_OPTIONS", 512);
var SelectFieldService = _SelectFieldService;

// worker/web-worker/sdk/service/index.ts
var FieldsManager = class {
  constructor(table) {
    this.table = table;
    __publicField(this, "dataSpace");
    this.dataSpace = this.table.dataSpace;
    this.table = table;
  }
  get lookup() {
    return new LookupFieldService(this.table);
  }
  get select() {
    return new SelectFieldService(this.table);
  }
  get multiSelect() {
    return new MultiSelectFieldService(this.table);
  }
  get link() {
    return new LinkFieldService(this.table);
  }
};

// worker/web-worker/sdk/service/compute.ts
var ComputeService = class {
  constructor(dataSpace) {
    this.dataSpace = dataSpace;
    __publicField(this, "updateEffectCells", async (signal) => {
      const { table, rowId, diffKeys } = signal;
      const tableId = getTableIdByRawTableName(table);
      const tm = new TableManager(tableId, this.dataSpace);
      const effectRowsMap = await tm.fields.link.getEffectRows(table, [rowId]);
      const effectFields = await Promise.all(
        diffKeys.map(
          (key) => this.dataSpace.reference.getEffectedFields(table, key)
        )
      );
      const effectFieldsMap = effectFields.flat().reduce((acc, cur) => {
        if (!acc[cur.table_name]) {
          acc[cur.table_name] = [];
        }
        acc[cur.table_name].push(cur.table_column_name);
        return acc;
      }, {});
      Object.entries(effectRowsMap).forEach(([tableName, rowIds]) => {
        const tm2 = new TableManager(
          getTableIdByRawTableName(tableName),
          this.dataSpace
        );
        effectFieldsMap[tableName]?.forEach((field) => {
          tm2.fields.lookup.updateColumn({
            tableName,
            tableColumnName: field,
            rowIds
          });
        });
      });
    });
  }
};

// lib/sqlite/sql-alter-column-type.ts
var alterColumnType = (tableName, columnName, newType) => {
  return `
        ALTER TABLE ${tableName} ADD COLUMN ${columnName}_new ${newType};
        UPDATE ${tableName} SET ${columnName}_new = ${columnName};
        ALTER TABLE ${tableName} RENAME COLUMN ${columnName} TO ${columnName}_old;
        ALTER TABLE ${tableName} RENAME COLUMN ${columnName}_new TO ${columnName};
        ALTER TABLE ${tableName} DROP COLUMN ${columnName}_old;

    `;
};

// worker/web-worker/meta-table/base.ts
var BaseTableImpl = class {
  constructor(dataSpace) {
    this.dataSpace = dataSpace;
    __publicField(this, "name", "");
    __publicField(this, "JSONFields", []);
    __publicField(this, "toJson", (data) => {
      Object.entries(data).forEach(([key, value2]) => {
        if (this.JSONFields.includes(key) && value2) {
          ;
          data[key] = JSON.parse(value2);
        }
      });
      return data;
    });
    __publicField(this, "transformData", (data) => {
      const kv = Object.entries(data).map(([k, v]) => {
        if (typeof v === "object" && v != null) {
          v = JSON.stringify(v);
        }
        return [k, v];
      });
      const updateKPlaceholder = kv.map(([k, v]) => `${k} = ?`).join(", ");
      const insertKPlaceholder = kv.map(([k]) => k).join(", ");
      const insertVPlaceholder = kv.map(() => "?").join(", ");
      const deleteKPlaceholder = kv.map(([k]) => `${k} = ?`).join(" AND ");
      const values = kv.map(([, v]) => v);
      return {
        kv,
        updateKPlaceholder,
        insertKPlaceholder,
        insertVPlaceholder,
        deleteKPlaceholder,
        values
      };
    });
  }
  initTable(createTableSql) {
    this.dataSpace.exec(createTableSql);
  }
  async del(id, db2 = this.dataSpace.db) {
    this.dataSpace.syncExec2(`DELETE FROM ${this.name} WHERE id = ?;`, [id], db2);
    return true;
  }
  async delBy(data, db2 = this.dataSpace.db) {
    const { deleteKPlaceholder, values } = this.transformData(data);
    this.dataSpace.syncExec2(
      `DELETE FROM ${this.name} WHERE ${deleteKPlaceholder};`,
      values,
      db2
    );
    return true;
  }
  async get(id) {
    const res = await this.dataSpace.exec2(
      `SELECT * FROM ${this.name} where id = ?;`,
      [id]
    );
    if (res.length === 0) {
      return null;
    }
    const item = res[0];
    return this.toJson(item);
  }
  async add(data, db2 = this.dataSpace.db) {
    const { insertKPlaceholder, insertVPlaceholder, values } = this.transformData(data);
    this.dataSpace.syncExec2(
      `INSERT INTO ${this.name} (${insertKPlaceholder}) VALUES (${insertVPlaceholder});`,
      values,
      db2
    );
    return data;
  }
  async set(id, data) {
    const { updateKPlaceholder, values } = this.transformData(data);
    await this.dataSpace.exec2(
      `UPDATE ${this.name} SET ${updateKPlaceholder} WHERE id = ?`,
      [...values, id]
    );
    return true;
  }
  async list(query, opts) {
    let res = [];
    let sql = `SELECT ${opts?.fields?.join(", ") || "*"} FROM ${this.name}`;
    let setV = [];
    if (query && Object.keys(query).length > 0) {
      const kv = Object.entries(query);
      const setK = kv.map(([k, v]) => {
        if (v == null) {
          return `${k} IS NULL`;
        }
        return `${k} = ?`;
      }).join(" AND ");
      setV = kv.filter(([, v]) => v != null).map(([, v]) => v);
      sql += ` WHERE ${setK}`;
    }
    if (opts?.orderBy) {
      sql += ` ORDER BY ${opts.orderBy} ${opts.order || "ASC"}`;
    }
    if (opts?.limit) {
      sql += ` LIMIT ${opts.limit}`;
    }
    if (opts?.offset) {
      sql += ` OFFSET ${opts.offset}`;
    }
    sql += ";";
    res = await this.dataSpace.exec2(sql, setV);
    return res.map((item) => {
      return this.toJson(item);
    });
  }
};

// worker/web-worker/meta-table/column.ts
var bc = new EventEmitter(EidosDataEventChannelName);
var ColumnTable = class _ColumnTable extends BaseTableImpl {
  constructor() {
    super(...arguments);
    __publicField(this, "name", ColumnTableName);
    __publicField(this, "createTableSql", `
  CREATE TABLE IF NOT EXISTS ${ColumnTableName} (
    name TEXT,
    type TEXT,
    table_name TEXT,
    table_column_name TEXT,
    property TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(table_name, table_column_name)
  );

  CREATE TRIGGER IF NOT EXISTS column_insert_trigger_${ColumnTableName}
  AFTER INSERT ON ${ColumnTableName}
  FOR EACH ROW
  BEGIN
      SELECT eidos_column_event_insert(new.table_name, json_object('name', new.name, 'type', new.type, 'table_name', new.table_name, 'table_column_name', new.table_column_name, 'property', new.property));
  END;

  CREATE TRIGGER IF NOT EXISTS column_update_trigger_${ColumnTableName}
  AFTER UPDATE ON ${ColumnTableName}
  FOR EACH ROW
  BEGIN
      SELECT eidos_column_event_update(new.table_name, json_object('name', new.name, 'type', new.type, 'table_name', new.table_name, 'table_column_name', new.table_column_name, 'property', new.property), json_object('name', old.name, 'type', old.type, 'table_name', old.table_name, 'table_column_name', old.table_column_name, 'property', old.property));
  END;
`);
    __publicField(this, "JSONFields", ["property"]);
  }
  static getColumnTypeByFieldType(type) {
    const typeMap = {
      ["checkbox" /* Checkbox */]: "BOOLEAN",
      ["number" /* Number */]: "REAL",
      ["rating" /* Rating */]: "INT"
    };
    const columnType = typeMap[type] ?? "TEXT";
    return columnType;
  }
  async add(data) {
    const { name: name2, type, table_name, table_column_name, property } = data;
    const columnType = _ColumnTable.getColumnTypeByFieldType(type);
    const tableId = getTableIdByRawTableName(table_name);
    await this.dataSpace.db.transaction(async (db2) => {
      let _property = property;
      if (type === "formula" /* Formula */) {
        _property = { formula: "upper(title)" };
      }
      this.dataSpace.syncExec2(
        `INSERT INTO ${ColumnTableName} (name,type,table_name,table_column_name,property) VALUES (?,?,?,?,?)`,
        [name2, type, table_name, table_column_name, JSON.stringify(_property)],
        db2
      );
      switch (type) {
        case "created-by" /* CreatedBy */:
          this.dataSpace.syncExec2(
            `ALTER TABLE ${table_name} ADD COLUMN ${table_column_name} GENERATED ALWAYS AS (_created_by);`,
            [],
            db2
          );
          break;
        case "last-edited-by" /* LastEditedBy */:
          this.dataSpace.syncExec2(
            `ALTER TABLE ${table_name} ADD COLUMN ${table_column_name} GENERATED ALWAYS AS (_last_edited_by);`,
            [],
            db2
          );
          break;
        case "last-edited-time" /* LastEditedTime */:
          this.dataSpace.syncExec2(
            `ALTER TABLE ${table_name} ADD COLUMN ${table_column_name} GENERATED ALWAYS AS (_last_edited_time);`,
            [],
            db2
          );
          break;
        case "created-time" /* CreatedTime */:
          this.dataSpace.syncExec2(
            `ALTER TABLE ${table_name} ADD COLUMN ${table_column_name} GENERATED ALWAYS AS (_created_time);`,
            [],
            db2
          );
          break;
        case "formula" /* Formula */:
          this.dataSpace.syncExec2(
            `ALTER TABLE ${table_name} ADD COLUMN ${table_column_name} GENERATED ALWAYS AS (upper(title));`,
            [],
            db2
          );
          break;
        case "link" /* Link */:
          const tm = new TableManager(tableId, this.dataSpace);
          await tm.fields.link.addField(data, db2);
          break;
        default:
          this.dataSpace.syncExec2(
            `ALTER TABLE ${table_name} ADD COLUMN ${table_column_name} ${columnType};`,
            [],
            db2
          );
          break;
      }
    });
    return data;
  }
  async addField(data) {
    const res = await this.add(data);
    await this.dataSpace.onTableChange(this.dataSpace.dbName, data.table_name);
    return res;
  }
  async getColumn(tableName, tableColumnName) {
    const res = await this.dataSpace.exec2(
      `SELECT * FROM ${ColumnTableName} WHERE table_name=? AND table_column_name=?`,
      [tableName, tableColumnName]
    );
    if (res.length === 0) return null;
    return this.toJson(res[0]);
  }
  set(id, data) {
    throw new Error("Method not implemented.");
  }
  del(id) {
    throw new Error("Method not implemented.");
  }
  async deleteField(tableName, tableColumnName) {
    const effectTables = [tableName];
    try {
      await this.dataSpace.db.transaction(async (db2) => {
        const _deleteField = async (tableName2, tableColumnName2) => {
          await this.dataSpace.tableFullTextSearch.updateTrigger(tableName2, [tableColumnName2]);
          await this.dataSpace.onTableChange(this.dataSpace.dbName, tableName2, [
            tableColumnName2
          ]);
          this.dataSpace.syncExec2(
            `DELETE FROM ${ColumnTableName} WHERE table_column_name = ? AND table_name = ?;`,
            [tableColumnName2, tableName2],
            db2
          );
          this.dataSpace.syncExec2(
            `ALTER TABLE ${tableName2} DROP COLUMN ${tableColumnName2};`,
            [],
            db2
          );
        };
        const column = await this.getColumn(tableName, tableColumnName);
        if (column?.type === "link" /* Link */) {
          const tm = new TableManager(
            getTableIdByRawTableName(tableName),
            this.dataSpace
          );
          const pairedField = await tm.fields.link.getPairedLinkField(column);
          effectTables.push(pairedField.table_name);
          await tm.fields.link.beforeDeleteColumn(
            tableName,
            tableColumnName,
            db2
          );
          await _deleteField(
            pairedField.table_name,
            pairedField.table_column_name
          );
        }
        await _deleteField(tableName, tableColumnName);
      });
    } catch (error) {
      console.error(error);
      this.dataSpace.notify({
        title: "Error",
        description: "Failed to delete column, because it is referenced by other fields"
      });
    }
    return effectTables;
  }
  /**
   * @param tableName tb_<uuid>
   */
  async deleteByRawTableName(tableName, db2 = this.dataSpace.db) {
    this.dataSpace.syncExec2(
      `DELETE FROM ${ColumnTableName} WHERE table_name=?;`,
      [tableName],
      db2
    );
  }
  async updateProperty(data) {
    const { tableName, tableColumnName, property, type } = data;
    await this.dataSpace.db.transaction(async (D2) => {
      const oldField = await this.getColumn(tableName, tableColumnName);
      if (!oldField) return;
      await this.dataSpace.sql`UPDATE ${Symbol(
        ColumnTableName
      )} SET property = ${JSON.stringify(
        property
      )} WHERE table_column_name = ${tableColumnName} AND table_name = ${tableName};`;
      switch (type) {
        case "lookup" /* Lookup */:
          const tm = new TableManager(
            getTableIdByRawTableName(tableName),
            this.dataSpace
          );
          await tm.fields.lookup.onPropertyChange(oldField, property);
          break;
        case "link" /* Link */:
          const field = await this.getColumn(
            tableName,
            tableColumnName
          );
          const newLinkTable = property.linkTableName;
          const oldLinkTable = field?.property.linkTableName;
          if (oldLinkTable !== newLinkTable) {
            console.log("update link title column");
          }
          break;
        case "formula" /* Formula */:
          const fields = await this.list({ table_name: tableName });
          const formulaExpr = transformFormula2VirtualGeneratedField(
            tableColumnName,
            fields
          );
          D2.exec(
            `
            ALTER TABLE ${tableName} DROP COLUMN ${tableColumnName};
            ALTER TABLE ${tableName} ADD COLUMN ${tableColumnName} GENERATED ALWAYS AS ${formulaExpr};
            `
          );
          bc.postMessage({
            type: "DataUpdateSignalType" /* DataUpdateSignalType */,
            payload: {
              type: "updateColumn" /* UpdateColumn */,
              table: tableName,
              column: data
            }
          });
          break;
        default:
          break;
      }
    });
  }
  async list(q) {
    const res = await super.list(q);
    return res.filter((col) => !col.table_column_name.startsWith("_"));
  }
  static isColumnTypeChanged(oldType, newType) {
    return _ColumnTable.getColumnTypeByFieldType(oldType) !== _ColumnTable.getColumnTypeByFieldType(newType);
  }
  async changeType(tableName, tableColumnName, newType) {
    const defaultFieldProperty = allFieldTypesMap[newType].getDefaultFieldProperty();
    let newProperty = defaultFieldProperty;
    const field = await this.getColumn(
      tableName,
      tableColumnName
    );
    if (!field) return;
    const oldColumnType = _ColumnTable.getColumnTypeByFieldType(field.type);
    const newColumnType = _ColumnTable.getColumnTypeByFieldType(newType);
    const isColumnTypeChanged = oldColumnType !== newColumnType;
    await this.dataSpace.db.transaction(async (db2) => {
      if (isColumnTypeChanged) {
        this.dataSpace.blockUIMsg("Changing column type");
        await this.dataSpace.dataChangeTrigger.unRegisterTrigger(
          this.dataSpace.dbName,
          tableName
        );
        if (this.dataSpace.activeUndoManager) {
          this.dataSpace.undoRedoManager.deactivate();
        }
        let sql = `DROP TRIGGER IF EXISTS data_update_trigger_${tableName};
        DROP TRIGGER IF EXISTS data_insert_trigger_${tableName};
        DROP TRIGGER IF EXISTS data_delete_trigger_${tableName};`;
        sql += `DROP INDEX IF EXISTS ${getColumnIndexName(
          tableName,
          tableColumnName
        )};`;
        sql += alterColumnType(tableName, tableColumnName, newColumnType);
        this.dataSpace.syncExec2(sql, [], db2);
      }
      switch (newType) {
        case "multi-select" /* MultiSelect */:
        case "select" /* Select */:
          const tm = new TableManager(
            getTableIdByRawTableName(tableName),
            this.dataSpace
          );
          const options = await tm.fields.select.beforeConvert(field, db2);
          newProperty = {
            ...defaultFieldProperty,
            options
          };
          break;
        default:
          break;
      }
      this.dataSpace.syncExec2(
        `UPDATE ${ColumnTableName} SET type = ?, property = ? WHERE table_column_name = ? AND table_name = ?;`,
        [newType, JSON.stringify(newProperty), tableColumnName, tableName],
        db2
      );
    });
    this.dataSpace.blockUIMsg(null);
    if (isColumnTypeChanged) {
      const collist = await this.dataSpace.listRawColumns(tableName);
      await this.dataSpace.dataChangeTrigger.setTrigger(
        this.dataSpace,
        tableName,
        collist
      );
    }
  }
};

// worker/web-worker/sdk/table.ts
var TableManager = class {
  constructor(id, dataSpace) {
    this.id = id;
    this.dataSpace = dataSpace;
    // table name in sqlite
    __publicField(this, "rawTableName");
    __publicField(this, "db");
    this.rawTableName = getRawTableNameById(id);
    this.db = dataSpace.db;
  }
  get compute() {
    return new ComputeService(this.dataSpace);
  }
  get rows() {
    return new RowsManager(this);
  }
  get fields() {
    return new FieldsManager(this);
  }
  get index() {
    return new IndexManager(this);
  }
  async isExist(id) {
    const tableNode = await this.dataSpace.getTreeNode(id);
    return Boolean(tableNode);
  }
  async get(id) {
    const views = await this.dataSpace.listViews(id);
    const tableNode = await this.dataSpace.getTreeNode(id);
    if (!tableNode) {
      return null;
    }
    return {
      id: tableNode.id,
      name: tableNode.name,
      views
    };
  }
  async del(id) {
    const rawTableName = `tb_${id}`;
    await this.dataSpace.db.transaction(async (db2) => {
      this.fields.link.beforeDeleteTable(rawTableName, db2);
      db2.exec(`DROP TABLE ${rawTableName}`);
      await this.dataSpace.column.deleteByRawTableName(rawTableName, db2);
      await this.dataSpace.view.deleteByTableId(id, db2);
      await this.dataSpace.tree.del(id, db2);
      if (isDesktopMode) {
        await this.dataSpace.tableFullTextSearch.clearFTS(rawTableName);
        await this.dataSpace.tableFullTextSearch.dropFTS(rawTableName);
      }
    });
    return true;
  }
  async hasSystemColumn(tableId, column) {
    const res = await this.dataSpace.exec2(`PRAGMA table_info(tb_${tableId})`);
    const columns = res.map((item) => item.name);
    return columns.includes(column);
  }
  // we add system columns to table, but old tables don't have these columns, so we need to fix them.
  async fixTable(tableId) {
    const hasSystemColumn = await this.hasSystemColumn(tableId, "_created_time");
    if (!hasSystemColumn) {
      const createTableSqlRes = await this.dataSpace.exec2(
        `SELECT sql FROM sqlite_master WHERE type='table' AND name='tb_${tableId}'`
      );
      const createTableSql = createTableSqlRes[0].sql;
      const { sql } = generateMergeTableWithNewColumnsSql(
        createTableSql,
        `
      _created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      _last_edited_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      _created_by TEXT DEFAULT 'unknown',
      _last_edited_by TEXT DEFAULT 'unknown'
  `
      );
      console.log(sql);
      const res = await this.dataSpace.exec2(sql);
      console.log(res);
    }
  }
  static generateCreateTableSql(fields) {
    const tableId = v4_default().split("-").join("");
    const rawTableName = getRawTableNameById(tableId);
    const fieldsWithoutTitle = fields.filter((field) => field.name.toLowerCase() !== "title");
    const rawColumns = fieldsWithoutTitle.map((_, index) => generateColumnName());
    let createTableSql = `
CREATE TABLE ${rawTableName} (
  _id TEXT PRIMARY KEY NOT NULL,
  title TEXT NULL,
  _created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  _last_edited_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  _created_by TEXT DEFAULT 'unknown',
  _last_edited_by TEXT DEFAULT 'unknown',
`;
    rawColumns.forEach((column, index) => {
      const field = fieldsWithoutTitle[index];
      const sqlType = ColumnTable.getColumnTypeByFieldType(field.type);
      const isLastColumn = index === rawColumns.length - 1;
      createTableSql += `${column} ${sqlType} NULL` + (isLastColumn ? "\n" : ",\n");
    });
    createTableSql += `);`;
    createTableSql += `
    --- insert ui-column to table
    INSERT INTO ${ColumnTableName}(name, type, table_name, table_column_name) VALUES ('_id', 'row-id', '${rawTableName}', '_id');
    INSERT INTO ${ColumnTableName}(name, type, table_name, table_column_name) VALUES ('title', 'title', '${rawTableName}', 'title');
    `;
    fieldsWithoutTitle.forEach((field, index) => {
      const rawColumn = rawColumns[index];
      const escapedName = field.name.replace(/'/g, "''");
      createTableSql += `INSERT INTO ${ColumnTableName}(name, type, table_name, table_column_name) VALUES ('${escapedName}', '${field.type}', '${rawTableName}', '${rawColumn}');`;
    });
    return {
      tableId,
      createTableSql
    };
  }
};

// worker/web-worker/data-pipeline/DataChangeEventHandler.ts
var bc2 = new EventEmitter(EidosDataEventChannelName);
var _DataChangeEventHandler = class _DataChangeEventHandler {
  constructor(dataSpace) {
    this.dataSpace = dataSpace;
    __publicField(this, "handleLinkRelationChange", async (data) => {
      const { table, _old, _new } = data;
      const tableId = getTableIdByRawTableName(table);
      const tm = new TableManager(tableId, this.dataSpace);
      const res = await tm.fields.link.getEffectRowsByRelationDeleted(
        table,
        _old || _new
      );
      Object.entries(res).forEach(([tableName, fieldRowIdsMap]) => {
        Object.entries(fieldRowIdsMap).forEach(([k, v]) => {
          Array.from(v).forEach((rowId) => {
            this.dataSpace.linkRelationUpdater.addCell(tableName, k, rowId);
          });
        });
      });
    });
    bc2.onmessage = async (e) => {
      const { type, payload } = e.data;
      if (type === "DataUpdateSignalType" /* DataUpdateSignalType */) {
        const { _new, _old, table } = payload;
        if (table.startsWith("lk_")) {
          switch (payload.type) {
            case "insert" /* Insert */:
            case "delete" /* Delete */:
              this.handleLinkRelationChange({
                table,
                _old,
                _new
              });
              break;
            default:
              break;
          }
          return;
        }
        switch (payload.type) {
          case "insert" /* Insert */:
          case "update" /* Update */:
            const diff = _DataChangeEventHandler.getDiff(_old, _new);
            const diffKeys = Object.keys(diff);
            const updateSignal = {
              table,
              rowId: _new._id,
              diff,
              diffKeys
            };
            if (diffKeys.length === 0) {
              return;
            }
            const tableId = getTableIdByRawTableName(table);
            const tm = new TableManager(tableId, this.dataSpace);
            await tm.compute.updateEffectCells(updateSignal);
            break;
          case "delete" /* Delete */:
            break;
          default:
            break;
        }
      }
    };
  }
};
__publicField(_DataChangeEventHandler, "getDiff", (oldData, newData) => {
  const diff = {};
  Object.entries(newData).forEach(([k, v]) => {
    if (oldData?.hasOwnProperty(k) && oldData[k] !== v) {
      diff[k] = { old: oldData[k], new: v };
    }
    if (!oldData?.hasOwnProperty(k)) {
      diff[k] = { old: void 0, new: v };
    }
  });
  return diff;
});
var DataChangeEventHandler = _DataChangeEventHandler;

// worker/web-worker/data-pipeline/DataChangeTrigger.ts
var DataChangeTrigger = class {
  constructor() {
    // space::table =>
    __publicField(this, "triggerMap");
    this.triggerMap = /* @__PURE__ */ new Map();
  }
  getRowJSONObj(collist, type) {
    let json_object = "json_object(";
    for (const col of collist) {
      const name2 = col.name;
      json_object += `'${name2}', ${type}.${name2}, `;
    }
    json_object += `'rowid', ${type}.rowid)`;
    return json_object;
  }
  async registerTrigger(space2, tableName, trigger) {
    const key = `${space2}::${tableName}`;
    this.triggerMap.set(key, trigger);
  }
  async unRegisterTrigger(space2, tableName) {
    const key = `${space2}::${tableName}`;
    this.triggerMap.delete(key);
  }
  isTriggerChanged(space2, tableName, trigger) {
    const key = `${space2}::${tableName}`;
    const oldTrigger = this.triggerMap.get(key);
    if (!oldTrigger) {
      return true;
    }
    return oldTrigger.update !== trigger.update || oldTrigger.insert !== trigger.insert || oldTrigger.delete !== trigger.delete;
  }
  async setTrigger(dataspace, tableName, collist, toDeleteColumns) {
    console.log("setTrigger", tableName);
    const _collist = collist.filter((col) => {
      if (toDeleteColumns) {
        return !toDeleteColumns.includes(col.name);
      }
      return true;
    });
    const new_json_object = this.getRowJSONObj(_collist, "new");
    const old_json_object = this.getRowJSONObj(_collist, "old");
    const updateSql = `CREATE TEMP TRIGGER data_update_trigger_${tableName}
    AFTER UPDATE ON ${tableName}
    FOR EACH ROW
    BEGIN
        SELECT eidos_data_event_update('${tableName}', ${new_json_object}, ${old_json_object});
    END;`;
    const insertSql = `CREATE TEMP TRIGGER data_insert_trigger_${tableName}
    AFTER INSERT ON ${tableName}
    FOR EACH ROW
    BEGIN
        SELECT eidos_data_event_insert('${tableName}', ${new_json_object});
    END;`;
    const deleteSql = `CREATE TEMP TRIGGER data_delete_trigger_${tableName}
    AFTER DELETE ON ${tableName}
    FOR EACH ROW
    BEGIN
        SELECT eidos_data_event_delete('${tableName}', ${old_json_object});
    END;`;
    if (!this.isTriggerChanged(dataspace.dbName, tableName, {
      update: updateSql,
      insert: insertSql,
      delete: deleteSql
    })) {
      return;
    }
    dataspace.db.transaction((db2) => {
      db2.exec(`DROP TRIGGER IF EXISTS data_update_trigger_${tableName}`);
      db2.exec(`DROP TRIGGER IF EXISTS data_insert_trigger_${tableName}`);
      db2.exec(`DROP TRIGGER IF EXISTS data_delete_trigger_${tableName}`);
      db2.exec(updateSql);
      db2.exec(insertSql);
      db2.exec(deleteSql);
    });
    this.registerTrigger(dataspace.dbName, tableName, {
      update: updateSql,
      insert: insertSql,
      delete: deleteSql
    });
  }
};

// worker/web-worker/data-pipeline/LinkRelationUpdater.ts
var LinkRelationUpdater = class {
  constructor(dataSpace, setInterval) {
    this.dataSpace = dataSpace;
    __publicField(this, "needUpdateCell");
    __publicField(this, "updateCells", async () => {
      for (const tableName in this.needUpdateCell) {
        console.log("updateCells", tableName);
        const tableId = getTableIdByRawTableName(tableName);
        const tm = new TableManager(tableId, this.dataSpace);
        for (const tableColumnName in this.needUpdateCell[tableName]) {
          const rowIds = Array.from(
            this.needUpdateCell[tableName][tableColumnName]
          );
          await tm.fields.link.updateLinkCell(tableName, tableColumnName, rowIds);
        }
      }
      this.needUpdateCell = {};
    });
    __publicField(this, "addCell", (tableName, tableColumnName, rowId) => {
      if (!this.needUpdateCell[tableName]) {
        this.needUpdateCell[tableName] = {};
      }
      if (!this.needUpdateCell[tableName][tableColumnName]) {
        this.needUpdateCell[tableName][tableColumnName] = /* @__PURE__ */ new Set();
      }
      this.needUpdateCell[tableName][tableColumnName].add(rowId);
      console.log("addCell", this.needUpdateCell);
    });
    this.needUpdateCell = {};
    setInterval && setInterval(() => {
      this.updateCells();
    }, 100);
  }
};

// worker/web-worker/data-pipeline/UndoRedo.ts
var SQLiteUndoRedo = class {
  constructor(db2) {
    __publicField(this, "undo");
    __publicField(this, "db");
    __publicField(this, "triggerNames", []);
    this.db = db2;
    this.undo = {
      active: false,
      undostack: [],
      redostack: [],
      firstlog: 1
    };
  }
  activate(tables) {
    if (this.undo.active) return;
    this.deactivate();
    this.createTriggers(this.db, tables);
    this.undo.active = true;
    this.undo.undostack = [];
    this.undo.redostack = [];
    this.undo.freeze = -1;
    this._start_interval();
  }
  deactivate() {
    if (!this.undo.active) return;
    this._drop_triggers();
    this.undo.undostack = [];
    this.undo.redostack = [];
    this.undo.active = false;
    this.undo.freeze = -1;
  }
  freeze() {
    if (!this.undo.freeze) return;
    if (this.undo.freeze >= 0)
      throw new Error("recursive call to SQLiteUndoRedo.freeze");
    this.undo.freeze = this.db?.execute("SELECT coalesce(max(seq),0) FROM undolog").fetchone()[0];
  }
  unfreeze() {
    if (!this.undo.freeze) return;
    if (this.undo.freeze < 0)
      throw new Error("called unfreeze while not frozen");
    this.db.exec(`DELETE FROM undolog WHERE seq > ?`, [this.undo.freeze]);
    this.undo.freeze = -1;
  }
  // when any table is modified, this function is called
  event() {
    if (!this.undo.pending) {
      this.undo.pending = setTimeout(() => this.barrier(), 300);
    }
  }
  async barrier() {
    clearTimeout(this.undo.pending);
    this.undo.pending = void 0;
    if (!this.undo.active) {
      this.refresh();
      return;
    }
    const end = this.db.execute("SELECT coalesce(max(seq),0) FROM undolog").fetchone()[0];
    this.undo.undostack.push({
      begin: this.undo.firstlog,
      end
    });
    this._start_interval();
    this.refresh();
  }
  callUndo() {
    logger.info("undo");
    this._step(this.undo.undostack, this.undo.redostack);
  }
  callRedo() {
    logger.info("redo");
    this._step(this.undo.redostack, this.undo.undostack);
  }
  refresh() {
  }
  reload_all() {
    const body = [];
    logger.info("not implemented, but should be");
  }
  async _makeTriggersForTbl(db2, tbl) {
    const collist = await db2.sql`pragma table_info(${Symbol(tbl)})`;
    let sql = `CREATE TEMP TRIGGER _${tbl}_it AFTER INSERT ON ${tbl} BEGIN
`;
    sql += "  INSERT INTO undolog VALUES(NULL,";
    sql += `'DELETE FROM ${tbl} WHERE rowid='||new.rowid);
END;
`;
    sql += `CREATE TEMP TRIGGER _${tbl}_ut AFTER UPDATE ON ${tbl} BEGIN
`;
    sql += "  INSERT INTO undolog VALUES(NULL,";
    sql += `'UPDATE ${tbl} `;
    let sep = "SET ";
    for (const column of collist) {
      const name2 = column[1];
      sql += `${sep}${name2}='||quote(old.${name2})||'`;
      sep = ",";
    }
    sql += ` WHERE rowid='||old.rowid);
END;
`;
    sql += `CREATE TEMP TRIGGER _${tbl}_dt BEFORE DELETE ON ${tbl} BEGIN
`;
    sql += "  INSERT INTO undolog VALUES(NULL,";
    sql += `'INSERT INTO ${tbl}(rowid`;
    for (const column of collist) {
      const name2 = column[1];
      sql += `,${name2}`;
    }
    sql += `) VALUES('||old.rowid||'`;
    for (const column of collist) {
      const name2 = column[1];
      sql += `,'||quote(old.${name2})||'`;
    }
    sql += `)');
END;
`;
    logger.debug(`Creating triggers for ${tbl}`, sql);
    return sql;
  }
  async createTriggers(db2, tables) {
    try {
      db2.exec("DROP TABLE IF EXISTS undolog");
    } catch (err) {
    }
    db2.exec("CREATE TEMP TABLE undolog(seq integer primary key, sql text)");
    for (const tbl of tables) {
      try {
        const sql = await this._makeTriggersForTbl(db2, tbl);
        db2.exec(sql);
        this.triggerNames.push(`_${tbl}_it`);
        this.triggerNames.push(`_${tbl}_ut`);
        this.triggerNames.push(`_${tbl}_dt`);
      } catch (error) {
        logger.info(`Error creating triggers for ${tbl}`, error);
      }
    }
  }
  _drop_triggers() {
    for (const triggerName of this.triggerNames) {
      this.db.exec(`DROP TRIGGER IF EXISTS ${triggerName}`);
    }
  }
  _start_interval() {
    const begin = this.db.execute("SELECT coalesce(max(seq),0)+1 FROM undolog").fetchone()[0];
    if (begin > this.undo.firstlog) {
      this.undo.firstlog = begin;
    }
  }
  _step(from, to) {
    if (from.length === 0) return;
    const { begin, end } = from.pop();
    const newBegin = this.db.execute("SELECT coalesce(max(seq),0)+1 FROM undolog").fetchone()[0];
    const q1 = `SELECT sql FROM undolog WHERE seq>=${begin} AND seq<=${end} ORDER BY seq DESC`;
    const rows = this.db.execute(q1).fetchall();
    const sql = rows.map((row) => row[0]).join(";\n");
    this.db.exec(sql);
    const newEnd = this.db.execute("SELECT coalesce(max(seq),0) FROM undolog").fetchone()[0];
    to.push({
      begin: newBegin,
      end: newEnd
    });
    this.db.onUpdate();
  }
};

// worker/web-worker/db-migrator/DbMigrator.ts
var DbMigrator = class {
  constructor(db2, draftDb, allowDeletions = false) {
    this.db = db2;
    this.draftDb = draftDb;
    this.allowDeletions = allowDeletions;
  }
  async compareTables() {
    const tables = await this.db.syncExec2(
      `select * from sqlite_schema where type='table' AND name  like 'eidos__%';`
    );
    const draftTables = await this.draftDb.syncExec2(
      `select * from sqlite_schema where type='table' AND name  like 'eidos__%';`
    );
    const newTables = draftTables.filter((draftTable) => {
      const table = tables.find((table2) => table2.name === draftTable.name);
      return !table;
    });
    const removedTables = tables.filter((table) => {
      const draftTable = draftTables.find(
        (draftTable2) => draftTable2.name === table.name
      );
      return !draftTable;
    });
    return {
      tables,
      newTables,
      removedTables
    };
  }
  async compareColumns(tableName) {
    const columns = await this.db.syncExec2(
      `PRAGMA table_info(${tableName});`
    );
    const draftColumns = await this.draftDb.syncExec2(
      `PRAGMA table_info(${tableName});`
    );
    const newColumns = draftColumns.filter((draftColumn) => {
      const column = columns.find(
        (column2) => column2.name.toLocaleLowerCase() === draftColumn.name.toLocaleLowerCase()
      );
      return !column;
    });
    const removedColumns = columns.filter((column) => {
      const draftColumn = draftColumns.find(
        (draftColumn2) => draftColumn2.name === column.name
      );
      return !draftColumn;
    });
    return {
      newColumns,
      removedColumns
    };
  }
  async migrateTables() {
    const { newTables, removedTables } = await this.compareTables();
    return { newTables, removedTables };
  }
  async migrateTable(tableName) {
    const { newColumns, removedColumns } = await this.compareColumns(tableName);
    newColumns.length && console.log(`migrateTable ${tableName} start`);
    for (const newColumn of newColumns) {
      const { name: name2, type, notnull, dflt_value } = newColumn;
      let sql = `ALTER TABLE ${tableName} ADD COLUMN `;
      let columnDefineSql = ` ${name2} ${type}`;
      if (dflt_value != null) {
        columnDefineSql += ` DEFAULT ${dflt_value}`;
      }
      if (notnull) {
        columnDefineSql += " NOT NULL ";
      }
      sql += columnDefineSql;
      try {
        console.log(sql);
        this.db.syncExec2(sql);
        console.log(`migrateTable ${tableName} add column ${name2}`);
      } catch (error) {
        if (error.message.includes(
          "Cannot add a column with non-constant default"
        )) {
          console.warn(`migrateTable ${tableName} add column ${name2} failed`);
          const createTableSqlRes = this.db.syncExec2(
            `SELECT sql FROM sqlite_master WHERE type='table' AND name='${tableName}'`
          );
          const createTableSql = createTableSqlRes[0].sql;
          const newSql = generateMergeTableWithNewColumnsSql(
            createTableSql,
            columnDefineSql
          );
          console.log("use newSql to migrate", newSql.sql);
          this.db.syncExec2(newSql.sql);
        } else {
          console.log(error);
        }
      }
    }
    newColumns.length && console.log(`migrateTable ${tableName} done`);
  }
  async migrate() {
    if (this.db.hasMigrated) {
      console.log("db has migrated");
      return;
    }
    const { removedTables } = await this.migrateTables();
    const tables = await this.db.syncExec2(
      `select * from sqlite_schema where type='table' AND name  like 'eidos__%';`
    );
    for (const table of tables) {
      const isRemovedTable = removedTables.find(
        (removedTable) => removedTable.name === table.name
      );
      if (!isRemovedTable) {
        await this.migrateTable(table.name);
      }
    }
    this.cleanDraftDb();
  }
  async cleanDraftDb() {
    this.draftDb.db.close();
  }
};

// worker/web-worker/helper.ts
function timeit(threshold) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = function(...args) {
      const start = performance.now();
      const result = originalMethod.apply(this, args);
      const end = performance.now();
      const duration = end - start;
      if (duration > threshold) {
        console.debug(
          `%cCall to ${propertyKey} took ${duration} milliseconds with args:`,
          "color: purple; font-weight: bold;",
          args
        );
      } else {
      }
      return result;
    };
    return descriptor;
  };
}

// worker/web-worker/import-and-export/base.ts
var BaseImportAndExport = class {
};

// node_modules/.pnpm/csv-parse@5.5.6/node_modules/csv-parse/lib/api/CsvError.js
var CsvError = class _CsvError extends Error {
  constructor(code, message, options, ...contexts) {
    if (Array.isArray(message)) message = message.join(" ").trim();
    super(message);
    if (Error.captureStackTrace !== void 0) {
      Error.captureStackTrace(this, _CsvError);
    }
    this.code = code;
    for (const context of contexts) {
      for (const key in context) {
        const value2 = context[key];
        this[key] = Buffer.isBuffer(value2) ? value2.toString(options.encoding) : value2 == null ? value2 : JSON.parse(JSON.stringify(value2));
      }
    }
  }
};

// node_modules/.pnpm/csv-parse@5.5.6/node_modules/csv-parse/lib/utils/is_object.js
var is_object = function(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
};

// node_modules/.pnpm/csv-parse@5.5.6/node_modules/csv-parse/lib/api/normalize_columns_array.js
var normalize_columns_array = function(columns) {
  const normalizedColumns = [];
  for (let i = 0, l = columns.length; i < l; i++) {
    const column = columns[i];
    if (column === void 0 || column === null || column === false) {
      normalizedColumns[i] = { disabled: true };
    } else if (typeof column === "string") {
      normalizedColumns[i] = { name: column };
    } else if (is_object(column)) {
      if (typeof column.name !== "string") {
        throw new CsvError("CSV_OPTION_COLUMNS_MISSING_NAME", [
          "Option columns missing name:",
          `property "name" is required at position ${i}`,
          "when column is an object literal"
        ]);
      }
      normalizedColumns[i] = column;
    } else {
      throw new CsvError("CSV_INVALID_COLUMN_DEFINITION", [
        "Invalid column definition:",
        "expect a string or a literal object,",
        `got ${JSON.stringify(column)} at position ${i}`
      ]);
    }
  }
  return normalizedColumns;
};

// node_modules/.pnpm/csv-parse@5.5.6/node_modules/csv-parse/lib/utils/ResizeableBuffer.js
var ResizeableBuffer = class {
  constructor(size = 100) {
    this.size = size;
    this.length = 0;
    this.buf = Buffer.allocUnsafe(size);
  }
  prepend(val) {
    if (Buffer.isBuffer(val)) {
      const length = this.length + val.length;
      if (length >= this.size) {
        this.resize();
        if (length >= this.size) {
          throw Error("INVALID_BUFFER_STATE");
        }
      }
      const buf = this.buf;
      this.buf = Buffer.allocUnsafe(this.size);
      val.copy(this.buf, 0);
      buf.copy(this.buf, val.length);
      this.length += val.length;
    } else {
      const length = this.length++;
      if (length === this.size) {
        this.resize();
      }
      const buf = this.clone();
      this.buf[0] = val;
      buf.copy(this.buf, 1, 0, length);
    }
  }
  append(val) {
    const length = this.length++;
    if (length === this.size) {
      this.resize();
    }
    this.buf[length] = val;
  }
  clone() {
    return Buffer.from(this.buf.slice(0, this.length));
  }
  resize() {
    const length = this.length;
    this.size = this.size * 2;
    const buf = Buffer.allocUnsafe(this.size);
    this.buf.copy(buf, 0, 0, length);
    this.buf = buf;
  }
  toString(encoding) {
    if (encoding) {
      return this.buf.slice(0, this.length).toString(encoding);
    } else {
      return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
    }
  }
  toJSON() {
    return this.toString("utf8");
  }
  reset() {
    this.length = 0;
  }
};
var ResizeableBuffer_default = ResizeableBuffer;

// node_modules/.pnpm/csv-parse@5.5.6/node_modules/csv-parse/lib/api/init_state.js
var np = 12;
var cr = 13;
var nl = 10;
var space = 32;
var tab = 9;
var init_state = function(options) {
  return {
    bomSkipped: false,
    bufBytesStart: 0,
    castField: options.cast_function,
    commenting: false,
    // Current error encountered by a record
    error: void 0,
    enabled: options.from_line === 1,
    escaping: false,
    escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,
    // columns can be `false`, `true`, `Array`
    expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : void 0,
    field: new ResizeableBuffer_default(20),
    firstLineToHeaders: options.cast_first_line_to_header,
    needMoreDataSize: Math.max(
      // Skip if the remaining buffer smaller than comment
      options.comment !== null ? options.comment.length : 0,
      ...options.delimiter.map((delimiter) => delimiter.length),
      // Skip if the remaining buffer can be escape sequence
      options.quote !== null ? options.quote.length : 0
    ),
    previousBuf: void 0,
    quoting: false,
    stop: false,
    rawBuffer: new ResizeableBuffer_default(100),
    record: [],
    recordHasError: false,
    record_length: 0,
    recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 0 : Math.max(...options.record_delimiter.map((v) => v.length)),
    trimChars: [Buffer.from(" ", options.encoding)[0], Buffer.from("	", options.encoding)[0]],
    wasQuoting: false,
    wasRowDelimiter: false,
    timchars: [
      Buffer.from(Buffer.from([cr], "utf8").toString(), options.encoding),
      Buffer.from(Buffer.from([nl], "utf8").toString(), options.encoding),
      Buffer.from(Buffer.from([np], "utf8").toString(), options.encoding),
      Buffer.from(Buffer.from([space], "utf8").toString(), options.encoding),
      Buffer.from(Buffer.from([tab], "utf8").toString(), options.encoding)
    ]
  };
};

// node_modules/.pnpm/csv-parse@5.5.6/node_modules/csv-parse/lib/utils/underscore.js
var underscore = function(str) {
  return str.replace(/([A-Z])/g, function(_, match) {
    return "_" + match.toLowerCase();
  });
};

// node_modules/.pnpm/csv-parse@5.5.6/node_modules/csv-parse/lib/api/normalize_options.js
var normalize_options = function(opts) {
  const options = {};
  for (const opt in opts) {
    options[underscore(opt)] = opts[opt];
  }
  if (options.encoding === void 0 || options.encoding === true) {
    options.encoding = "utf8";
  } else if (options.encoding === null || options.encoding === false) {
    options.encoding = null;
  } else if (typeof options.encoding !== "string" && options.encoding !== null) {
    throw new CsvError("CSV_INVALID_OPTION_ENCODING", [
      "Invalid option encoding:",
      "encoding must be a string or null to return a buffer,",
      `got ${JSON.stringify(options.encoding)}`
    ], options);
  }
  if (options.bom === void 0 || options.bom === null || options.bom === false) {
    options.bom = false;
  } else if (options.bom !== true) {
    throw new CsvError("CSV_INVALID_OPTION_BOM", [
      "Invalid option bom:",
      "bom must be true,",
      `got ${JSON.stringify(options.bom)}`
    ], options);
  }
  options.cast_function = null;
  if (options.cast === void 0 || options.cast === null || options.cast === false || options.cast === "") {
    options.cast = void 0;
  } else if (typeof options.cast === "function") {
    options.cast_function = options.cast;
    options.cast = true;
  } else if (options.cast !== true) {
    throw new CsvError("CSV_INVALID_OPTION_CAST", [
      "Invalid option cast:",
      "cast must be true or a function,",
      `got ${JSON.stringify(options.cast)}`
    ], options);
  }
  if (options.cast_date === void 0 || options.cast_date === null || options.cast_date === false || options.cast_date === "") {
    options.cast_date = false;
  } else if (options.cast_date === true) {
    options.cast_date = function(value2) {
      const date = Date.parse(value2);
      return !isNaN(date) ? new Date(date) : value2;
    };
  } else if (typeof options.cast_date !== "function") {
    throw new CsvError("CSV_INVALID_OPTION_CAST_DATE", [
      "Invalid option cast_date:",
      "cast_date must be true or a function,",
      `got ${JSON.stringify(options.cast_date)}`
    ], options);
  }
  options.cast_first_line_to_header = null;
  if (options.columns === true) {
    options.cast_first_line_to_header = void 0;
  } else if (typeof options.columns === "function") {
    options.cast_first_line_to_header = options.columns;
    options.columns = true;
  } else if (Array.isArray(options.columns)) {
    options.columns = normalize_columns_array(options.columns);
  } else if (options.columns === void 0 || options.columns === null || options.columns === false) {
    options.columns = false;
  } else {
    throw new CsvError("CSV_INVALID_OPTION_COLUMNS", [
      "Invalid option columns:",
      "expect an array, a function or true,",
      `got ${JSON.stringify(options.columns)}`
    ], options);
  }
  if (options.group_columns_by_name === void 0 || options.group_columns_by_name === null || options.group_columns_by_name === false) {
    options.group_columns_by_name = false;
  } else if (options.group_columns_by_name !== true) {
    throw new CsvError("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME", [
      "Invalid option group_columns_by_name:",
      "expect an boolean,",
      `got ${JSON.stringify(options.group_columns_by_name)}`
    ], options);
  } else if (options.columns === false) {
    throw new CsvError("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME", [
      "Invalid option group_columns_by_name:",
      "the `columns` mode must be activated."
    ], options);
  }
  if (options.comment === void 0 || options.comment === null || options.comment === false || options.comment === "") {
    options.comment = null;
  } else {
    if (typeof options.comment === "string") {
      options.comment = Buffer.from(options.comment, options.encoding);
    }
    if (!Buffer.isBuffer(options.comment)) {
      throw new CsvError("CSV_INVALID_OPTION_COMMENT", [
        "Invalid option comment:",
        "comment must be a buffer or a string,",
        `got ${JSON.stringify(options.comment)}`
      ], options);
    }
  }
  if (options.comment_no_infix === void 0 || options.comment_no_infix === null || options.comment_no_infix === false) {
    options.comment_no_infix = false;
  } else if (options.comment_no_infix !== true) {
    throw new CsvError("CSV_INVALID_OPTION_COMMENT", [
      "Invalid option comment_no_infix:",
      "value must be a boolean,",
      `got ${JSON.stringify(options.comment_no_infix)}`
    ], options);
  }
  const delimiter_json = JSON.stringify(options.delimiter);
  if (!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];
  if (options.delimiter.length === 0) {
    throw new CsvError("CSV_INVALID_OPTION_DELIMITER", [
      "Invalid option delimiter:",
      "delimiter must be a non empty string or buffer or array of string|buffer,",
      `got ${delimiter_json}`
    ], options);
  }
  options.delimiter = options.delimiter.map(function(delimiter) {
    if (delimiter === void 0 || delimiter === null || delimiter === false) {
      return Buffer.from(",", options.encoding);
    }
    if (typeof delimiter === "string") {
      delimiter = Buffer.from(delimiter, options.encoding);
    }
    if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {
      throw new CsvError("CSV_INVALID_OPTION_DELIMITER", [
        "Invalid option delimiter:",
        "delimiter must be a non empty string or buffer or array of string|buffer,",
        `got ${delimiter_json}`
      ], options);
    }
    return delimiter;
  });
  if (options.escape === void 0 || options.escape === true) {
    options.escape = Buffer.from('"', options.encoding);
  } else if (typeof options.escape === "string") {
    options.escape = Buffer.from(options.escape, options.encoding);
  } else if (options.escape === null || options.escape === false) {
    options.escape = null;
  }
  if (options.escape !== null) {
    if (!Buffer.isBuffer(options.escape)) {
      throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);
    }
  }
  if (options.from === void 0 || options.from === null) {
    options.from = 1;
  } else {
    if (typeof options.from === "string" && /\d+/.test(options.from)) {
      options.from = parseInt(options.from);
    }
    if (Number.isInteger(options.from)) {
      if (options.from < 0) {
        throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);
      }
    } else {
      throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);
    }
  }
  if (options.from_line === void 0 || options.from_line === null) {
    options.from_line = 1;
  } else {
    if (typeof options.from_line === "string" && /\d+/.test(options.from_line)) {
      options.from_line = parseInt(options.from_line);
    }
    if (Number.isInteger(options.from_line)) {
      if (options.from_line <= 0) {
        throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);
      }
    } else {
      throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);
    }
  }
  if (options.ignore_last_delimiters === void 0 || options.ignore_last_delimiters === null) {
    options.ignore_last_delimiters = false;
  } else if (typeof options.ignore_last_delimiters === "number") {
    options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);
    if (options.ignore_last_delimiters === 0) {
      options.ignore_last_delimiters = false;
    }
  } else if (typeof options.ignore_last_delimiters !== "boolean") {
    throw new CsvError("CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS", [
      "Invalid option `ignore_last_delimiters`:",
      "the value must be a boolean value or an integer,",
      `got ${JSON.stringify(options.ignore_last_delimiters)}`
    ], options);
  }
  if (options.ignore_last_delimiters === true && options.columns === false) {
    throw new CsvError("CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS", [
      "The option `ignore_last_delimiters`",
      "requires the activation of the `columns` option"
    ], options);
  }
  if (options.info === void 0 || options.info === null || options.info === false) {
    options.info = false;
  } else if (options.info !== true) {
    throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);
  }
  if (options.max_record_size === void 0 || options.max_record_size === null || options.max_record_size === false) {
    options.max_record_size = 0;
  } else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) {
  } else if (typeof options.max_record_size === "string" && /\d+/.test(options.max_record_size)) {
    options.max_record_size = parseInt(options.max_record_size);
  } else {
    throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);
  }
  if (options.objname === void 0 || options.objname === null || options.objname === false) {
    options.objname = void 0;
  } else if (Buffer.isBuffer(options.objname)) {
    if (options.objname.length === 0) {
      throw new Error(`Invalid Option: objname must be a non empty buffer`);
    }
    if (options.encoding === null) {
    } else {
      options.objname = options.objname.toString(options.encoding);
    }
  } else if (typeof options.objname === "string") {
    if (options.objname.length === 0) {
      throw new Error(`Invalid Option: objname must be a non empty string`);
    }
  } else if (typeof options.objname === "number") {
  } else {
    throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);
  }
  if (options.objname !== void 0) {
    if (typeof options.objname === "number") {
      if (options.columns !== false) {
        throw Error("Invalid Option: objname index cannot be combined with columns or be defined as a field");
      }
    } else {
      if (options.columns === false) {
        throw Error("Invalid Option: objname field must be combined with columns or be defined as an index");
      }
    }
  }
  if (options.on_record === void 0 || options.on_record === null) {
    options.on_record = void 0;
  } else if (typeof options.on_record !== "function") {
    throw new CsvError("CSV_INVALID_OPTION_ON_RECORD", [
      "Invalid option `on_record`:",
      "expect a function,",
      `got ${JSON.stringify(options.on_record)}`
    ], options);
  }
  if (options.on_skip !== void 0 && options.on_skip !== null && typeof options.on_skip !== "function") {
    throw new Error(`Invalid Option: on_skip must be a function, got ${JSON.stringify(options.on_skip)}`);
  }
  if (options.quote === null || options.quote === false || options.quote === "") {
    options.quote = null;
  } else {
    if (options.quote === void 0 || options.quote === true) {
      options.quote = Buffer.from('"', options.encoding);
    } else if (typeof options.quote === "string") {
      options.quote = Buffer.from(options.quote, options.encoding);
    }
    if (!Buffer.isBuffer(options.quote)) {
      throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);
    }
  }
  if (options.raw === void 0 || options.raw === null || options.raw === false) {
    options.raw = false;
  } else if (options.raw !== true) {
    throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);
  }
  if (options.record_delimiter === void 0) {
    options.record_delimiter = [];
  } else if (typeof options.record_delimiter === "string" || Buffer.isBuffer(options.record_delimiter)) {
    if (options.record_delimiter.length === 0) {
      throw new CsvError("CSV_INVALID_OPTION_RECORD_DELIMITER", [
        "Invalid option `record_delimiter`:",
        "value must be a non empty string or buffer,",
        `got ${JSON.stringify(options.record_delimiter)}`
      ], options);
    }
    options.record_delimiter = [options.record_delimiter];
  } else if (!Array.isArray(options.record_delimiter)) {
    throw new CsvError("CSV_INVALID_OPTION_RECORD_DELIMITER", [
      "Invalid option `record_delimiter`:",
      "value must be a string, a buffer or array of string|buffer,",
      `got ${JSON.stringify(options.record_delimiter)}`
    ], options);
  }
  options.record_delimiter = options.record_delimiter.map(function(rd, i) {
    if (typeof rd !== "string" && !Buffer.isBuffer(rd)) {
      throw new CsvError("CSV_INVALID_OPTION_RECORD_DELIMITER", [
        "Invalid option `record_delimiter`:",
        "value must be a string, a buffer or array of string|buffer",
        `at index ${i},`,
        `got ${JSON.stringify(rd)}`
      ], options);
    } else if (rd.length === 0) {
      throw new CsvError("CSV_INVALID_OPTION_RECORD_DELIMITER", [
        "Invalid option `record_delimiter`:",
        "value must be a non empty string or buffer",
        `at index ${i},`,
        `got ${JSON.stringify(rd)}`
      ], options);
    }
    if (typeof rd === "string") {
      rd = Buffer.from(rd, options.encoding);
    }
    return rd;
  });
  if (typeof options.relax_column_count === "boolean") {
  } else if (options.relax_column_count === void 0 || options.relax_column_count === null) {
    options.relax_column_count = false;
  } else {
    throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);
  }
  if (typeof options.relax_column_count_less === "boolean") {
  } else if (options.relax_column_count_less === void 0 || options.relax_column_count_less === null) {
    options.relax_column_count_less = false;
  } else {
    throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);
  }
  if (typeof options.relax_column_count_more === "boolean") {
  } else if (options.relax_column_count_more === void 0 || options.relax_column_count_more === null) {
    options.relax_column_count_more = false;
  } else {
    throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);
  }
  if (typeof options.relax_quotes === "boolean") {
  } else if (options.relax_quotes === void 0 || options.relax_quotes === null) {
    options.relax_quotes = false;
  } else {
    throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`);
  }
  if (typeof options.skip_empty_lines === "boolean") {
  } else if (options.skip_empty_lines === void 0 || options.skip_empty_lines === null) {
    options.skip_empty_lines = false;
  } else {
    throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);
  }
  if (typeof options.skip_records_with_empty_values === "boolean") {
  } else if (options.skip_records_with_empty_values === void 0 || options.skip_records_with_empty_values === null) {
    options.skip_records_with_empty_values = false;
  } else {
    throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`);
  }
  if (typeof options.skip_records_with_error === "boolean") {
  } else if (options.skip_records_with_error === void 0 || options.skip_records_with_error === null) {
    options.skip_records_with_error = false;
  } else {
    throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`);
  }
  if (options.rtrim === void 0 || options.rtrim === null || options.rtrim === false) {
    options.rtrim = false;
  } else if (options.rtrim !== true) {
    throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);
  }
  if (options.ltrim === void 0 || options.ltrim === null || options.ltrim === false) {
    options.ltrim = false;
  } else if (options.ltrim !== true) {
    throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);
  }
  if (options.trim === void 0 || options.trim === null || options.trim === false) {
    options.trim = false;
  } else if (options.trim !== true) {
    throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);
  }
  if (options.trim === true && opts.ltrim !== false) {
    options.ltrim = true;
  } else if (options.ltrim !== true) {
    options.ltrim = false;
  }
  if (options.trim === true && opts.rtrim !== false) {
    options.rtrim = true;
  } else if (options.rtrim !== true) {
    options.rtrim = false;
  }
  if (options.to === void 0 || options.to === null) {
    options.to = -1;
  } else {
    if (typeof options.to === "string" && /\d+/.test(options.to)) {
      options.to = parseInt(options.to);
    }
    if (Number.isInteger(options.to)) {
      if (options.to <= 0) {
        throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);
      }
    } else {
      throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);
    }
  }
  if (options.to_line === void 0 || options.to_line === null) {
    options.to_line = -1;
  } else {
    if (typeof options.to_line === "string" && /\d+/.test(options.to_line)) {
      options.to_line = parseInt(options.to_line);
    }
    if (Number.isInteger(options.to_line)) {
      if (options.to_line <= 0) {
        throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);
      }
    } else {
      throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);
    }
  }
  return options;
};

// node_modules/.pnpm/csv-parse@5.5.6/node_modules/csv-parse/lib/api/index.js
var isRecordEmpty = function(record) {
  return record.every((field) => field == null || field.toString && field.toString().trim() === "");
};
var cr2 = 13;
var nl2 = 10;
var boms = {
  // Note, the following are equals:
  // Buffer.from("\ufeff")
  // Buffer.from([239, 187, 191])
  // Buffer.from('EFBBBF', 'hex')
  "utf8": Buffer.from([239, 187, 191]),
  // Note, the following are equals:
  // Buffer.from "\ufeff", 'utf16le
  // Buffer.from([255, 254])
  "utf16le": Buffer.from([255, 254])
};
var transform = function(original_options = {}) {
  const info = {
    bytes: 0,
    comment_lines: 0,
    empty_lines: 0,
    invalid_field_length: 0,
    lines: 1,
    records: 0
  };
  const options = normalize_options(original_options);
  return {
    info,
    original_options,
    options,
    state: init_state(options),
    __needMoreData: function(i, bufLen, end) {
      if (end) return false;
      const { encoding, escape, quote } = this.options;
      const { quoting, needMoreDataSize, recordDelimiterMaxLength } = this.state;
      const numOfCharLeft = bufLen - i - 1;
      const requiredLength = Math.max(
        needMoreDataSize,
        // Skip if the remaining buffer smaller than record delimiter
        // If "record_delimiter" is yet to be discovered:
        // 1. It is equals to `[]` and "recordDelimiterMaxLength" equals `0`
        // 2. We set the length to windows line ending in the current encoding
        // Note, that encoding is known from user or bom discovery at that point
        // recordDelimiterMaxLength,
        recordDelimiterMaxLength === 0 ? Buffer.from("\r\n", encoding).length : recordDelimiterMaxLength,
        // Skip if remaining buffer can be an escaped quote
        quoting ? (escape === null ? 0 : escape.length) + quote.length : 0,
        // Skip if remaining buffer can be record delimiter following the closing quote
        quoting ? quote.length + recordDelimiterMaxLength : 0
      );
      return numOfCharLeft < requiredLength;
    },
    // Central parser implementation
    parse: function(nextBuf, end, push, close) {
      const { bom, comment_no_infix, encoding, from_line, ltrim, max_record_size, raw, relax_quotes, rtrim, skip_empty_lines, to, to_line } = this.options;
      let { comment, escape, quote, record_delimiter } = this.options;
      const { bomSkipped, previousBuf, rawBuffer, escapeIsQuote } = this.state;
      let buf;
      if (previousBuf === void 0) {
        if (nextBuf === void 0) {
          close();
          return;
        } else {
          buf = nextBuf;
        }
      } else if (previousBuf !== void 0 && nextBuf === void 0) {
        buf = previousBuf;
      } else {
        buf = Buffer.concat([previousBuf, nextBuf]);
      }
      if (bomSkipped === false) {
        if (bom === false) {
          this.state.bomSkipped = true;
        } else if (buf.length < 3) {
          if (end === false) {
            this.state.previousBuf = buf;
            return;
          }
        } else {
          for (const encoding2 in boms) {
            if (boms[encoding2].compare(buf, 0, boms[encoding2].length) === 0) {
              const bomLength = boms[encoding2].length;
              this.state.bufBytesStart += bomLength;
              buf = buf.slice(bomLength);
              this.options = normalize_options({ ...this.original_options, encoding: encoding2 });
              ({ comment, escape, quote } = this.options);
              break;
            }
          }
          this.state.bomSkipped = true;
        }
      }
      const bufLen = buf.length;
      let pos;
      for (pos = 0; pos < bufLen; pos++) {
        if (this.__needMoreData(pos, bufLen, end)) {
          break;
        }
        if (this.state.wasRowDelimiter === true) {
          this.info.lines++;
          this.state.wasRowDelimiter = false;
        }
        if (to_line !== -1 && this.info.lines > to_line) {
          this.state.stop = true;
          close();
          return;
        }
        if (this.state.quoting === false && record_delimiter.length === 0) {
          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);
          if (record_delimiterCount) {
            record_delimiter = this.options.record_delimiter;
          }
        }
        const chr = buf[pos];
        if (raw === true) {
          rawBuffer.append(chr);
        }
        if ((chr === cr2 || chr === nl2) && this.state.wasRowDelimiter === false) {
          this.state.wasRowDelimiter = true;
        }
        if (this.state.escaping === true) {
          this.state.escaping = false;
        } else {
          if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {
            if (escapeIsQuote) {
              if (this.__isQuote(buf, pos + escape.length)) {
                this.state.escaping = true;
                pos += escape.length - 1;
                continue;
              }
            } else {
              this.state.escaping = true;
              pos += escape.length - 1;
              continue;
            }
          }
          if (this.state.commenting === false && this.__isQuote(buf, pos)) {
            if (this.state.quoting === true) {
              const nextChr = buf[pos + quote.length];
              const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos + quote.length);
              const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);
              const isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);
              const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length);
              if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {
                pos += escape.length - 1;
              } else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {
                this.state.quoting = false;
                this.state.wasQuoting = true;
                pos += quote.length - 1;
                continue;
              } else if (relax_quotes === false) {
                const err = this.__error(
                  new CsvError("CSV_INVALID_CLOSING_QUOTE", [
                    "Invalid Closing Quote:",
                    `got "${String.fromCharCode(nextChr)}"`,
                    `at line ${this.info.lines}`,
                    "instead of delimiter, record delimiter, trimable character",
                    "(if activated) or comment"
                  ], this.options, this.__infoField())
                );
                if (err !== void 0) return err;
              } else {
                this.state.quoting = false;
                this.state.wasQuoting = true;
                this.state.field.prepend(quote);
                pos += quote.length - 1;
              }
            } else {
              if (this.state.field.length !== 0) {
                if (relax_quotes === false) {
                  const info2 = this.__infoField();
                  const bom2 = Object.keys(boms).map((b) => boms[b].equals(this.state.field.toString()) ? b : false).filter(Boolean)[0];
                  const err = this.__error(
                    new CsvError("INVALID_OPENING_QUOTE", [
                      "Invalid Opening Quote:",
                      `a quote is found on field ${JSON.stringify(info2.column)} at line ${info2.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`,
                      bom2 ? `(${bom2} bom)` : void 0
                    ], this.options, info2, {
                      field: this.state.field
                    })
                  );
                  if (err !== void 0) return err;
                }
              } else {
                this.state.quoting = true;
                pos += quote.length - 1;
                continue;
              }
            }
          }
          if (this.state.quoting === false) {
            const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);
            if (recordDelimiterLength !== 0) {
              const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0);
              if (skipCommentLine) {
                this.info.comment_lines++;
              } else {
                if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {
                  this.state.enabled = true;
                  this.__resetField();
                  this.__resetRecord();
                  pos += recordDelimiterLength - 1;
                  continue;
                }
                if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {
                  this.info.empty_lines++;
                  pos += recordDelimiterLength - 1;
                  continue;
                }
                this.info.bytes = this.state.bufBytesStart + pos;
                const errField = this.__onField();
                if (errField !== void 0) return errField;
                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;
                const errRecord = this.__onRecord(push);
                if (errRecord !== void 0) return errRecord;
                if (to !== -1 && this.info.records >= to) {
                  this.state.stop = true;
                  close();
                  return;
                }
              }
              this.state.commenting = false;
              pos += recordDelimiterLength - 1;
              continue;
            }
            if (this.state.commenting) {
              continue;
            }
            if (comment !== null && (comment_no_infix === false || this.state.record.length === 0 && this.state.field.length === 0)) {
              const commentCount = this.__compareBytes(comment, buf, pos, chr);
              if (commentCount !== 0) {
                this.state.commenting = true;
                continue;
              }
            }
            const delimiterLength = this.__isDelimiter(buf, pos, chr);
            if (delimiterLength !== 0) {
              this.info.bytes = this.state.bufBytesStart + pos;
              const errField = this.__onField();
              if (errField !== void 0) return errField;
              pos += delimiterLength - 1;
              continue;
            }
          }
        }
        if (this.state.commenting === false) {
          if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {
            return this.__error(
              new CsvError("CSV_MAX_RECORD_SIZE", [
                "Max Record Size:",
                "record exceed the maximum number of tolerated bytes",
                `of ${max_record_size}`,
                `at line ${this.info.lines}`
              ], this.options, this.__infoField())
            );
          }
        }
        const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);
        const rappend = rtrim === false || this.state.wasQuoting === false;
        if (lappend === true && rappend === true) {
          this.state.field.append(chr);
        } else if (rtrim === true && !this.__isCharTrimable(buf, pos)) {
          return this.__error(
            new CsvError("CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE", [
              "Invalid Closing Quote:",
              "found non trimable byte after quote",
              `at line ${this.info.lines}`
            ], this.options, this.__infoField())
          );
        } else {
          if (lappend === false) {
            pos += this.__isCharTrimable(buf, pos) - 1;
          }
          continue;
        }
      }
      if (end === true) {
        if (this.state.quoting === true) {
          const err = this.__error(
            new CsvError("CSV_QUOTE_NOT_CLOSED", [
              "Quote Not Closed:",
              `the parsing is finished with an opening quote at line ${this.info.lines}`
            ], this.options, this.__infoField())
          );
          if (err !== void 0) return err;
        } else {
          if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {
            this.info.bytes = this.state.bufBytesStart + pos;
            const errField = this.__onField();
            if (errField !== void 0) return errField;
            const errRecord = this.__onRecord(push);
            if (errRecord !== void 0) return errRecord;
          } else if (this.state.wasRowDelimiter === true) {
            this.info.empty_lines++;
          } else if (this.state.commenting === true) {
            this.info.comment_lines++;
          }
        }
      } else {
        this.state.bufBytesStart += pos;
        this.state.previousBuf = buf.slice(pos);
      }
      if (this.state.wasRowDelimiter === true) {
        this.info.lines++;
        this.state.wasRowDelimiter = false;
      }
    },
    __onRecord: function(push) {
      const { columns, group_columns_by_name, encoding, info: info2, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_records_with_empty_values } = this.options;
      const { enabled, record } = this.state;
      if (enabled === false) {
        return this.__resetRecord();
      }
      const recordLength = record.length;
      if (columns === true) {
        if (skip_records_with_empty_values === true && isRecordEmpty(record)) {
          this.__resetRecord();
          return;
        }
        return this.__firstLineToColumns(record);
      }
      if (columns === false && this.info.records === 0) {
        this.state.expectedRecordLength = recordLength;
      }
      if (recordLength !== this.state.expectedRecordLength) {
        const err = columns === false ? new CsvError("CSV_RECORD_INCONSISTENT_FIELDS_LENGTH", [
          "Invalid Record Length:",
          `expect ${this.state.expectedRecordLength},`,
          `got ${recordLength} on line ${this.info.lines}`
        ], this.options, this.__infoField(), {
          record
        }) : new CsvError("CSV_RECORD_INCONSISTENT_COLUMNS", [
          "Invalid Record Length:",
          `columns length is ${columns.length},`,
          // rename columns
          `got ${recordLength} on line ${this.info.lines}`
        ], this.options, this.__infoField(), {
          record
        });
        if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {
          this.info.invalid_field_length++;
          this.state.error = err;
        } else {
          const finalErr = this.__error(err);
          if (finalErr) return finalErr;
        }
      }
      if (skip_records_with_empty_values === true && isRecordEmpty(record)) {
        this.__resetRecord();
        return;
      }
      if (this.state.recordHasError === true) {
        this.__resetRecord();
        this.state.recordHasError = false;
        return;
      }
      this.info.records++;
      if (from === 1 || this.info.records >= from) {
        const { objname } = this.options;
        if (columns !== false) {
          const obj = {};
          for (let i = 0, l = record.length; i < l; i++) {
            if (columns[i] === void 0 || columns[i].disabled) continue;
            if (group_columns_by_name === true && obj[columns[i].name] !== void 0) {
              if (Array.isArray(obj[columns[i].name])) {
                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);
              } else {
                obj[columns[i].name] = [obj[columns[i].name], record[i]];
              }
            } else {
              obj[columns[i].name] = record[i];
            }
          }
          if (raw === true || info2 === true) {
            const extRecord = Object.assign(
              { record: obj },
              raw === true ? { raw: this.state.rawBuffer.toString(encoding) } : {},
              info2 === true ? { info: this.__infoRecord() } : {}
            );
            const err = this.__push(
              objname === void 0 ? extRecord : [obj[objname], extRecord],
              push
            );
            if (err) {
              return err;
            }
          } else {
            const err = this.__push(
              objname === void 0 ? obj : [obj[objname], obj],
              push
            );
            if (err) {
              return err;
            }
          }
        } else {
          if (raw === true || info2 === true) {
            const extRecord = Object.assign(
              { record },
              raw === true ? { raw: this.state.rawBuffer.toString(encoding) } : {},
              info2 === true ? { info: this.__infoRecord() } : {}
            );
            const err = this.__push(
              objname === void 0 ? extRecord : [record[objname], extRecord],
              push
            );
            if (err) {
              return err;
            }
          } else {
            const err = this.__push(
              objname === void 0 ? record : [record[objname], record],
              push
            );
            if (err) {
              return err;
            }
          }
        }
      }
      this.__resetRecord();
    },
    __firstLineToColumns: function(record) {
      const { firstLineToHeaders } = this.state;
      try {
        const headers = firstLineToHeaders === void 0 ? record : firstLineToHeaders.call(null, record);
        if (!Array.isArray(headers)) {
          return this.__error(
            new CsvError("CSV_INVALID_COLUMN_MAPPING", [
              "Invalid Column Mapping:",
              "expect an array from column function,",
              `got ${JSON.stringify(headers)}`
            ], this.options, this.__infoField(), {
              headers
            })
          );
        }
        const normalizedHeaders = normalize_columns_array(headers);
        this.state.expectedRecordLength = normalizedHeaders.length;
        this.options.columns = normalizedHeaders;
        this.__resetRecord();
        return;
      } catch (err) {
        return err;
      }
    },
    __resetRecord: function() {
      if (this.options.raw === true) {
        this.state.rawBuffer.reset();
      }
      this.state.error = void 0;
      this.state.record = [];
      this.state.record_length = 0;
    },
    __onField: function() {
      const { cast, encoding, rtrim, max_record_size } = this.options;
      const { enabled, wasQuoting } = this.state;
      if (enabled === false) {
        return this.__resetField();
      }
      let field = this.state.field.toString(encoding);
      if (rtrim === true && wasQuoting === false) {
        field = field.trimRight();
      }
      if (cast === true) {
        const [err, f] = this.__cast(field);
        if (err !== void 0) return err;
        field = f;
      }
      this.state.record.push(field);
      if (max_record_size !== 0 && typeof field === "string") {
        this.state.record_length += field.length;
      }
      this.__resetField();
    },
    __resetField: function() {
      this.state.field.reset();
      this.state.wasQuoting = false;
    },
    __push: function(record, push) {
      const { on_record } = this.options;
      if (on_record !== void 0) {
        const info2 = this.__infoRecord();
        try {
          record = on_record.call(null, record, info2);
        } catch (err) {
          return err;
        }
        if (record === void 0 || record === null) {
          return;
        }
      }
      push(record);
    },
    // Return a tuple with the error and the casted value
    __cast: function(field) {
      const { columns, relax_column_count } = this.options;
      const isColumns = Array.isArray(columns);
      if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {
        return [void 0, void 0];
      }
      if (this.state.castField !== null) {
        try {
          const info2 = this.__infoField();
          return [void 0, this.state.castField.call(null, field, info2)];
        } catch (err) {
          return [err];
        }
      }
      if (this.__isFloat(field)) {
        return [void 0, parseFloat(field)];
      } else if (this.options.cast_date !== false) {
        const info2 = this.__infoField();
        return [void 0, this.options.cast_date.call(null, field, info2)];
      }
      return [void 0, field];
    },
    // Helper to test if a character is a space or a line delimiter
    __isCharTrimable: function(buf, pos) {
      const isTrim = (buf2, pos2) => {
        const { timchars } = this.state;
        loop1: for (let i = 0; i < timchars.length; i++) {
          const timchar = timchars[i];
          for (let j = 0; j < timchar.length; j++) {
            if (timchar[j] !== buf2[pos2 + j]) continue loop1;
          }
          return timchar.length;
        }
        return 0;
      };
      return isTrim(buf, pos);
    },
    // Keep it in case we implement the `cast_int` option
    // __isInt(value){
    //   // return Number.isInteger(parseInt(value))
    //   // return !isNaN( parseInt( obj ) );
    //   return /^(\-|\+)?[1-9][0-9]*$/.test(value)
    // }
    __isFloat: function(value2) {
      return value2 - parseFloat(value2) + 1 >= 0;
    },
    __compareBytes: function(sourceBuf, targetBuf, targetPos, firstByte) {
      if (sourceBuf[0] !== firstByte) return 0;
      const sourceLength = sourceBuf.length;
      for (let i = 1; i < sourceLength; i++) {
        if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;
      }
      return sourceLength;
    },
    __isDelimiter: function(buf, pos, chr) {
      const { delimiter, ignore_last_delimiters } = this.options;
      if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {
        return 0;
      } else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === "number" && this.state.record.length === ignore_last_delimiters - 1) {
        return 0;
      }
      loop1: for (let i = 0; i < delimiter.length; i++) {
        const del = delimiter[i];
        if (del[0] === chr) {
          for (let j = 1; j < del.length; j++) {
            if (del[j] !== buf[pos + j]) continue loop1;
          }
          return del.length;
        }
      }
      return 0;
    },
    __isRecordDelimiter: function(chr, buf, pos) {
      const { record_delimiter } = this.options;
      const recordDelimiterLength = record_delimiter.length;
      loop1: for (let i = 0; i < recordDelimiterLength; i++) {
        const rd = record_delimiter[i];
        const rdLength = rd.length;
        if (rd[0] !== chr) {
          continue;
        }
        for (let j = 1; j < rdLength; j++) {
          if (rd[j] !== buf[pos + j]) {
            continue loop1;
          }
        }
        return rd.length;
      }
      return 0;
    },
    __isEscape: function(buf, pos, chr) {
      const { escape } = this.options;
      if (escape === null) return false;
      const l = escape.length;
      if (escape[0] === chr) {
        for (let i = 0; i < l; i++) {
          if (escape[i] !== buf[pos + i]) {
            return false;
          }
        }
        return true;
      }
      return false;
    },
    __isQuote: function(buf, pos) {
      const { quote } = this.options;
      if (quote === null) return false;
      const l = quote.length;
      for (let i = 0; i < l; i++) {
        if (quote[i] !== buf[pos + i]) {
          return false;
        }
      }
      return true;
    },
    __autoDiscoverRecordDelimiter: function(buf, pos) {
      const { encoding } = this.options;
      const rds = [
        // Important, the windows line ending must be before mac os 9
        Buffer.from("\r\n", encoding),
        Buffer.from("\n", encoding),
        Buffer.from("\r", encoding)
      ];
      loop: for (let i = 0; i < rds.length; i++) {
        const l = rds[i].length;
        for (let j = 0; j < l; j++) {
          if (rds[i][j] !== buf[pos + j]) {
            continue loop;
          }
        }
        this.options.record_delimiter.push(rds[i]);
        this.state.recordDelimiterMaxLength = rds[i].length;
        return rds[i].length;
      }
      return 0;
    },
    __error: function(msg) {
      const { encoding, raw, skip_records_with_error } = this.options;
      const err = typeof msg === "string" ? new Error(msg) : msg;
      if (skip_records_with_error) {
        this.state.recordHasError = true;
        if (this.options.on_skip !== void 0) {
          this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : void 0);
        }
        return void 0;
      } else {
        return err;
      }
    },
    __infoDataSet: function() {
      return {
        ...this.info,
        columns: this.options.columns
      };
    },
    __infoRecord: function() {
      const { columns, raw, encoding } = this.options;
      return {
        ...this.__infoDataSet(),
        error: this.state.error,
        header: columns === true,
        index: this.state.record.length,
        raw: raw ? this.state.rawBuffer.toString(encoding) : void 0
      };
    },
    __infoField: function() {
      const { columns } = this.options;
      const isColumns = Array.isArray(columns);
      return {
        ...this.__infoRecord(),
        column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,
        quoting: this.state.wasQuoting
      };
    }
  };
};

// node_modules/.pnpm/csv-parse@5.5.6/node_modules/csv-parse/lib/sync.js
var parse = function(data, opts = {}) {
  if (typeof data === "string") {
    data = Buffer.from(data);
  }
  const records = opts && opts.objname ? {} : [];
  const parser = transform(opts);
  const push = (record) => {
    if (parser.options.objname === void 0)
      records.push(record);
    else {
      records[record[0]] = record[1];
    }
  };
  const close = () => {
  };
  const err1 = parser.parse(data, false, push, close);
  if (err1 !== void 0) throw err1;
  const err2 = parser.parse(void 0, true, push, close);
  if (err2 !== void 0) throw err2;
  return records;
};

// node_modules/.pnpm/csv-stringify@6.5.1/node_modules/csv-stringify/lib/utils/get.js
var charCodeOfDot = ".".charCodeAt(0);
var reEscapeChar = /\\(\\)?/g;
var rePropName = RegExp(
  // Match anything that isn't a dot or bracket.
  `[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`,
  "g"
);
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
var getTag = function(value2) {
  if (!value2)
    value2 === void 0 ? "[object Undefined]" : "[object Null]";
  return Object.prototype.toString.call(value2);
};
var isSymbol = function(value2) {
  const type = typeof value2;
  return type === "symbol" || type === "object" && value2 && getTag(value2) === "[object Symbol]";
};
var isKey = function(value2, object2) {
  if (Array.isArray(value2)) {
    return false;
  }
  const type = typeof value2;
  if (type === "number" || type === "symbol" || type === "boolean" || !value2 || isSymbol(value2)) {
    return true;
  }
  return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object2 != null && value2 in Object(object2);
};
var stringToPath = function(string3) {
  const result = [];
  if (string3.charCodeAt(0) === charCodeOfDot) {
    result.push("");
  }
  string3.replace(rePropName, function(match, expression, quote, subString) {
    let key = match;
    if (quote) {
      key = subString.replace(reEscapeChar, "$1");
    } else if (expression) {
      key = expression.trim();
    }
    result.push(key);
  });
  return result;
};
var castPath = function(value2, object2) {
  if (Array.isArray(value2)) {
    return value2;
  } else {
    return isKey(value2, object2) ? [value2] : stringToPath(value2);
  }
};
var toKey = function(value2) {
  if (typeof value2 === "string" || isSymbol(value2))
    return value2;
  const result = `${value2}`;
  return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
};
var get = function(object2, path) {
  path = castPath(path, object2);
  let index = 0;
  const length = path.length;
  while (object2 != null && index < length) {
    object2 = object2[toKey(path[index++])];
  }
  return index && index === length ? object2 : void 0;
};

// node_modules/.pnpm/csv-stringify@6.5.1/node_modules/csv-stringify/lib/utils/is_object.js
var is_object2 = function(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
};

// node_modules/.pnpm/csv-stringify@6.5.1/node_modules/csv-stringify/lib/api/normalize_columns.js
var normalize_columns = function(columns) {
  if (columns === void 0 || columns === null) {
    return [void 0, void 0];
  }
  if (typeof columns !== "object") {
    return [Error('Invalid option "columns": expect an array or an object')];
  }
  if (!Array.isArray(columns)) {
    const newcolumns = [];
    for (const k in columns) {
      newcolumns.push({
        key: k,
        header: columns[k]
      });
    }
    columns = newcolumns;
  } else {
    const newcolumns = [];
    for (const column of columns) {
      if (typeof column === "string") {
        newcolumns.push({
          key: column,
          header: column
        });
      } else if (typeof column === "object" && column !== null && !Array.isArray(column)) {
        if (!column.key) {
          return [Error('Invalid column definition: property "key" is required')];
        }
        if (column.header === void 0) {
          column.header = column.key;
        }
        newcolumns.push(column);
      } else {
        return [Error("Invalid column definition: expect a string or an object")];
      }
    }
    columns = newcolumns;
  }
  return [void 0, columns];
};

// node_modules/.pnpm/csv-stringify@6.5.1/node_modules/csv-stringify/lib/api/CsvError.js
var CsvError2 = class _CsvError extends Error {
  constructor(code, message, ...contexts) {
    if (Array.isArray(message)) message = message.join(" ");
    super(message);
    if (Error.captureStackTrace !== void 0) {
      Error.captureStackTrace(this, _CsvError);
    }
    this.code = code;
    for (const context of contexts) {
      for (const key in context) {
        const value2 = context[key];
        this[key] = Buffer.isBuffer(value2) ? value2.toString() : value2 == null ? value2 : JSON.parse(JSON.stringify(value2));
      }
    }
  }
};

// node_modules/.pnpm/csv-stringify@6.5.1/node_modules/csv-stringify/lib/utils/underscore.js
var underscore2 = function(str) {
  return str.replace(/([A-Z])/g, function(_, match) {
    return "_" + match.toLowerCase();
  });
};

// node_modules/.pnpm/csv-stringify@6.5.1/node_modules/csv-stringify/lib/api/normalize_options.js
var normalize_options2 = function(opts) {
  const options = {};
  for (const opt in opts) {
    options[underscore2(opt)] = opts[opt];
  }
  if (options.bom === void 0 || options.bom === null || options.bom === false) {
    options.bom = false;
  } else if (options.bom !== true) {
    return [new CsvError2("CSV_OPTION_BOOLEAN_INVALID_TYPE", [
      "option `bom` is optional and must be a boolean value,",
      `got ${JSON.stringify(options.bom)}`
    ])];
  }
  if (options.delimiter === void 0 || options.delimiter === null) {
    options.delimiter = ",";
  } else if (Buffer.isBuffer(options.delimiter)) {
    options.delimiter = options.delimiter.toString();
  } else if (typeof options.delimiter !== "string") {
    return [new CsvError2("CSV_OPTION_DELIMITER_INVALID_TYPE", [
      "option `delimiter` must be a buffer or a string,",
      `got ${JSON.stringify(options.delimiter)}`
    ])];
  }
  if (options.quote === void 0 || options.quote === null) {
    options.quote = '"';
  } else if (options.quote === true) {
    options.quote = '"';
  } else if (options.quote === false) {
    options.quote = "";
  } else if (Buffer.isBuffer(options.quote)) {
    options.quote = options.quote.toString();
  } else if (typeof options.quote !== "string") {
    return [new CsvError2("CSV_OPTION_QUOTE_INVALID_TYPE", [
      "option `quote` must be a boolean, a buffer or a string,",
      `got ${JSON.stringify(options.quote)}`
    ])];
  }
  if (options.quoted === void 0 || options.quoted === null) {
    options.quoted = false;
  } else {
  }
  if (options.escape_formulas === void 0 || options.escape_formulas === null) {
    options.escape_formulas = false;
  } else if (typeof options.escape_formulas !== "boolean") {
    return [new CsvError2("CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE", [
      "option `escape_formulas` must be a boolean,",
      `got ${JSON.stringify(options.escape_formulas)}`
    ])];
  }
  if (options.quoted_empty === void 0 || options.quoted_empty === null) {
    options.quoted_empty = void 0;
  } else {
  }
  if (options.quoted_match === void 0 || options.quoted_match === null || options.quoted_match === false) {
    options.quoted_match = null;
  } else if (!Array.isArray(options.quoted_match)) {
    options.quoted_match = [options.quoted_match];
  }
  if (options.quoted_match) {
    for (const quoted_match of options.quoted_match) {
      const isString = typeof quoted_match === "string";
      const isRegExp = quoted_match instanceof RegExp;
      if (!isString && !isRegExp) {
        return [Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)];
      }
    }
  }
  if (options.quoted_string === void 0 || options.quoted_string === null) {
    options.quoted_string = false;
  } else {
  }
  if (options.eof === void 0 || options.eof === null) {
    options.eof = true;
  } else {
  }
  if (options.escape === void 0 || options.escape === null) {
    options.escape = '"';
  } else if (Buffer.isBuffer(options.escape)) {
    options.escape = options.escape.toString();
  } else if (typeof options.escape !== "string") {
    return [Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)];
  }
  if (options.escape.length > 1) {
    return [Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`)];
  }
  if (options.header === void 0 || options.header === null) {
    options.header = false;
  } else {
  }
  const [errColumns, columns] = normalize_columns(options.columns);
  if (errColumns !== void 0) return [errColumns];
  options.columns = columns;
  if (options.quoted === void 0 || options.quoted === null) {
    options.quoted = false;
  } else {
  }
  if (options.cast === void 0 || options.cast === null) {
    options.cast = {};
  } else {
  }
  if (options.cast.bigint === void 0 || options.cast.bigint === null) {
    options.cast.bigint = (value2) => "" + value2;
  }
  if (options.cast.boolean === void 0 || options.cast.boolean === null) {
    options.cast.boolean = (value2) => value2 ? "1" : "";
  }
  if (options.cast.date === void 0 || options.cast.date === null) {
    options.cast.date = (value2) => "" + value2.getTime();
  }
  if (options.cast.number === void 0 || options.cast.number === null) {
    options.cast.number = (value2) => "" + value2;
  }
  if (options.cast.object === void 0 || options.cast.object === null) {
    options.cast.object = (value2) => JSON.stringify(value2);
  }
  if (options.cast.string === void 0 || options.cast.string === null) {
    options.cast.string = function(value2) {
      return value2;
    };
  }
  if (options.on_record !== void 0 && typeof options.on_record !== "function") {
    return [Error(`Invalid Option: "on_record" must be a function.`)];
  }
  if (options.record_delimiter === void 0 || options.record_delimiter === null) {
    options.record_delimiter = "\n";
  } else if (Buffer.isBuffer(options.record_delimiter)) {
    options.record_delimiter = options.record_delimiter.toString();
  } else if (typeof options.record_delimiter !== "string") {
    return [Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`)];
  }
  switch (options.record_delimiter) {
    case "unix":
      options.record_delimiter = "\n";
      break;
    case "mac":
      options.record_delimiter = "\r";
      break;
    case "windows":
      options.record_delimiter = "\r\n";
      break;
    case "ascii":
      options.record_delimiter = "";
      break;
    case "unicode":
      options.record_delimiter = "\u2028";
      break;
  }
  return [void 0, options];
};

// node_modules/.pnpm/csv-stringify@6.5.1/node_modules/csv-stringify/lib/api/index.js
var bom_utf8 = Buffer.from([239, 187, 191]);
var stringifier = function(options, state, info) {
  return {
    options,
    state,
    info,
    __transform: function(chunk, push) {
      if (!Array.isArray(chunk) && typeof chunk !== "object") {
        return Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`);
      }
      if (this.info.records === 0) {
        if (Array.isArray(chunk)) {
          if (this.options.header === true && this.options.columns === void 0) {
            return Error("Undiscoverable Columns: header option requires column option or object records");
          }
        } else if (this.options.columns === void 0) {
          const [err2, columns] = normalize_columns(Object.keys(chunk));
          if (err2) return;
          this.options.columns = columns;
        }
      }
      if (this.info.records === 0) {
        this.bom(push);
        const err2 = this.headers(push);
        if (err2) return err2;
      }
      try {
        if (this.options.on_record) {
          this.options.on_record(chunk, this.info.records);
        }
      } catch (err2) {
        return err2;
      }
      let err, chunk_string;
      if (this.options.eof) {
        [err, chunk_string] = this.stringify(chunk);
        if (err) return err;
        if (chunk_string === void 0) {
          return;
        } else {
          chunk_string = chunk_string + this.options.record_delimiter;
        }
      } else {
        [err, chunk_string] = this.stringify(chunk);
        if (err) return err;
        if (chunk_string === void 0) {
          return;
        } else {
          if (this.options.header || this.info.records) {
            chunk_string = this.options.record_delimiter + chunk_string;
          }
        }
      }
      this.info.records++;
      push(chunk_string);
    },
    stringify: function(chunk, chunkIsHeader = false) {
      if (typeof chunk !== "object") {
        return [void 0, chunk];
      }
      const { columns } = this.options;
      const record = [];
      if (Array.isArray(chunk)) {
        if (columns) {
          chunk.splice(columns.length);
        }
        for (let i = 0; i < chunk.length; i++) {
          const field = chunk[i];
          const [err, value2] = this.__cast(field, {
            index: i,
            column: i,
            records: this.info.records,
            header: chunkIsHeader
          });
          if (err) return [err];
          record[i] = [value2, field];
        }
      } else {
        for (let i = 0; i < columns.length; i++) {
          const field = get(chunk, columns[i].key);
          const [err, value2] = this.__cast(field, {
            index: i,
            column: columns[i].key,
            records: this.info.records,
            header: chunkIsHeader
          });
          if (err) return [err];
          record[i] = [value2, field];
        }
      }
      let csvrecord = "";
      for (let i = 0; i < record.length; i++) {
        let options2, err;
        let [value2, field] = record[i];
        if (typeof value2 === "string") {
          options2 = this.options;
        } else if (is_object2(value2)) {
          options2 = value2;
          value2 = options2.value;
          delete options2.value;
          if (typeof value2 !== "string" && value2 !== void 0 && value2 !== null) {
            if (err) return [Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value2)}`)];
          }
          options2 = { ...this.options, ...options2 };
          [err, options2] = normalize_options2(options2);
          if (err !== void 0) {
            return [err];
          }
        } else if (value2 === void 0 || value2 === null) {
          options2 = this.options;
        } else {
          return [Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value2)}`)];
        }
        const { delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter, escape_formulas } = options2;
        if ("" === value2 && "" === field) {
          let quotedMatch = quoted_match && quoted_match.filter((quoted_match2) => {
            if (typeof quoted_match2 === "string") {
              return value2.indexOf(quoted_match2) !== -1;
            } else {
              return quoted_match2.test(value2);
            }
          });
          quotedMatch = quotedMatch && quotedMatch.length > 0;
          const shouldQuote = quotedMatch || true === quoted_empty || true === quoted_string && false !== quoted_empty;
          if (shouldQuote === true) {
            value2 = quote + value2 + quote;
          }
          csvrecord += value2;
        } else if (value2) {
          if (typeof value2 !== "string") {
            return [Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value2)}`)];
          }
          const containsdelimiter = delimiter.length && value2.indexOf(delimiter) >= 0;
          const containsQuote = quote !== "" && value2.indexOf(quote) >= 0;
          const containsEscape = value2.indexOf(escape) >= 0 && escape !== quote;
          const containsRecordDelimiter = value2.indexOf(record_delimiter) >= 0;
          const quotedString = quoted_string && typeof field === "string";
          let quotedMatch = quoted_match && quoted_match.filter((quoted_match2) => {
            if (typeof quoted_match2 === "string") {
              return value2.indexOf(quoted_match2) !== -1;
            } else {
              return quoted_match2.test(value2);
            }
          });
          quotedMatch = quotedMatch && quotedMatch.length > 0;
          if (escape_formulas) {
            switch (value2[0]) {
              case "=":
              case "+":
              case "-":
              case "@":
              case "	":
              case "\r":
              case "\uFF1D":
              case "\uFF0B":
              case "\uFF0D":
              case "\uFF20":
                value2 = `'${value2}`;
                break;
            }
          }
          const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;
          if (shouldQuote === true && containsEscape === true) {
            const regexp = escape === "\\" ? new RegExp(escape + escape, "g") : new RegExp(escape, "g");
            value2 = value2.replace(regexp, escape + escape);
          }
          if (containsQuote === true) {
            const regexp = new RegExp(quote, "g");
            value2 = value2.replace(regexp, escape + quote);
          }
          if (shouldQuote === true) {
            value2 = quote + value2 + quote;
          }
          csvrecord += value2;
        } else if (quoted_empty === true || field === "" && quoted_string === true && quoted_empty !== false) {
          csvrecord += quote + quote;
        }
        if (i !== record.length - 1) {
          csvrecord += delimiter;
        }
      }
      return [void 0, csvrecord];
    },
    bom: function(push) {
      if (this.options.bom !== true) {
        return;
      }
      push(bom_utf8);
    },
    headers: function(push) {
      if (this.options.header === false) {
        return;
      }
      if (this.options.columns === void 0) {
        return;
      }
      let err;
      let headers = this.options.columns.map((column) => column.header);
      if (this.options.eof) {
        [err, headers] = this.stringify(headers, true);
        headers += this.options.record_delimiter;
      } else {
        [err, headers] = this.stringify(headers);
      }
      if (err) return err;
      push(headers);
    },
    __cast: function(value2, context) {
      const type = typeof value2;
      try {
        if (type === "string") {
          return [void 0, this.options.cast.string(value2, context)];
        } else if (type === "bigint") {
          return [void 0, this.options.cast.bigint(value2, context)];
        } else if (type === "number") {
          return [void 0, this.options.cast.number(value2, context)];
        } else if (type === "boolean") {
          return [void 0, this.options.cast.boolean(value2, context)];
        } else if (value2 instanceof Date) {
          return [void 0, this.options.cast.date(value2, context)];
        } else if (type === "object" && value2 !== null) {
          return [void 0, this.options.cast.object(value2, context)];
        } else {
          return [void 0, value2, value2];
        }
      } catch (err) {
        return [err];
      }
    }
  };
};

// node_modules/.pnpm/csv-stringify@6.5.1/node_modules/csv-stringify/lib/sync.js
var stringify = function(records, opts = {}) {
  const data = [];
  const [err, options] = normalize_options2(opts);
  if (err !== void 0) throw err;
  const state = {
    stop: false
  };
  const info = {
    records: 0
  };
  const api = stringifier(options, state, info);
  for (const record of records) {
    const err2 = api.__transform(record, function(record2) {
      data.push(record2);
    });
    if (err2 !== void 0) throw err2;
  }
  if (data.length === 0) {
    api.bom((d) => {
      data.push(d);
    });
    const err2 = api.headers((headers) => {
      data.push(headers);
    });
    if (err2 !== void 0) throw err2;
  }
  return data.join("");
};

// worker/web-worker/import-and-export/csv.ts
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var CsvImportAndExport = class extends BaseImportAndExport {
  async guessColumnType(content) {
    const records = parse(content, {
      columns: true,
      skip_empty_lines: true,
      to: 1e3
    });
    const sampleSize = Math.min(10, records.length);
    const sampledRecords = [];
    const seen = /* @__PURE__ */ new Set();
    while (sampledRecords.length < sampleSize) {
      const randomIndex = Math.floor(Math.random() * records.length);
      if (!seen.has(randomIndex)) {
        seen.add(randomIndex);
        sampledRecords.push(records[randomIndex]);
      }
    }
    const columnTypes = {};
    for (let columnIndex = 0; columnIndex < Object.keys(sampledRecords[0]).length; columnIndex++) {
      const columnName = Object.keys(sampledRecords[0])[columnIndex];
      let columnType = "String";
      const columnDataList = sampledRecords.map((record) => record[columnName]).filter((value2) => value2 !== null && value2 !== void 0);
      if (columnDataList.length === 0) {
        columnTypes[columnName] = columnType;
        continue;
      }
      const _isNumber = columnDataList.every((value2) => {
        return !isNaN(Number(value2));
      });
      if (_isNumber) {
        columnType = "Number";
      }
      columnTypes[columnName] = columnType;
    }
    return columnTypes;
  }
  async import(file, dataSpace) {
    dataSpace.blockUIMsg("Starting import...");
    const nodeName = file.name?.replace(/\.[^/.]+$/, "");
    const tableId = v4_default().split("-").join("");
    let tm = new TableManager(tableId, dataSpace);
    const batchSize = 2e4;
    const start = performance.now();
    try {
      if (!file.content.trim()) {
        throw new Error("CSV file is empty");
      }
      const firstParseResult = parse(file.content, {
        columns: (headers) => {
          return headers.map((header2, index) => {
            const cleaned = (header2 || "").trim();
            return cleaned || `unknown${index}`;
          });
        },
        skip_empty_lines: true,
        to: 1
      });
      console.log("Parse result:", firstParseResult);
      console.log("Header row:", firstParseResult[0]);
      if (!Array.isArray(firstParseResult) || firstParseResult.length === 0) {
        throw new Error("Failed to parse CSV header");
      }
      const headerRow = firstParseResult[0];
      if (!headerRow || typeof headerRow !== "object") {
        throw new Error("Invalid CSV header format");
      }
      let columns = Object.keys(headerRow);
      if (columns.length === 0) {
        throw new Error("No columns found in CSV");
      }
      const previewContent = file.content.split("\n").slice(0, 1001).join("\n");
      dataSpace.blockUIMsg("Analyzing file structure...");
      const types2 = await this.guessColumnType(previewContent);
      const lines = file.content.split("\n").filter((line) => line.trim());
      if (lines.length < 2) {
        throw new Error("CSV file must contain at least one data row");
      }
      const header = lines[0];
      const rawTableName = getRawTableNameById(tableId);
      let rawColumns = columns.map((column) => generateColumnName());
      let createTableSql = `
CREATE TABLE ${rawTableName} (
  _id TEXT PRIMARY KEY NOT NULL,
  title TEXT  NULL,
  _created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  _last_edited_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  _created_by TEXT DEFAULT 'unknown',
  _last_edited_by TEXT DEFAULT 'unknown',
  
`;
      rawColumns.forEach((column, index) => {
        const type = types2[columns[index]];
        const isLastColumn = index === rawColumns.length - 1;
        createTableSql += `${column} ${type === "Number" ? "REAL" : "TEXT"} NULL` + (isLastColumn ? "\n" : ",\n");
      });
      createTableSql += `);`;
      const typeFieldMap = {
        String: "text" /* Text */,
        Number: "number" /* Number */,
        Date: "date" /* Date */
      };
      columns.forEach((column, index) => {
        const type = types2[column];
        const isFirstColumn = index === 0;
        const fieldType = isFirstColumn ? "title" : typeFieldMap[type] || "text" /* Text */;
        const rawColumn = isFirstColumn ? "title" : rawColumns[index];
        const _column = column.replace(/'/g, "''");
        createTableSql += `INSERT INTO ${ColumnTableName}(name, type, table_name, table_column_name) VALUES ('${_column}', '${fieldType}', '${rawTableName}', '${rawColumn}');`;
      });
      dataSpace.blockUIMsg("Creating table...");
      await dataSpace.createTableViaSchema(tableId, nodeName, createTableSql);
      await sleep(1e3);
      const fieldMap = await tm.rows.getFieldMap();
      const cacheSize = 2 * 1024 * 1024;
      await dataSpace.db.exec("PRAGMA synchronous = 0;");
      await dataSpace.db.exec(`PRAGMA cache_size = ${cacheSize};`);
      await dataSpace.db.exec("PRAGMA locking_mode = EXCLUSIVE;");
      await dataSpace.db.exec("PRAGMA temp_store = MEMORY;");
      console.log("locksInfo:", await dataSpace.sql`PRAGMA locking_mode`);
      const dataLines = lines.slice(1);
      const totalRows = dataLines.length;
      let processedRows = 0;
      let lastUIUpdate = Date.now();
      const UI_UPDATE_INTERVAL = 500;
      dataSpace.blockUIMsg("Importing data...");
      for (let i = 0; i < dataLines.length; i += batchSize) {
        const batchLines = [header, ...dataLines.slice(i, i + batchSize)];
        const batchContent = batchLines.join("\n");
        let records;
        try {
          records = parse(batchContent, {
            columns: (headers) => {
              return headers.map((header2, index) => {
                const cleaned = (header2 || "").trim();
                return cleaned || `unknown${index}`;
              });
            },
            skip_empty_lines: true,
            relax_column_count: true
          });
          records.shift();
          records = records.filter((record) => {
            return record && typeof record === "object" && Object.keys(record).length > 0 && !Object.keys(record).includes("");
          });
          if (records.length > 0) {
            await tm.rows.batchSyncCreate(records, fieldMap);
            processedRows += records.length;
          }
        } catch (err) {
          console.warn(`Error processing batch at index ${i}:`, err);
          continue;
        }
        const now = Date.now();
        if (now - lastUIUpdate >= UI_UPDATE_INTERVAL) {
          dataSpace.blockUIMsg("Importing data...", {
            progress: processedRows / totalRows * 100
          });
          lastUIUpdate = now;
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
        if (i % (batchSize * 5) === 0) {
          await new Promise((resolve) => setTimeout(resolve, 50));
        }
      }
      const end = performance.now();
      console.log("import csv file done", end - start);
      dataSpace.blockUIMsg(null);
      return tableId;
    } catch (error) {
      console.error("CSV import error:", error);
      dataSpace.blockUIMsg(null);
      throw error;
    } finally {
      await dataSpace.db.exec("PRAGMA journal_mode = WAL;");
      await dataSpace.db.exec("PRAGMA synchronous = 1;");
      await dataSpace.db.exec("PRAGMA locking_mode = NORMAL;");
    }
  }
  async export(nodeId, dataSpace) {
    const tableName = getRawTableNameById(nodeId);
    const columns = await dataSpace.column.list({ table_name: tableName });
    const columnNames = columns.map((column) => column.name);
    const tm = new TableManager(nodeId, dataSpace);
    const rows = await tm.rows.query();
    const csv = stringify(rows, { header: true, columns: columnNames });
    if (typeof csv === "string") {
      return csv;
    } else {
      return new Promise((resolve, reject) => {
        const chunks = [];
        csv.on("data", (chunk) => chunks.push(chunk.toString())).on("error", reject).on("end", () => resolve(chunks.join("")));
      });
    }
  }
};

// worker/web-worker/import-and-export/markdown.ts
var MarkdownImportAndExport = class extends BaseImportAndExport {
  async import(file, dataSpace) {
    const nodeId = uuidv7().split("-").join("");
    const nodeName = file.name.replace(/\.[^/.]+$/, "");
    await dataSpace.createOrUpdateDocWithMarkdown(
      nodeId,
      file.content,
      void 0,
      nodeName
    );
    return nodeId;
  }
  async export(nodeId, dataSpace) {
    const node = await dataSpace.getTreeNode(nodeId);
    const markdown = await dataSpace.getDocMarkdown(nodeId);
    return markdown;
  }
};

// worker/web-worker/meta-table/action.ts
var ActionTable = class extends BaseTableImpl {
  constructor() {
    super(...arguments);
    __publicField(this, "name", ActionTableName);
    __publicField(this, "createTableSql", `
  CREATE TABLE IF NOT EXISTS ${this.name} (
    id TEXT PRIMARY KEY,
    name TEXT,
    params TEXT,
    nodes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
`);
    __publicField(this, "JSONFields", ["params", "nodes"]);
  }
  add(data) {
    this.dataSpace.exec2(`INSERT INTO ${this.name} VALUES (?, ?, ?, ?)`, [
      data.id,
      data.name,
      JSON.stringify(data.params),
      JSON.stringify(data.nodes)
    ]);
    return Promise.resolve(data);
  }
  set(id, data) {
    this.dataSpace.exec2(
      `UPDATE ${this.name} SET name = ?, nodes = ? WHERE id = ?`,
      [data.name, JSON.stringify(data.nodes), id]
    );
    return Promise.resolve(true);
  }
  del(id) {
    this.dataSpace.exec2(`DELETE FROM ${this.name} WHERE id = ?`, [id]);
    return Promise.resolve(true);
  }
};

// worker/web-worker/meta-table/doc.ts
var _DocTable = class _DocTable extends BaseTableImpl {
  constructor() {
    super(...arguments);
    __publicField(this, "name", DocTableName);
    __publicField(this, "createFTSSql", this.dataSpace.hasLoadExtension ? `
  CREATE VIRTUAL TABLE IF NOT EXISTS fts_docs USING fts5(id,markdown, content='${this.name}',tokenize = 'simple');
  ` : `CREATE VIRTUAL TABLE IF NOT EXISTS fts_docs USING fts5(id,markdown, content='${this.name}');`);
    __publicField(this, "createTableSql", `
  CREATE TABLE IF NOT EXISTS ${this.name} (
    id TEXT PRIMARY KEY,
    content TEXT,
    is_day_page BOOLEAN DEFAULT 0,
    markdown TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );


  CREATE TRIGGER IF NOT EXISTS update_time_trigger__${this.name}
  AFTER UPDATE ON ${this.name}
  FOR EACH ROW
  BEGIN
    UPDATE ${this.name} SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
  END;
    ${this.createFTSSql}    
  CREATE TEMP TRIGGER IF NOT EXISTS ${this.name}_ai AFTER INSERT ON ${this.name} BEGIN
    INSERT INTO fts_docs(rowid,id, markdown) VALUES (new.rowid, new.id, new.markdown);
  END;

  CREATE TEMP TRIGGER IF NOT EXISTS ${this.name}_ad AFTER DELETE ON ${this.name} BEGIN
    INSERT INTO fts_docs(fts_docs, rowid, id,markdown) VALUES('delete', old.rowid, old.id, old.markdown);
  END;
  
  CREATE TEMP TRIGGER IF NOT EXISTS ${this.name}_au AFTER UPDATE ON ${this.name} BEGIN
    INSERT INTO fts_docs(fts_docs, rowid, id, markdown) VALUES('delete', old.rowid, old.id, old.markdown);
    INSERT INTO fts_docs(rowid, id, markdown) VALUES (new.rowid, new.id, new.markdown);
  END;
`);
    /**
     * for now lexical's code node depends on the browser's dom, so we can't use lexical in worker.
     * wait for lexical improve code node to support worker
     * @param type
     * @param data
     * @returns
     */
    __publicField(this, "callMain", (type, data) => {
      return this.dataSpace.callRenderer?.(type, data);
    });
  }
  async rebuildIndex(opts) {
    const { refillNullMarkdown, recreateFtsTable } = opts;
    if (recreateFtsTable) {
      await this.dataSpace.db.exec(`
        DROP TRIGGER IF EXISTS ${this.name}_ai;
        DROP TRIGGER IF EXISTS ${this.name}_ad;
        DROP TRIGGER IF EXISTS ${this.name}_au;
      `);
      await this.dataSpace.exec2(`DROP TABLE IF EXISTS fts_docs;`);
      await this.dataSpace.exec2(this.createFTSSql);
      console.log(`Recreated fts_docs table and triggers for ${this.dataSpace.dbName}`);
    }
    await this.dataSpace.exec2(
      `INSERT INTO fts_docs(fts_docs) VALUES('rebuild');`
    );
    if (refillNullMarkdown) {
      const res = await this.dataSpace.exec2(
        `SELECT id, markdown FROM ${this.name}`
      );
      for (const item of res) {
        if (item.markdown == null) {
          const markdown = await this.getMarkdown(item.id);
          try {
            await this.dataSpace.exec2(
              `UPDATE ${this.name} SET markdown = ? WHERE id = ?`,
              [markdown, item.id]
            );
            console.log(`update ${item.id} markdown`);
          } catch (error) {
            console.warn(`update ${item.id} markdown error`, error);
          }
        }
      }
    }
    await this.dataSpace.exec2(
      `INSERT INTO fts_docs(fts_docs) VALUES('rebuild');`
    );
    console.log(`rebuild ${this.dataSpace.dbName} index`);
  }
  async listAllDayPages() {
    const res = await this.dataSpace.exec2(
      `SELECT id FROM ${this.name} WHERE is_day_page = 1 AND markdown != '' ORDER BY id DESC`
    );
    return res.map((item) => ({
      id: item.id
    }));
  }
  async listDayPage(page = 0) {
    const pageSize = 7;
    const res = await this.dataSpace.exec2(
      `SELECT id FROM ${this.name} WHERE is_day_page = 1 ORDER BY id DESC LIMIT ?,?`,
      [page * pageSize, pageSize]
    );
    return res.map((item) => ({
      id: item.id
    }));
  }
  async del(id) {
    this.dataSpace.exec(`DELETE FROM ${this.name} WHERE id = ?`, [id]);
    return true;
  }
  async getMarkdown(id) {
    const doc = await this.get(id);
    return doc?.markdown || "";
  }
  async getBaseInfo(id) {
    const res = await this.dataSpace.exec2(
      `SELECT id, created_at, updated_at FROM ${this.name} WHERE id = ?`,
      [id]
    );
    return res[0];
  }
  async search(query) {
    const res = await this.dataSpace.exec2(
      `SELECT id, snippet(fts_docs, 1, '<b>', '</b>','...',127) as result FROM fts_docs(?);`,
      [query]
    );
    return res.reverse();
  }
  async createOrUpdateWithMarkdown(id, mdStr) {
    const content = await this.callMain(
      "ConvertMarkdown2State" /* ConvertMarkdown2State */,
      mdStr
    );
    return this._createOrUpdate(id, content, mdStr);
  }
  async createOrUpdate(data) {
    const { id, text, type, mode = "replace" } = data;
    switch (type) {
      case "html":
        const content = await this.callMain(
          "ConvertHtml2State" /* ConvertHtml2State */,
          text
        );
        const markdown = await this.callMain(
          "GetDocMarkdown" /* GetDocMarkdown */,
          content
        );
        return this._createOrUpdate(id, content, markdown, mode);
      case "markdown":
        const content2 = await this.callMain(
          "ConvertMarkdown2State" /* ConvertMarkdown2State */,
          text
        );
        return this._createOrUpdate(id, content2, text, mode);
      case "email":
        const content3 = await this.callMain("ConvertEmail2State" /* ConvertEmail2State */, {
          space: this.dataSpace.dbName,
          email: text
        });
        const markdown3 = await this.callMain(
          "GetDocMarkdown" /* GetDocMarkdown */,
          content3
        );
        return this._createOrUpdate(id, content3, markdown3, mode);
      default:
        throw new Error(`unknown type ${type}`);
    }
  }
  async _createOrUpdate(id, content, markdown, mode = "replace") {
    let is_day_page = /^\d{4}-\d{2}-\d{2}$/.test(id);
    const res = await this.get(id);
    try {
      if (!res) {
        await this.add({
          id,
          content,
          is_day_page,
          markdown
        });
      } else {
        switch (mode) {
          case "replace":
            await this.set(id, {
              id,
              is_day_page,
              content,
              markdown
            });
            break;
          case "prepend":
            await this.set(id, {
              id,
              is_day_page,
              content: _DocTable.mergeState(content, res.content),
              markdown: markdown + "\n" + res.markdown
            });
            break;
          case "append":
            await this.set(id, {
              id,
              is_day_page,
              content: _DocTable.mergeState(res.content, content),
              markdown: res.markdown + "\n" + markdown
            });
            break;
          default:
            throw new Error(`unknown mode ${mode}`);
        }
      }
      return {
        id,
        success: true
      };
    } catch (error) {
      console.error(error);
      return {
        id,
        success: false,
        msg: `${JSON.stringify(error)}`
      };
    }
  }
};
__publicField(_DocTable, "mergeState", (oldState, newState) => {
  const _oldState = JSON.parse(
    oldState
  );
  const _appendState = JSON.parse(
    newState
  );
  _oldState.root.children.push(..._appendState.root.children);
  return JSON.stringify(_oldState);
});
var DocTable = _DocTable;

// worker/web-worker/meta-table/embedding.ts
var EmbeddingTable = class extends BaseTableImpl {
  constructor() {
    super(...arguments);
    __publicField(this, "name", EmbeddingTableName);
    __publicField(this, "createTableSql", `
CREATE TABLE IF NOT EXISTS ${this.name} (
    id TEXT PRIMARY KEY,
    embedding TEXT,
    model TEXT,
    raw_content TEXT,
    source_type TEXT,
    source TEXT
);
`);
  }
  add(data) {
    this.dataSpace.exec(
      `INSERT INTO ${this.name} (id, embedding, model, raw_content, source_type, source) VALUES (?, ?, ?, ?, ?, ?)`,
      [
        data.id,
        data.embedding,
        data.model,
        data.raw_content,
        data.source_type,
        data.source
      ]
    );
    return Promise.resolve(data);
  }
  get(id) {
    throw new Error("Method not implemented.");
  }
  set(id, data) {
    throw new Error("Method not implemented.");
  }
  del(id) {
    throw new Error("Method not implemented.");
  }
};

// worker/web-worker/meta-table/file.ts
var FileTable = class extends BaseTableImpl {
  constructor() {
    super(...arguments);
    __publicField(this, "name", FileTableName);
    __publicField(this, "createTableSql", `
CREATE TABLE IF NOT EXISTS ${this.name} (
    id TEXT PRIMARY KEY,
    name TEXT,
    path TEXT UNIQUE,
    size INTEGER,
    mime TEXT,
    is_vectorized INTEGER DEFAULT 0 NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);  
`);
  }
  /**
   * save file to efs
   * @param url a url of file
   * @param subDir sub directory of file, default is [], which means save file to spaces/\<space\>/files/, if subDir is ["a","b"], then save file to spaces/\<space\>/files/a/b/
   * @param _name file name, default is null, which means use the file name in url
   * @returns
   */
  async saveFile2EFS(url, subDir, _name) {
    if (typeof url === "string") {
      const fileId = getUuid();
      const blob = await fetch(url).then((res) => res.blob());
      const name2 = _name || url.split("/").pop();
      const file = new File([blob], name2, { type: blob.type });
      const space2 = this.dataSpace.dbName;
      const dirs = ["spaces", space2, "files", ...subDir];
      const paths = await this.dataSpace.efsManager?.addFile(dirs, file, _name ? _name : fileId);
      if (!paths) {
        throw new Error("add file failed");
      }
      const path = paths.join("/");
      const size = file.size;
      const oldFile = await this.getFileByPath(path);
      if (oldFile) {
        return oldFile;
      }
      const fileObj = this.add({
        id: fileId,
        name: name2,
        path,
        size,
        mime: file.type
      });
      return fileObj;
    }
    return null;
  }
  async add(data) {
    this.dataSpace.exec(
      `INSERT INTO ${this.name} (id,name,path,size,mime) VALUES (? , ? , ? , ? , ?);`,
      [data.id, data.name, data.path, data.size, data.mime]
    );
    return data;
  }
  async getFileByPath(path) {
    const res = await this.dataSpace.exec2(
      `SELECT * FROM ${this.name} WHERE path = ?;`,
      [path]
    );
    if (res.length === 0) {
      return null;
    }
    return res[0];
  }
  async deleteFileByPathPrefix(prefix) {
    try {
      this.dataSpace.exec(`DELETE FROM ${this.name} WHERE path LIKE ?;`, [
        `${prefix}%`
      ]);
      return Promise.resolve(true);
    } catch (error) {
      return Promise.resolve(false);
    }
  }
  async updateVectorized(id, is_vectorized) {
    try {
      this.dataSpace.exec(
        `UPDATE ${this.name} SET is_vectorized = ? WHERE id = ?;`,
        [is_vectorized ? 1 : 0, id]
      );
      return Promise.resolve(true);
    } catch (error) {
      return Promise.resolve(false);
    }
  }
  async get(id) {
    const res = await this.dataSpace.exec2(
      `SELECT * FROM ${this.name} WHERE id = ?;`,
      [id]
    );
    if (res.length === 0) {
      return null;
    }
    return res[0];
  }
  del(id) {
    try {
      this.dataSpace.exec(`DELETE FROM ${this.name} WHERE id = ?;`, [id]);
      return Promise.resolve(true);
    } catch (error) {
      return Promise.resolve(false);
    }
  }
  /**
   * get blob url of file
   * in script or extension environment we can't access opfs file directly, so we need to use blob url to access it.
   * @param id file id
   * @returns
   */
  async getBlobURL(id) {
    const file = await this.get(id);
    if (!file) {
      throw new Error("file not found");
    }
    return this.getBlobURLbyPath(file.path);
  }
  async getBlobURLbyPath(path) {
    const f = await this.dataSpace.efsManager?.getFileByPath(path);
    if (!f) {
      throw new Error("file not found");
    }
    return URL.createObjectURL(f);
  }
  async getBlobByPath(path) {
    let fileManager = this.dataSpace.efsManager;
    let f = null;
    if (path.startsWith("/@/")) {
      const extFolderName = path.split("/")[2];
      fileManager = await getExternalFolderManager(extFolderName);
      const paths = decodeURIComponent(path).split("/").filter(Boolean).slice(2);
      f = await fileManager.getFile(paths);
    } else {
      if (!fileManager) {
        throw new Error("file manager not found");
      }
      f = await fileManager.getFileByPath(path);
    }
    const blob = new Blob([f], { type: f.type });
    return blob;
  }
  async walk() {
    const fileManager = this.dataSpace.efsManager;
    if (!fileManager) {
      throw new Error("file manager not found");
    }
    const allFiles = await fileManager.walk([
      "spaces",
      this.dataSpace.dbName,
      "files"
    ]);
    console.log("allFiles", allFiles);
    return allFiles;
  }
  // transform file system
  async transformFileSystem(sourceFs, targetFs) {
    const callback = async (data) => {
      console.log(`current: ${data.current}/${data.total} ${data.msg}`);
      this.dataSpace.blockUIMsg(
        `current: ${data.current}/${data.total} ${data.msg}`,
        {
          progress: data.current / data.total * 100
        }
      );
      if (data.current === data.total) {
        this.dataSpace.blockUIMsg(null);
      }
    };
    if (sourceFs !== targetFs) {
      const sourceFsManager = new EidosFileSystemManager(
        await getFsRootHandle(sourceFs)
      );
      const targetFsManager = new EidosFileSystemManager(
        await getFsRootHandle(targetFs)
      );
      const ignoreSqlite = targetFs === "opfs" /* OPFS */;
      await sourceFsManager.copyTo(
        targetFsManager,
        {
          ignoreSqlite
        },
        callback
      );
    }
  }
  async uploadDir(dirHandle, total, current, _parentPath) {
    const space2 = this.dataSpace.dbName;
    let parentPath = _parentPath || ["spaces", space2, "files"];
    if (!this.dataSpace.efsManager) {
      throw new Error("file manager not found");
    }
    await this.dataSpace.efsManager.addDir(parentPath, dirHandle.name);
    parentPath = [...parentPath, dirHandle.name];
    for await (const [key, value2] of dirHandle.entries()) {
      if (value2.kind === "directory") {
        await this.uploadDir(
          value2,
          total,
          current,
          parentPath
        );
      } else if (value2.kind === "file") {
        try {
          const file = await value2.getFile();
          const fileId = getUuid();
          const paths = await this.dataSpace.efsManager.addFile(parentPath, file);
          if (!paths) {
            throw new Error("add file failed");
          }
          const { name: name2, size, type: mime } = file;
          const path = paths.join("/");
          const fileInfo = {
            id: fileId,
            name: name2,
            size,
            mime,
            path
          };
          await this.add(fileInfo);
        } catch (error) {
        } finally {
          current++;
          this.dataSpace.blockUIMsg(`uploading ${name}`, {
            progress: current / total * 100
          });
        }
      }
    }
  }
  /**
   * Upload a file to EFS with specified parent path
   * @param fileData File data as ArrayBuffer or base64 string
   * @param fileName Original file name
   * @param mimeType File mime type
   * @param parentPath Parent path array, defaults to ["spaces", <space>, "files"]
   * @returns Uploaded file info
   */
  async upload(fileData, fileName, mimeType, parentPath) {
    const space2 = this.dataSpace.dbName;
    const rootPath = ["spaces", space2, "files"];
    const basePath = [...rootPath, ...parentPath || []];
    if (!this.dataSpace.efsManager) {
      throw new Error("file manager not found");
    }
    const fileId = getUuid();
    const blob = typeof fileData === "string" ? new Blob([Buffer.from(fileData, "base64")], { type: mimeType }) : new Blob([fileData], { type: mimeType });
    const file = new File([blob], fileName, { type: mimeType });
    const paths = await this.dataSpace.efsManager.addFile(basePath, file);
    if (!paths) {
      throw new Error("add file failed");
    }
    const path = paths.join("/");
    const fileInfo = {
      id: fileId,
      name: fileName,
      size: file.size,
      mime: mimeType,
      path
    };
    const fileObj = await this.add(fileInfo);
    return {
      ...fileObj,
      publicUrl: this.dataSpace.efsManager.getFileUrlByPath(path)
    };
  }
};

// worker/web-worker/meta-table/reference.ts
var ReferenceTable = class extends BaseTableImpl {
  constructor() {
    super(...arguments);
    __publicField(this, "name", ReferenceTableName);
    __publicField(this, "createTableSql", `
  CREATE TABLE IF NOT EXISTS ${this.name} (
    self_table_name TEXT,
    self_table_column_name TEXT,
    ref_table_name TEXT,
    ref_table_column_name TEXT,
    link_table_name TEXT,
    link_table_column_name TEXT,
    self GENERATED ALWAYS AS (self_table_name || '.' || self_table_column_name) STORED,
    ref GENERATED ALWAYS AS (ref_table_name || '.' || ref_table_column_name) STORED,
    link GENERATED ALWAYS AS (link_table_name || '.' || link_table_column_name) STORED,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (self_table_name, self_table_column_name, ref_table_name, ref_table_column_name, link_table_name, link_table_column_name),
    FOREIGN KEY (self_table_name, self_table_column_name) REFERENCES ${ColumnTableName}(table_name, table_column_name) ON DELETE CASCADE
  );
`);
    __publicField(this, "getEffectedFields", async (table_name, table_column_name) => {
      const sql = `
      SELECT * FROM ${this.name} WHERE (
        (ref_table_name = ? AND ref_table_column_name = ?) OR (link_table_name = ? AND link_table_column_name = ?)
      )
    `;
      const result = await this.dataSpace.syncExec2(sql, [
        table_name,
        table_column_name,
        table_name,
        table_column_name
      ]);
      return result.map((r) => ({
        table_name: r.self_table_name,
        table_column_name: r.self_table_column_name
      }));
    });
  }
  del(id) {
    throw new Error("Method not implemented.");
  }
};

// worker/web-worker/meta-table/script.ts
var ScriptTable = class extends BaseTableImpl {
  constructor() {
    super(...arguments);
    __publicField(this, "name", ScriptTableName);
    __publicField(this, "createTableSql", `
    CREATE TABLE IF NOT EXISTS ${this.name} (
        id TEXT PRIMARY KEY,
        name TEXT,
        description TEXT,
        type TEXT DEFAULT 'script',
        version TEXT,
        code TEXT,
        ts_code TEXT,
        model TEXT,
        prompt_config TEXT,
        commands TEXT,
        tables TEXT,
        envs TEXT,
        env_map TEXT,
        fields_map TEXT,
        enabled BOOLEAN DEFAULT 0,
        bindings TEXT,
        dependencies TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
`);
    __publicField(this, "JSONFields", [
      "commands",
      "tables",
      "envs",
      "env_map",
      "fields_map",
      "prompt_config",
      "bindings",
      "dependencies"
    ]);
  }
  async del(id) {
    await this.dataSpace.db.transaction(async () => {
      await this.dataSpace.exec2(`DELETE FROM ${this.name} WHERE id = ?`, [id]);
      const chatIds = await this.dataSpace.chat.getChatIdsByProjectId(id);
      await Promise.all(chatIds.map((chatId) => this.dataSpace.chat.delete(chatId)));
    });
    return true;
  }
  async enable(id) {
    this.dataSpace.exec2(`UPDATE ${this.name} SET enabled = 1 WHERE id = ?`, [
      id
    ]);
    return Promise.resolve(true);
  }
  async disable(id) {
    this.dataSpace.exec2(`UPDATE ${this.name} SET enabled = 0 WHERE id = ?`, [
      id
    ]);
    return Promise.resolve(true);
  }
  async updateEnvMap(id, env_map) {
    this.dataSpace.exec2(`UPDATE ${this.name} SET env_map = ? WHERE id = ?`, [
      JSON.stringify(env_map),
      id
    ]);
    return Promise.resolve(true);
  }
};

// worker/web-worker/meta-table/tree.ts
var TreeTable = class extends BaseTableImpl {
  constructor() {
    super(...arguments);
    __publicField(this, "name", TreeTableName);
    __publicField(this, "createTableSql", `
  CREATE TABLE IF NOT EXISTS ${TreeTableName} (
    id TEXT PRIMARY KEY NOT NULL,
    name TEXT,
    type TEXT,
    parent_id TEXT NULL,
    is_pinned BOOLEAN DEFAULT 0,
    is_full_width BOOLEAN DEFAULT 0,
    is_locked BOOLEAN DEFAULT 0,
    icon TEXT NULL,
    cover TEXT NULL,
    is_deleted BOOLEAN DEFAULT 0,
    hide_properties BOOLEAN DEFAULT 0,
    position REAL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
  
  CREATE TEMP TRIGGER IF NOT EXISTS ${TreeTableName}_insert_trigger
  AFTER INSERT ON ${TreeTableName}
  BEGIN
    SELECT eidos_meta_table_event_insert(
      '${TreeTableName}',
      json_object(
        'id', new.id,
        'name', new.name,
        'type', new.type,
        'parent_id', new.parent_id,
        'is_pinned', new.is_pinned,
        'is_full_width', new.is_full_width,
        'is_locked', new.is_locked,
        'icon', new.icon,
        'cover', new.cover,
        'is_deleted', new.is_deleted,
        'hide_properties', new.hide_properties,
        'position', new.position,
        'created_at', new.created_at,
        'updated_at', new.updated_at
      )
    );
  END;
  `);
    __publicField(this, "getNextRowId", async () => {
      const res = await this.dataSpace.exec2(
        `SELECT max(rowid) as maxId from ${TreeTableName};`
      );
      return res[0].maxId + 1;
    });
  }
  async add(data) {
    const nextPosition = await this.getNextRowId();
    this.dataSpace.exec(
      `INSERT INTO ${TreeTableName} (id,name,type,parent_id,position) VALUES (? , ? , ? , ?,?);`,
      [data.id, data.name, data.type, data.parent_id, nextPosition]
    );
    return Promise.resolve({
      ...data,
      position: nextPosition
    });
  }
  async get(id) {
    const res = await this.dataSpace.exec2(
      `SELECT * FROM ${TreeTableName} where id = ?;`,
      [id]
    );
    if (res.length === 0) {
      return null;
    }
    return res[0];
  }
  async updateName(id, name2) {
    try {
      await this.dataSpace.exec2(
        `UPDATE ${TreeTableName} SET name = ? WHERE id = ?;`,
        [name2, id]
      );
      return Promise.resolve(true);
    } catch (error) {
      return Promise.resolve(false);
    }
  }
  async pin(id, is_pinned) {
    await this.dataSpace.exec2(
      `UPDATE ${TreeTableName} SET is_pinned = ? WHERE id = ?;`,
      [is_pinned, id]
    );
    return Promise.resolve(true);
  }
  async del(id, db2 = this.dataSpace.db) {
    this.dataSpace.syncExec2(
      `DELETE FROM ${TreeTableName} WHERE id = ?`,
      [id],
      db2
    );
    return true;
  }
  // @deprecated Proxy can't pass to main thread
  makeProxyRow(row) {
    const dataSpace = this.dataSpace;
    return new Proxy(row, {
      get(target, p, receiver) {
        if (p === "children") {
          return [];
        }
        return Reflect.get(target, p, receiver);
      },
      set(target, p, value2, receiver) {
        dataSpace.exec(`UPDATE ${TreeTableName} SET ${p} = ? WHERE id = ?;`, [
          value2,
          target.id
        ]);
        return Reflect.set(target, p, value2, receiver);
      }
    });
  }
  async query(qs) {
    const { query, withSubNode } = qs;
    let sql = `SELECT * FROM ${TreeTableName} `;
    if (query) {
      sql += ` WHERE name like ?`;
    }
    if (query && !withSubNode) {
      sql += ` AND parent_id is null`;
    }
    sql += ` ORDER BY position DESC;`;
    const bind = query ? [`%${query}%`] : void 0;
    const res = await this.dataSpace.exec2(sql, bind);
    return res.map((row) => row);
  }
  async moveIntoTable(id, tableId, parentId) {
    try {
      await this.dataSpace.db.transaction(async (db2) => {
        this.dataSpace.syncExec2(
          `UPDATE ${TreeTableName} SET parent_id = ? WHERE id = ?;`,
          [tableId, id],
          db2
        );
        const tableName = getRawTableNameById(tableId);
        const title = (await this.get(id))?.name;
        if (parentId) {
          const parentTableName = getRawTableNameById(parentId);
          this.dataSpace.syncExec2(
            `DELETE FROM ${parentTableName} WHERE _id = ?;`,
            [extractIdFromShortId(id)],
            db2
          );
        }
        this.dataSpace.syncExec2(
          `INSERT INTO ${tableName} (_id,title) VALUES (?,?);`,
          [extractIdFromShortId(id), title],
          db2
        );
      });
      return Promise.resolve(true);
    } catch (error) {
      return Promise.resolve(false);
    }
  }
  /**
   * id: uuid without '-'
   * miniId: last 8 char of id. most of time, it's enough to identify a node
   * @param idOrMiniId
   */
  async getNode(idOrMiniId) {
    const res = await this.dataSpace.exec2(
      `SELECT * FROM ${TreeTableName} WHERE id = ? OR substr(id, -8) = ?;`,
      [idOrMiniId, idOrMiniId]
    );
    return res.length > 0 ? res[0] : null;
  }
  async checkLoop(id, parentId) {
    if (id === parentId) {
      throw new Error("Can't move into a child node");
    } else {
      const adjacencyList = await this.getAdjacencyList();
      const visited = /* @__PURE__ */ new Set();
      const hasLoop = this.dfs(adjacencyList, visited, id, parentId);
      if (hasLoop) {
        throw new Error("Can't move into a child node");
      }
    }
  }
  async getAdjacencyList() {
    const res = await this.dataSpace.exec2(
      `SELECT id, parent_id FROM ${TreeTableName}`
    );
    const adjacencyList = /* @__PURE__ */ new Map();
    for (const row of res) {
      if (!adjacencyList.has(row.parent_id)) {
        adjacencyList.set(row.parent_id, []);
      }
      adjacencyList.get(row.parent_id).push(row.id);
    }
    return adjacencyList;
  }
  dfs(adjacencyList, visited, node, target) {
    if (node === target) {
      return true;
    }
    visited.add(node);
    const neighbors = adjacencyList.get(node) || [];
    for (const neighbor of neighbors) {
      if (!visited.has(neighbor) && this.dfs(adjacencyList, visited, neighbor, target)) {
        return true;
      }
    }
    return false;
  }
  async getPosition(props) {
    const { parentId, targetId, targetDirection } = props;
    const parentChildren = await this.list(
      { parent_id: parentId || null },
      {
        orderBy: "position",
        order: "DESC"
      }
    );
    const targetIndex = parentChildren.findIndex((node) => node.id === targetId);
    const prevIndex = targetDirection === "up" ? targetIndex - 1 : targetIndex;
    const nextIndex = targetDirection === "up" ? targetIndex : targetIndex + 1;
    const prevNode = parentChildren[prevIndex];
    const nextNode = parentChildren[nextIndex];
    const newPosition = () => {
      if (prevIndex === -1) {
        return nextNode?.position + 0.5;
      }
      if (!nextNode) {
        return prevNode?.position / 2;
      }
      return ((prevNode?.position || 0) + nextNode?.position) / 2;
    };
    return newPosition();
  }
};

// lib/sqlite/sql-parser.ts
var import_pgsql_ast_parser4 = __toESM(require_pgsql_ast_parser(), 1);
var replaceQueryTableName = (query, tableNameMap) => {
  const ast = (0, import_pgsql_ast_parser4.parseFirst)(query);
  const selectStatement = ast;
  selectStatement.from?.forEach((from) => {
    if (from.type === "table") {
      const tableName = from.name.name;
      from.name.name = tableNameMap[tableName] ?? tableName;
    }
  });
  return import_pgsql_ast_parser4.toSql.statement(selectStatement);
};
var replaceWithFindIndexQuery = (query, rowId) => {
  const ast = (0, import_pgsql_ast_parser4.parseFirst)(query);
  const selectStatement = ast;
  selectStatement.columns?.length && selectStatement.columns.push({
    expr: {
      type: "call",
      function: {
        name: "row_number"
      },
      args: [],
      over: {
        orderBy: selectStatement.orderBy
      }
    },
    alias: {
      name: "_index_in_view"
    }
  });
  let querySql = import_pgsql_ast_parser4.toSql.statement(selectStatement);
  querySql = `WITH RankedResults AS (
${querySql}
)
SELECT
  _index_in_view
FROM
  RankedResults
WHERE
  _id = '${rowId}';`;
  return querySql;
};

// worker/web-worker/meta-table/view.ts
var ViewTable = class extends BaseTableImpl {
  constructor() {
    super(...arguments);
    __publicField(this, "name", ViewTableName);
    __publicField(this, "createTableSql", `
CREATE TABLE IF NOT EXISTS ${this.name} (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  type TEXT NOT NULL,
  table_id TEXT NOT NULL,
  query TEXT NOT NULL,
  properties TEXT,
  filter TEXT,
  order_map TEXT,
  hidden_fields TEXT,
  position REAL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
`);
    __publicField(this, "JSONFields", ["properties", "filter", "order_map", "hidden_fields"]);
  }
  async add(data) {
    const position = await this.getLastPosition() + 1;
    await this.dataSpace.exec2(
      `INSERT INTO ${this.name} (id,name,type,table_id,query,position) VALUES (? , ? , ? , ? , ?, ?);`,
      [data.id, data.name, data.type, data.table_id, data.query, position]
    );
    return {
      ...data,
      position
    };
  }
  async del(id) {
    try {
      await this.dataSpace.exec2(`DELETE FROM ${this.name} WHERE id = ?`, [id]);
      return true;
    } catch (error) {
      console.warn(error);
      return false;
    }
  }
  async deleteByTableId(table_id, db2 = this.dataSpace.db) {
    this.dataSpace.syncExec2(
      `DELETE FROM ${this.name} WHERE table_id = ?`,
      [table_id],
      db2
    );
  }
  // methods
  async updateQuery(id, query) {
    await this.dataSpace.exec2(
      `UPDATE ${this.name} SET query = ? WHERE id = ?`,
      [query, id]
    );
  }
  async createDefaultView(table_id) {
    return await this.add({
      id: getUuid(),
      name: "New View",
      type: "grid" /* Grid */,
      table_id,
      query: `SELECT * FROM tb_${table_id}`
    });
  }
  async isRowExistInQuery(table_id, rowId, query) {
    const tmpTableName = `temp_table_${getUuid().slice(0, 8)}`;
    const tableName = `tb_${table_id}`;
    let isExist = false;
    try {
      await this.dataSpace.exec2(
        `CREATE TEMPORARY TABLE ${tmpTableName} AS SELECT * FROM ${tableName} WHERE _id = ?`,
        [rowId]
      );
      const newQuery = replaceQueryTableName(query, {
        [tableName]: tmpTableName
      });
      const result = await this.dataSpace.exec2(newQuery);
      isExist = result.length > 0;
    } catch (error) {
    } finally {
      await this.dataSpace.exec2(`DROP TABLE ${tmpTableName}`);
    }
    return isExist;
  }
  async findRowIndexInQuery(table_id, rowId, query) {
    const tableName = `tb_${table_id}`;
    console.log("findRowIndexInQuery", tableName, rowId, query);
    try {
      const newQuery = replaceWithFindIndexQuery(query, rowId);
      const result = await this.dataSpace.exec2(newQuery);
      console.log("result", query, result);
      return result[0]._index_in_view;
    } catch (error) {
      console.error(error);
    } finally {
    }
    return 1;
  }
  async recompute(table_id, rowIds) {
    const tableName = `tb_${table_id}`;
    const placeholders = rowIds.map(() => "?").join(",");
    const result = await this.dataSpace.exec2(
      `SELECT * FROM ${tableName} where _id in (${placeholders})`,
      rowIds
    );
    return result;
  }
  async getLastPosition() {
    const res = await this.dataSpace.exec2(
      `SELECT COALESCE(MAX(position), 0) as maxPosition from ${this.name};`
    );
    return res[0].maxPosition;
  }
  async getPosition(props) {
    const { tableId, targetId, targetDirection } = props;
    const POSITION_GAP = 1;
    const views = await this.list(
      { table_id: tableId },
      {
        orderBy: "position",
        order: "ASC"
      }
    );
    const targetIndex = views.findIndex((view) => view.id === targetId);
    const prevIndex = targetDirection === "up" ? targetIndex - 1 : targetIndex;
    const nextIndex = targetDirection === "up" ? targetIndex : targetIndex + 1;
    const prevView = views[prevIndex];
    const nextView = views[nextIndex];
    if (prevIndex === -1) {
      return nextView ? nextView.position - POSITION_GAP : 1;
    }
    if (!nextView) {
      return prevView.position + POSITION_GAP;
    }
    if (nextView.position - prevView.position <= 1) {
      const viewsToReorder = [...views];
      let position = 1;
      for (const view of viewsToReorder) {
        await this.updatePosition(view.id, position++);
      }
      return this.getPosition(props);
    }
    return Math.floor((prevView.position + nextView.position) / 2);
  }
  async updatePosition(id, position) {
    await this.dataSpace.exec2(
      `UPDATE ${this.name} SET position = ? WHERE id = ?`,
      [position, id]
    );
  }
  /**
   * Update view position when dragging
   * @param dragId The id of the view being dragged
   * @param targetId The id of the target view
   * @param direction The direction relative to target ("up" | "down")
   * @param tableId The table id that these views belong to
   */
  async movePosition(props) {
    const { dragId, targetId, direction, tableId } = props;
    if (dragId === targetId) {
      return;
    }
    try {
      const newPosition = await this.getPosition({
        tableId,
        targetId,
        targetDirection: direction
      });
      console.log(newPosition, dragId);
      await this.updatePosition(dragId, newPosition);
    } catch (error) {
      console.error("Failed to move view position:", error);
      throw new Error("Failed to update view position");
    }
  }
  /**
   * Batch reorder views
   * @param viewIds Array of view ids in desired order (first = highest position)
   */
  async reorderViews(viewIds) {
    if (viewIds.length === 0) return;
    try {
      await this.dataSpace.db.transaction(async (db2) => {
        let position = viewIds.length * 1e3;
        for (const id of viewIds) {
          this.dataSpace.syncExec2(
            `UPDATE ${this.name} SET position = ? WHERE id = ?`,
            [position, id],
            db2
          );
          position -= 1e3;
        }
      });
    } catch (error) {
      console.error("Failed to reorder views:", error);
      throw new Error("Failed to reorder views");
    }
  }
};
__decorateClass([
  timeit(100)
], ViewTable.prototype, "recompute", 1);

// worker/web-worker/udf/index.ts
var withSqlite3AllUDF = (bc3) => {
  const twice = {
    name: "twice",
    xFunc: function(pCx, arg) {
      return arg + arg;
    },
    deterministic: true
  };
  const twiceNoCtx = {
    name: "twice",
    xFunc: function(arg) {
      return arg + arg;
    },
    deterministic: true
  };
  const props = {
    name: "props",
    xFunc: function(pCx, arg) {
      return arg;
    },
    deterministic: true
  };
  const propsNoCtx = {
    name: "props",
    xFunc: function(arg) {
      return arg;
    },
    deterministic: true
  };
  const today = {
    name: "today",
    xFunc: function(pCx) {
      return (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
    },
    deterministic: true
  };
  const todayNoCtx = {
    name: "today",
    xFunc: function() {
      return (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
    },
    deterministic: true
  };
  const uuidv4 = {
    name: "uuidv4",
    xFunc: function(pCx) {
      return v4_default();
    },
    deterministic: false
  };
  const uuidv4NoCtx = {
    name: "uuidv4",
    xFunc: function() {
      return v4_default();
    },
    deterministic: false
  };
  const uuidv72 = {
    name: "uuidv7",
    xFunc: function(pCx) {
      return uuidv7();
    },
    deterministic: false
  };
  const uuidv7NoCtx = {
    name: "uuidv7",
    xFunc: function() {
      return uuidv7();
    },
    deterministic: false
  };
  const eidos_data_event_update = {
    name: "eidos_data_event_update",
    xFunc: function(pCx, table, _new, _old) {
      bc3.postMessage({
        type: "DataUpdateSignalType" /* DataUpdateSignalType */,
        payload: {
          type: "update" /* Update */,
          table,
          _new: JSON.parse(_new),
          _old: JSON.parse(_old)
        }
      });
    }
  };
  const eidos_data_event_updateNoCtx = {
    name: "eidos_data_event_update",
    xFunc: function(table, _new, _old) {
      bc3.postMessage({
        type: "DataUpdateSignalType" /* DataUpdateSignalType */,
        payload: {
          type: "update" /* Update */,
          table,
          _new: JSON.parse(_new),
          _old: JSON.parse(_old)
        }
      });
    }
  };
  const eidos_data_event_insert = {
    name: "eidos_data_event_insert",
    xFunc: function(pCx, table, _new) {
      bc3.postMessage({
        type: "DataUpdateSignalType" /* DataUpdateSignalType */,
        payload: {
          type: "insert" /* Insert */,
          table,
          _new: JSON.parse(_new)
        }
      });
    }
  };
  const eidos_data_event_insertNoCtx = {
    name: "eidos_data_event_insert",
    xFunc: function(table, _new) {
      bc3.postMessage({
        type: "DataUpdateSignalType" /* DataUpdateSignalType */,
        payload: {
          type: "insert" /* Insert */,
          table,
          _new: JSON.parse(_new)
        }
      });
    }
  };
  const eidos_data_event_delete = {
    name: "eidos_data_event_delete",
    xFunc: function(pCx, table, _old) {
      bc3.postMessage({
        type: "DataUpdateSignalType" /* DataUpdateSignalType */,
        payload: {
          type: "delete" /* Delete */,
          table,
          _old: JSON.parse(_old)
        }
      });
    }
  };
  const eidos_data_event_deleteNoCtx = {
    name: "eidos_data_event_delete",
    xFunc: function(table, _old) {
      bc3.postMessage({
        type: "DataUpdateSignalType" /* DataUpdateSignalType */,
        payload: {
          type: "delete" /* Delete */,
          table,
          _old: JSON.parse(_old)
        }
      });
    }
  };
  const eidos_column_event_insert = {
    name: "eidos_column_event_insert",
    xFunc: function(pCx, table, _new) {
      bc3.postMessage({
        type: "DataUpdateSignalType" /* DataUpdateSignalType */,
        payload: {
          type: "addColumn" /* AddColumn */,
          table,
          _new: JSON.parse(_new)
        }
      });
    }
  };
  const eidos_column_event_insertNoCtx = {
    name: "eidos_column_event_insert",
    xFunc: function(table, _new) {
      bc3.postMessage({
        type: "DataUpdateSignalType" /* DataUpdateSignalType */,
        payload: {
          type: "addColumn" /* AddColumn */,
          table,
          _new: JSON.parse(_new)
        }
      });
    }
  };
  const eidos_column_event_update = {
    name: "eidos_column_event_update",
    xFunc: function(pCx, table, _new, _old) {
      bc3.postMessage({
        type: "DataUpdateSignalType" /* DataUpdateSignalType */,
        payload: {
          type: "updateColumn" /* UpdateColumn */,
          table,
          _new: JSON.parse(_new),
          _old: JSON.parse(_old)
        }
      });
    }
  };
  const eidos_column_event_updateNoCtx = {
    name: "eidos_column_event_update",
    xFunc: function(table, _new, _old) {
      bc3.postMessage({
        type: "DataUpdateSignalType" /* DataUpdateSignalType */,
        payload: {
          type: "updateColumn" /* UpdateColumn */,
          table,
          _new: JSON.parse(_new),
          _old: JSON.parse(_old)
        }
      });
    }
  };
  const eidos_meta_table_event_insert = {
    name: "eidos_meta_table_event_insert",
    xFunc: function(pCx, table, _new) {
      bc3.postMessage({
        type: "MetaTableUpdateSignalType" /* MetaTableUpdateSignalType */,
        payload: {
          type: "insert" /* Insert */,
          table,
          _new: JSON.parse(_new)
        }
      });
    }
  };
  const eidos_meta_table_event_insertNoCtx = {
    name: "eidos_meta_table_event_insert",
    xFunc: function(table, _new) {
      bc3.postMessage({
        type: "MetaTableUpdateSignalType" /* MetaTableUpdateSignalType */,
        payload: {
          type: "insert" /* Insert */,
          table,
          _new: JSON.parse(_new)
        }
      });
    }
  };
  const ALL_UDF = [
    twice,
    props,
    today,
    uuidv4,
    uuidv72,
    eidos_data_event_update,
    eidos_data_event_insert,
    eidos_data_event_delete,
    eidos_column_event_insert,
    eidos_column_event_update,
    eidos_meta_table_event_insert
  ];
  const ALL_UDF_NO_CTX = [
    twiceNoCtx,
    propsNoCtx,
    todayNoCtx,
    uuidv4NoCtx,
    uuidv7NoCtx,
    eidos_data_event_updateNoCtx,
    eidos_data_event_insertNoCtx,
    eidos_data_event_deleteNoCtx,
    eidos_column_event_insertNoCtx,
    eidos_column_event_updateNoCtx,
    eidos_meta_table_event_insertNoCtx
  ];
  return { ALL_UDF, ALL_UDF_NO_CTX };
};

// worker/web-worker/meta-table/chat.ts
var ChatTable = class extends BaseTableImpl {
  constructor() {
    super(...arguments);
    __publicField(this, "name", ChatTableName);
    __publicField(this, "createTableSql", `
  CREATE TABLE IF NOT EXISTS ${ChatTableName} (
    id TEXT PRIMARY KEY,
    title TEXT,
    user_id TEXT,
    project_id TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );

  CREATE TEMP TRIGGER IF NOT EXISTS ${ChatTableName}_insert_trigger
  AFTER INSERT ON ${ChatTableName}
  BEGIN
    SELECT eidos_meta_table_event_insert(
      '${ChatTableName}',
      json_object(
        'id', new.id,
        'title', new.title,
        'user_id', new.user_id,
        'project_id', new.project_id,
        'created_at', new.created_at
      )
    );
  END;
  `);
  }
  async getChatIdsByProjectId(projectId) {
    const sql = `SELECT id FROM ${this.name} WHERE project_id = ?`;
    const result = await this.dataSpace.exec2(sql, [projectId]);
    return result.map((row) => row.id);
  }
  async delete(chatId) {
    await this.dataSpace.db.transaction(async () => {
      await this.dataSpace.message.deleteMessagesByChatId(chatId);
      const sql = `DELETE FROM ${this.name} WHERE id = ?`;
      await this.dataSpace.exec2(sql, [chatId]);
    });
  }
};

// worker/web-worker/meta-table/message.ts
var MessageTable = class extends BaseTableImpl {
  constructor() {
    super(...arguments);
    __publicField(this, "name", MessageTableName);
    __publicField(this, "createTableSql", `
  CREATE TABLE IF NOT EXISTS ${MessageTableName} (
    id TEXT PRIMARY KEY,
    chat_id TEXT,
    role TEXT,
    content TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(chat_id) REFERENCES ${ChatTableName}(id)
  );

  CREATE TEMP TRIGGER IF NOT EXISTS ${MessageTableName}_insert_trigger
  AFTER INSERT ON ${MessageTableName}
  BEGIN
    SELECT eidos_meta_table_event_insert(
      '${MessageTableName}',
      json_object(
        'id', new.id,
        'chat_id', new.chat_id,
        'role', new.role,
        'content', new.content,
        'created_at', new.created_at
      )
    );
  END;
  `);
  }
  async deleteMessagesByChatId(chatId) {
    const sql = `DELETE FROM ${this.name} WHERE chat_id = ?`;
    await this.dataSpace.exec2(sql, [chatId]);
  }
  async clearMessages(chatId) {
    const sql = `DELETE FROM ${this.name} WHERE chat_id = ?`;
    await this.dataSpace.exec2(sql, [chatId]);
  }
};

// lib/sqlite/sql-view-query.ts
var import_pgsql_ast_parser7 = __toESM(require_pgsql_ast_parser(), 1);

// lib/sqlite/sql-filter-parser.ts
var import_pgsql_ast_parser5 = __toESM(require_pgsql_ast_parser(), 1);
var opMap = {
  AND: "AND" /* And */,
  OR: "OR" /* Or */,
  "=": "=" /* Equal */,
  "!=": "!=" /* NotEqual */,
  ">": ">" /* GreaterThan */,
  ">=": ">=" /* GreaterThanOrEqual */,
  "<": "<" /* LessThan */,
  "<=": "<=" /* LessThanOrEqual */,
  // LIKE: CompareOperator.Contains,
  "NOT LIKE": "NotContains" /* NotContains */,
  "IS NULL": "IsEmpty" /* IsEmpty */,
  "IS NOT NULL": "IsNotEmpty" /* IsNotEmpty */
};
var reverseOpMap = {
  ["AND" /* And */]: "AND",
  ["OR" /* Or */]: "OR",
  ["=" /* Equal */]: "=",
  ["!=" /* NotEqual */]: "!=",
  [">" /* GreaterThan */]: ">",
  [">=" /* GreaterThanOrEqual */]: ">=",
  ["<" /* LessThan */]: "<",
  ["<=" /* LessThanOrEqual */]: "<=",
  ["Contains" /* Contains */]: "LIKE",
  ["StartsWith" /* StartsWith */]: "LIKE",
  ["EndsWith" /* EndsWith */]: "LIKE",
  ["NotContains" /* NotContains */]: "NOT LIKE",
  ["IsEmpty" /* IsEmpty */]: "IS NULL",
  ["IsNotEmpty" /* IsNotEmpty */]: "IS NOT NULL"
};

// lib/sqlite/sql-sort-parser.ts
var import_pgsql_ast_parser6 = __toESM(require_pgsql_ast_parser(), 1);

// lib/sqlite/sql-view-query.ts
var rewriteQueryWithRowId = (query) => {
  const ast = (0, import_pgsql_ast_parser7.parseFirst)(query);
  const mapper = (0, import_pgsql_ast_parser7.astMapper)((map) => ({
    ref: (t) => {
      if (t.name === "*") {
        return {
          ...t,
          name: "rowid"
        };
      }
      return map.super().ref(t);
    }
  }));
  const modified = mapper.statement(ast);
  return import_pgsql_ast_parser7.toSql.statement(modified);
};

// worker/web-worker/data-pipeline/TableFullTextSearch.ts
var TableFullTextSearch = class {
  constructor(dataspace) {
    this.dataspace = dataspace;
  }
  async createDynamicFTS(tableName, temporary = false, inTransaction = false) {
    const tableInfo = await this.dataspace.db.selectObjects(`PRAGMA table_info(${tableName})`);
    if (!isDesktopMode) {
      throw new Error("Full text search is not supported in web mode");
    }
    const columns = tableInfo.map((col) => col.name).filter((name2) => name2.toLowerCase() !== "rowid").join(", ");
    const ftsTableName = `fts_${tableName}`;
    const createFtsSql = `
        CREATE VIRTUAL TABLE IF NOT EXISTS ${ftsTableName}
        USING fts5(${columns}, content='${tableName}', content_rowid='rowid', tokenize = 'simple');
        `;
    try {
      if (!inTransaction) {
        await this.dataspace.db.exec("BEGIN IMMEDIATE TRANSACTION");
      }
      await this.dataspace.db.exec(createFtsSql);
      await this.dataspace.db.exec(`INSERT INTO ${ftsTableName}(${ftsTableName}) VALUES('rebuild');`);
      if (!temporary) {
        await this.createTriggers(tableName, columns);
      }
      if (!inTransaction) {
        await this.dataspace.db.exec("COMMIT");
      }
    } catch (error) {
      if (!inTransaction) {
        await this.dataspace.db.exec("ROLLBACK");
      }
      throw error;
    }
  }
  async createTriggers(tableName, columns) {
    const ftsTableName = `fts_${tableName}`;
    const triggerSqls = [
      `CREATE TRIGGER IF NOT EXISTS fts_${tableName}_ai AFTER INSERT ON ${tableName} BEGIN
                INSERT INTO ${ftsTableName}(rowid, ${columns}) 
                VALUES (new.rowid, ${columns.split(",").map((c) => `new.${c.trim()}`).join(",")});
            END;`,
      `CREATE TRIGGER IF NOT EXISTS fts_${tableName}_ad AFTER DELETE ON ${tableName} BEGIN
                INSERT INTO ${ftsTableName}(${ftsTableName}, rowid) VALUES('delete', old.rowid);
            END;`,
      `CREATE TRIGGER IF NOT EXISTS fts_${tableName}_au AFTER UPDATE ON ${tableName} BEGIN
                INSERT INTO ${ftsTableName}(${ftsTableName}, rowid) VALUES('delete', old.rowid);
                INSERT INTO ${ftsTableName}(rowid, ${columns})
                VALUES (new.rowid, ${columns.split(",").map((c) => `new.${c.trim()}`).join(",")});
            END;`
    ];
    for (const sql of triggerSqls) {
      await this.dataspace.db.exec(sql);
    }
  }
  async search(tableName, query, viewId, page = 1, pageSize = 20) {
    if (!isDesktopMode) {
      throw new Error("Full text search is not supported in web mode");
    }
    const startTime = performance.now();
    const ftsTableName = `fts_${tableName}`;
    const offset = (page - 1) * pageSize;
    try {
      const hasFTS = await this.hasFTS(tableName);
      if (!hasFTS) {
        throw new Error(`FTS table ${ftsTableName} does not exist.`);
      }
      const view = await this.dataspace.view.get(viewId);
      if (!view?.query) {
        throw new Error(`View ${viewId} not found or has no query`);
      }
      const viewQuery = rewriteQueryWithRowId(view.query);
      const countSql = `
                SELECT COUNT(*) AS total
                FROM (${viewQuery}) ov
                JOIN ${ftsTableName} fts ON ov.rowid = fts.rowid
                WHERE ${ftsTableName} MATCH ?
            `;
      const [{ total }] = await this.dataspace.db.selectObjects(countSql, [query]);
      if (total === 0) {
        return {
          results: [],
          searchTime: -1,
          totalMatches: 0,
          currentPage: page,
          totalPages: 0
        };
      }
      const tableInfo = await this.dataspace.db.selectObjects(`PRAGMA table_info(${tableName})`);
      const columns = tableInfo.map((col) => col.name).filter((name2) => name2.toLowerCase() !== "rowid");
      const highlightSelects = columns.map((col) => `highlight(${ftsTableName}, ${columns.indexOf(col)}, '<mark>', '</mark>') as highlight_${col}`).join(", ");
      const matchSql = `
                WITH original_view AS (
                    SELECT 
                        ${tableName}.rowid,
                        v.*,
                        ROW_NUMBER() OVER () as original_order,
                        ROW_NUMBER() OVER () - 1 as row_index
                    FROM (${view.query}) v
                    JOIN ${tableName} ON ${tableName}._id = v._id
                ),
                matched_rows AS (
                    SELECT 
                        fts.rowid,
                        ${highlightSelects}
                    FROM ${ftsTableName} fts
                    WHERE ${ftsTableName} MATCH ?
                )
                SELECT v.*, m.*
                FROM original_view v
                JOIN matched_rows m ON m.rowid = v.rowid
                ORDER BY v.original_order
                LIMIT ? OFFSET ?
            `;
      const results = await this.dataspace.db.selectObjects(
        matchSql,
        [query, pageSize, offset]
      );
      const processedResults = results.map((row) => {
        const matches = [];
        for (const col of columns) {
          const highlightKey = `highlight_${col}`;
          const highlight = row[highlightKey];
          if (highlight && highlight.includes("<mark>")) {
            matches.push({
              column: col,
              snippet: highlight
            });
          }
          delete row[highlightKey];
        }
        const rowIndex = row.row_index;
        delete row.row_index;
        delete row.original_order;
        return {
          row,
          matches,
          rowIndex
        };
      });
      const endTime = performance.now();
      const searchTime = Math.round(endTime - startTime);
      return {
        results: processedResults,
        searchTime,
        totalMatches: total,
        currentPage: page,
        totalPages: Math.ceil(total / pageSize)
      };
    } catch (error) {
      throw error;
    }
  }
  async updateTrigger(tableName, toDeleteColumns) {
    const triggerNames = [
      `fts_${tableName}_ai`,
      `fts_${tableName}_ad`,
      `fts_${tableName}_au`
    ];
    for (const triggerName of triggerNames) {
      await this.dataspace.db.exec(`DROP TRIGGER IF EXISTS ${triggerName}`);
    }
    const tableInfo = await this.dataspace.db.selectObjects(`PRAGMA table_info(${tableName})`);
    const columns = tableInfo.map((col) => col.name).filter((name2) => name2.toLowerCase() !== "rowid" && !toDeleteColumns.includes(name2)).join(", ");
    await this.createTriggers(tableName, columns);
  }
  async clearFTS(tableName) {
    if (!isDesktopMode) {
      throw new Error("Full text search is not supported in web mode");
    }
    const ftsTableName = `fts_${tableName}`;
    const tableExists = await this.dataspace.db.selectObjects(
      `SELECT name FROM sqlite_master WHERE type='table' AND name=?`,
      [ftsTableName]
    );
    if (tableExists.length === 0) {
      console.warn(`FTS table ${ftsTableName} does not exist. no need to clear`);
      return;
    }
    await this.dataspace.db.exec(`INSERT INTO ${ftsTableName}(${ftsTableName}) VALUES('delete-all')`);
    console.log(`FTS table ${ftsTableName} has been cleared`);
  }
  async dropFTS(tableName) {
    if (!isDesktopMode) {
      throw new Error("Full text search is not supported in web mode");
    }
    const ftsTableName = `fts_${tableName}`;
    const tableExists = await this.dataspace.db.selectObjects(
      `SELECT name FROM sqlite_master WHERE type='table' AND name=?`,
      [ftsTableName]
    );
    if (tableExists.length === 0) {
      console.warn(`FTS table ${ftsTableName} does not exist. no need to drop`);
      return;
    }
    const triggerNames = [
      `fts_${tableName}_ai`,
      `fts_${tableName}_ad`,
      `fts_${tableName}_au`
    ];
    for (const triggerName of triggerNames) {
      await this.dataspace.db.exec(`DROP TRIGGER IF EXISTS ${triggerName}`);
    }
    await this.dataspace.db.exec(`DROP TABLE IF EXISTS ${ftsTableName}`);
    console.log(`FTS table ${ftsTableName} and related triggers have been dropped`);
  }
  async hasFTS(tableName) {
    if (!isDesktopMode) {
      throw new Error("Full text search is not supported in web mode");
    }
    const ftsTableName = `fts_${tableName}`;
    try {
      const tableExists = await this.dataspace.db.selectObjects(
        `SELECT name FROM sqlite_master WHERE type='table' AND name=?`,
        [ftsTableName]
      );
      return tableExists.length > 0;
    } catch (error) {
      console.error(`Error checking FTS table ${ftsTableName}:`, error);
      throw error;
    }
  }
  async rebuildFTS(tableName) {
    if (!isDesktopMode) {
      throw new Error("Full text search is not supported in web mode");
    }
    try {
      await this.dataspace.db.exec("BEGIN IMMEDIATE TRANSACTION");
      const ftsTableName = `fts_${tableName}`;
      const tableExists = await this.dataspace.db.selectObjects(
        `SELECT name FROM sqlite_master WHERE type='table' AND name=?`,
        [ftsTableName]
      );
      if (tableExists.length > 0) {
        await this.dataspace.db.exec(`INSERT INTO ${ftsTableName}(${ftsTableName}) VALUES('delete-all')`);
        const triggerNames = [
          `fts_${tableName}_ai`,
          `fts_${tableName}_ad`,
          `fts_${tableName}_au`
        ];
        for (const triggerName of triggerNames) {
          await this.dataspace.db.exec(`DROP TRIGGER IF EXISTS ${triggerName}`);
        }
        await this.dataspace.db.exec(`DROP TABLE IF EXISTS ${ftsTableName}`);
      }
      await this.createDynamicFTS(tableName, false, true);
      await this.dataspace.db.exec("COMMIT");
    } catch (error) {
      await this.dataspace.db.exec("ROLLBACK");
      this.dataspace.notify({
        title: "Error",
        description: "Failed to rebuild FTS table"
      });
      throw error;
    }
  }
};

// worker/web-worker/DataSpace.ts
var DataSpace = class {
  constructor(config) {
    __publicField(this, "db");
    __publicField(this, "draftDb");
    __publicField(this, "sqlite3");
    __publicField(this, "undoRedoManager");
    __publicField(this, "activeUndoManager");
    __publicField(this, "dbName");
    //  meta table
    __publicField(this, "doc");
    __publicField(this, "action");
    __publicField(this, "script");
    __publicField(this, "tree");
    __publicField(this, "view");
    __publicField(this, "column");
    __publicField(this, "reference");
    __publicField(this, "embedding");
    // queue: QueueTable
    __publicField(this, "chat");
    __publicField(this, "message");
    __publicField(this, "file");
    __publicField(this, "dataChangeTrigger");
    __publicField(this, "linkRelationUpdater");
    __publicField(this, "allTables", []);
    __publicField(this, "hasLoadExtension", false);
    // worker to main thread
    __publicField(this, "postMessage");
    __publicField(this, "callRenderer");
    // channel broadcast
    __publicField(this, "dataEventChannel");
    // for trigger
    __publicField(this, "eventHandler");
    __publicField(this, "efsManager");
    // for auto migration
    __publicField(this, "hasMigrated", false);
    __publicField(this, "tableFullTextSearch");
    __publicField(this, "isServer", false);
    __publicField(this, "deleteSelectOption", async (field, option) => {
      const tableId = getTableIdByRawTableName(field.table_name);
      const tableManager = this.table(tableId);
      if (field.type === "select" /* Select */) {
        return await tableManager.fields.select.deleteSelectOption(field, option);
      } else if (field.type === "multi-select" /* MultiSelect */) {
        return await tableManager.fields.multiSelect.deleteSelectOption(
          field,
          option
        );
      }
    });
    __publicField(this, "updateSelectOptionName", async (field, update) => {
      if (update.from == update.to) {
        return;
      }
      const tableId = getTableIdByRawTableName(field.table_name);
      const tableManager = this.table(tableId);
      if (field.type === "select" /* Select */) {
        return await tableManager.fields.select.updateSelectOptionName(
          field,
          update
        );
      } else if (field.type === "multi-select" /* MultiSelect */) {
        return await tableManager.fields.multiSelect.updateSelectOptionName(
          field,
          update
        );
      }
    });
    // just for type check
    __publicField(this, "sql2", this.sql);
    // rename for public rpc
    __publicField(this, "sqlQuery", this.sql4mainThread);
    const { db: db2, activeUndoManager, dbName, sqlite3, draftDb, context, createUDF, postMessage: postMessage2, efsManager: efsManager2, dataEventChannel, hasLoadExtension, callRenderer, cacheSize, isServer } = config;
    this.db = db2;
    this.isServer = isServer || db2 instanceof BaseServerDatabase;
    this.hasLoadExtension = Boolean(hasLoadExtension);
    if (cacheSize) {
      this.setCacheSize(cacheSize);
    }
    if (dataEventChannel) {
      this.dataEventChannel = dataEventChannel;
    } else {
      this.dataEventChannel = new EventEmitter(EidosDataEventChannelName);
    }
    if (callRenderer) {
      this.callRenderer = callRenderer;
    } else {
      this.callRenderer = (type, data) => {
        const channel = new MessageChannel();
        self.postMessage({ type, data }, [channel.port2]);
        return new Promise((resolve) => {
          channel.port1.onmessage = (event) => {
            resolve(event.data);
          };
        });
      };
    }
    this.sqlite3 = sqlite3;
    this.draftDb = draftDb;
    this.dbName = dbName;
    this.postMessage = postMessage2;
    this.efsManager = efsManager2;
    this.initUDF();
    this.eventHandler = new DataChangeEventHandler(this);
    this.dataChangeTrigger = new DataChangeTrigger();
    this.linkRelationUpdater = new LinkRelationUpdater(
      this,
      context.setInterval
    );
    this.doc = new DocTable(this);
    this.action = new ActionTable(this);
    this.script = new ScriptTable(this);
    this.tree = new TreeTable(this);
    this.view = new ViewTable(this);
    this.file = new FileTable(this);
    this.column = new ColumnTable(this);
    this.embedding = new EmbeddingTable(this);
    this.reference = new ReferenceTable(this);
    this.chat = new ChatTable(this);
    this.message = new MessageTable(this);
    this.allTables = [
      this.doc,
      this.action,
      this.script,
      this.tree,
      this.view,
      this.column,
      this.embedding,
      this.file,
      this.reference,
      this.chat,
      this.message
      // this.queue
    ];
    this.initMetaTable();
    if (this.draftDb) {
      const dbMigrator = new DbMigrator(this, this.draftDb);
      dbMigrator.migrate().then(() => {
        this.hasMigrated = true;
      });
    }
    if (createUDF) {
      createUDF(this.db);
    }
    this.undoRedoManager = new SQLiteUndoRedo(this);
    this.activeUndoManager = activeUndoManager;
    this.tableFullTextSearch = new TableFullTextSearch(this);
  }
  // close db
  closeDb() {
    this.db.close();
  }
  setCacheSize(size) {
    this.exec(`PRAGMA cache_size = ${size}`);
  }
  initUDF() {
    const allUfs = withSqlite3AllUDF(this.dataEventChannel);
    if (this.isServer) {
      allUfs.ALL_UDF_NO_CTX.forEach((udf) => {
        this.db.createFunction(udf);
      });
    } else {
      allUfs.ALL_UDF.forEach((udf) => {
        this.db.createFunction(udf);
      });
    }
  }
  initMetaTable() {
    this.allTables.forEach((table) => {
      this.db.exec(table.createTableSql);
    });
  }
  // table change callback
  async onTableChange(space2, tableName, toDeleteColumns) {
    if (space2 === this.dbName) {
      const collist = await this.listRawColumns(tableName);
      await this.dataChangeTrigger.setTrigger(
        this,
        tableName,
        collist,
        toDeleteColumns
      );
      if (this.activeUndoManager) {
        this.activeTablesUndoRedo([tableName]);
      }
    }
  }
  // embedding
  async addEmbedding(embedding) {
    return await this.embedding.add(embedding);
  }
  // table
  table(id) {
    return new TableManager(id, this);
  }
  // index
  createTableIndex(tableId, column) {
    this.table(tableId).index.createIndex(
      column,
      () => {
        this.blockUIMsg(
          "You are operating on a large table; auto indexing, please wait."
        );
      },
      () => {
        this.blockUIMsg(null);
      }
    );
    return;
  }
  async getLookupContext(tableName, columnName) {
    const tableId = getTableIdByRawTableName(tableName);
    const tableManager = this.table(tableId);
    return tableManager.fields.lookup.getLookupContext(tableName, columnName);
  }
  updateLookupColumn(tableName, columnName) {
    const tableId = getTableIdByRawTableName(tableName);
    const tableManager = this.table(tableId);
    return tableManager.fields.lookup.updateColumn({
      tableName,
      tableColumnName: columnName
    });
  }
  async setRow(tableId, rowId, data) {
    return await this.table(tableId).rows.update(rowId, data, {
      useFieldId: true
    });
  }
  async setCell(data) {
    const tableManager = this.table(data.tableId);
    const row = await tableManager.rows.get(data.rowId, { raw: true });
    const oldValue = row?.[data.fieldId];
    if (oldValue !== data.value) {
      await this.table(data.tableId).rows.update(
        data.rowId,
        {
          [data.fieldId]: data.value
        },
        { useFieldId: true }
      );
      return;
    }
  }
  async getRow(tableId, rowId) {
    const tableManager = this.table(tableId);
    const row = await tableManager.rows.query(
      {
        _id: rowId
      },
      {
        limit: 1,
        raw: true
      }
    );
    if (row.length === 0) {
      return null;
    }
    return row[0];
  }
  /**
   * Starting from v0.5.0, we switched to using uuidv7 as the _id, and the logic of deleteRowsByRange changed from sorting by rowid to sorting by _id.
   * This function is suitable for old versions of tables where _id of row is uuidv4, and data cannot be deleted by selection, but by a list of _id values.
   * There are some limitations, such as the maximum number of records that can be deleted at once is limited by the sqlite bind parameter.
   * @param rowIds
   * @param tableId
   */
  async deleteRowsByIds(ids, tableName) {
    const tableId = getTableIdByRawTableName(tableName);
    const tableManager = this.table(tableId);
    await tableManager.rows.batchDelete(ids);
    this.undoRedoManager.event();
  }
  async deleteRowsByRange(range, tableName, query) {
    if ("order by" !== query.toLowerCase().match(/order by/g)?.[0]) {
      query += " ORDER BY _id";
    }
    const sql = `DELETE FROM ${tableName} WHERE _id in (SELECT _id FROM (${query}) LIMIT ? OFFSET ?)`;
    await this.db.transaction(async (db2) => {
      for (const item of range.reverse()) {
        const bind = [item.endIndex - item.startIndex, item.startIndex];
        this.syncExec2(sql, bind, db2);
      }
    });
    this.undoRedoManager.event();
  }
  // files
  async addFile(file) {
    return await this.file.add(file);
  }
  async uploadDir(dirHandle, _parentPath) {
    const fs = new EidosFileSystemManager(dirHandle);
    console.log(fs);
    const files = await fs.walk([]);
    console.log(files);
    const count = files.length;
    console.log(count);
    await this.file.uploadDir(dirHandle, count, 0, _parentPath);
    this.blockUIMsg(null);
    return;
  }
  async getFileById(id) {
    return await this.file.get(id);
  }
  async getFileByPath(path) {
    return await this.file.getFileByPath(path);
  }
  async delFile(id) {
    return await this.file.del(id);
  }
  async delFileByPath(path) {
    const file = await this.file.getFileByPath(path);
    if (!file) {
      return;
    }
    return await this.file.del(file.id);
  }
  async deleteFileByPathPrefix(prefix) {
    return await this.file.deleteFileByPathPrefix(prefix);
  }
  async updateFileVectorized(id, isVectorized) {
    return await this.file.updateVectorized(id, isVectorized);
  }
  async saveFile2EFS(url, subDir = [], name2) {
    return await this.file.saveFile2EFS(url, subDir, name2);
  }
  async listFiles() {
    return await this.file.list();
  }
  async walkFiles() {
    return await this.file.walk();
  }
  async transformFileSystem(sourceFs, targetFs) {
    return await this.file.transformFileSystem(sourceFs, targetFs);
  }
  // views
  async listViews(tableId) {
    return await this.view.list({ table_id: tableId }, {
      order: "ASC",
      orderBy: "position"
    });
  }
  async addView(view) {
    return await this.view.add(view);
  }
  async delView(viewId) {
    return await this.view.del(viewId);
  }
  async updateView(viewId, view) {
    return await this.view.set(viewId, view);
  }
  async createDefaultView(tableId) {
    return await this.view.createDefaultView(tableId);
  }
  async isRowExistInQuery(tableId, rowId, query) {
    return await this.view.isRowExistInQuery(tableId, rowId, query);
  }
  async getRecomputeRows(tableId, rowIds) {
    return await this.view.recompute(tableId, rowIds);
  }
  async addField(data) {
    return await this.column.addField(data);
  }
  async deleteField(tableName, tableColumnName) {
    this.blockUIMsg("Deleting column, please wait.");
    const res = await this.column.deleteField(tableName, tableColumnName);
    this.blockUIMsg(null);
    return res;
  }
  async changeColumnType(tableName, columnName, type) {
    return await this.column.changeType(tableName, columnName, type);
  }
  async listRawColumns(tableName) {
    return await this.db.selectObjects(`PRAGMA table_info(${tableName})`);
  }
  async updateColumnProperty(data) {
    return await this.column.updateProperty(data);
  }
  async addRow(tableName, data) {
    const tableId = getTableIdByRawTableName(tableName);
    const tm = new TableManager(tableId, this);
    const res = await tm.rows.create(data);
    const row = await tm.rows.get(res._id, { raw: true, withRowId: true });
    return row;
  }
  // actions
  async addAction(data) {
    await this.action.add(data);
  }
  async listActions() {
    return this.action.list();
  }
  // scripts
  async addScript(data) {
    await this.script.add(data);
  }
  async listScripts(status = "all") {
    const query = status === "all" ? void 0 : { enabled: status === "enabled" };
    return this.script.list(query, {
      orderBy: "created_at",
      order: "DESC"
    });
  }
  async callScript(id, input) {
    return await this.script.call(id, input);
  }
  async getScript(id) {
    return this.script.get(id);
  }
  async deleteScript(id) {
    await this.script.del(id);
  }
  async updateScript(data) {
    await this.script.set(data.id, data);
  }
  async enableScript(id) {
    await this.script.enable(id);
  }
  async disableScript(id) {
    await this.script.disable(id);
  }
  // docs
  async rebuildIndex(refillNullMarkdown = false) {
    await this.doc.rebuildIndex({ refillNullMarkdown });
  }
  // table full text search
  async rebuildFTS(tableId) {
    this.blockUIMsg("Rebuilding FTS table, please wait.");
    const tableName = getRawTableNameById(tableId);
    await this.tableFullTextSearch.rebuildFTS(tableName);
    this.blockUIMsg(null);
  }
  async addDoc(docId, content, markdown, isDayPage = false) {
    await this.doc.add({ id: docId, content, markdown, is_day_page: isDayPage });
  }
  async getDocBaseInfo(id) {
    return this.doc.getBaseInfo(id);
  }
  // update doc mount on sqlite for now,maybe change to fs later
  async updateDoc(docId, content, markdown, _isDayPage = false) {
    const res = await this.doc.get(docId);
    const isDayPage = _isDayPage || /^\d{4}-\d{2}-\d{2}$/g.test(docId);
    if (!res) {
      await this.doc.add({
        id: docId,
        content,
        markdown,
        is_day_page: isDayPage
      });
    } else {
      if (res.content !== content || res.markdown !== markdown) {
        console.log("doc really changed", docId);
        await this.doc.set(docId, {
          id: docId,
          content,
          markdown,
          is_day_page: isDayPage
        });
      }
    }
  }
  async getDoc(docId) {
    const doc = await this.doc.get(docId);
    return doc?.content;
  }
  async getDocMarkdown(docId) {
    return this.doc.getMarkdown(docId);
  }
  /**
   * if you want to create or update a day page, you should pass a day page id. page id is like 2021-01-01
   * @param docId
   * @param mdStr
   * @param parent_id
   * @returns
   */
  async createOrUpdateDocWithMarkdown(docId, mdStr, parent_id, title, mode) {
    return this.createOrUpdateDoc({
      docId,
      content: mdStr,
      type: "markdown",
      parent_id,
      title,
      mode
    });
  }
  async createOrUpdateDoc(data) {
    if (isDayPageId(data.docId)) {
      return this.doc.createOrUpdate({
        id: data.docId,
        text: data.content,
        type: data.type,
        mode: data.mode
      });
    } else {
      return this.db.transaction(async () => {
        await this.getOrCreateTreeNode({
          id: data.docId,
          name: data.title || data.docId,
          parent_id: data.parent_id,
          type: "doc"
        });
        return await this.doc.createOrUpdate({
          id: data.docId,
          text: data.content,
          type: data.type,
          mode: data.mode
        });
      });
    }
  }
  async deleteDoc(docId) {
    await this.doc.del(docId);
  }
  async listAllDocIds() {
    const res = await this.doc.list({}, {
      fields: ["id"]
    });
    return res.map((doc) => doc.id);
  }
  async fullTextSearch(query) {
    return this.doc.search(query);
  }
  async createTable(fields, name2) {
    const { createTableSql, tableId } = TableManager.generateCreateTableSql(fields);
    console.log("create table sql: ", createTableSql);
    await this.createTableViaSchema(tableId, name2, createTableSql);
    return tableId;
  }
  async createTableViaSchema(id, name2, tableSchema, parent_id) {
    this.db.transaction(async (db2) => {
      await this.addTreeNode({ id, name: name2, type: "table", parent_id });
      db2.exec(tableSchema);
      await this.createDefaultView(id);
    });
  }
  async importCsv(file) {
    const csvImport = new CsvImportAndExport();
    console.log("importing csv file", file);
    const tableId = await csvImport.import(file, this);
    return tableId;
  }
  async exportCsv(tableId) {
    const csvImport = new CsvImportAndExport();
    return await csvImport.export(tableId, this);
  }
  async importMarkdown(file) {
    const markdownImport = new MarkdownImportAndExport();
    const nodeId = await markdownImport.import(file, this);
    return nodeId;
  }
  async exportMarkdown(nodeId) {
    const markdownImport = new MarkdownImportAndExport();
    return await markdownImport.export(nodeId, this);
  }
  // table
  async fixTable(tableId) {
    const tableManager = this.table(tableId);
    return await tableManager.fixTable(tableId);
  }
  async hasSystemColumn(tableId, column) {
    const tableManager = this.table(tableId);
    return await tableManager.hasSystemColumn(tableId, column);
  }
  async restoreNode(id) {
    await this.tree.set(id, {
      is_deleted: false
    });
  }
  async deleteNode(id) {
    await this.tree.set(id, {
      is_deleted: true
    });
  }
  // table
  async isTableExist(id) {
    const tableManager = this.table(id);
    return await tableManager.isExist(id);
  }
  async deleteTable(id) {
    await this.table(id).del(id);
  }
  async listDays(page) {
    return await this.doc.listDayPage(page);
  }
  async listAllDays() {
    return await this.doc.listAllDayPages();
  }
  syncExec2(sql, bind = [], db2 = this.db) {
    const res = [];
    if (this.isServer) {
      try {
        return db2.exec({
          sql,
          bind,
          returnValue: "resultRows",
          rowMode: "object"
        });
      } catch (error) {
        if (error.toString().includes("SqliteError")) {
          this.notify({
            title: "SqliteError",
            description: error.toString()
          });
        }
        console.log(error);
      }
    }
    db2.exec({
      sql,
      bind,
      returnValue: "resultRows",
      rowMode: "object",
      callback: (row) => {
        res.push(row);
      }
    });
    return res;
  }
  // FIXME: there are some problem with headless lexical run in worker
  // return markdown string, compute in worker
  // public async asyncGetDocMarkdown(docId: string) {
  //   const doc = await this.doc.get(docId)
  //   if (!doc) {
  //     throw new Error(`doc ${docId} not found`)
  //   }
  //   return await _getDocMarkdown(doc.markdown)
  // }
  // return object array
  async exec2(sql, bind = []) {
    return this.syncExec2(sql, bind);
  }
  async runAIgeneratedSQL(sql, tableName) {
    const _tableName = getTableNameFromSql(sql) || tableName;
    const fields = await this.column.list({ table_name: _tableName });
    const _sql = transformQuery(sql, fields);
    const res = await this.exec2(_sql);
    return RowsManager.getReadableRows(res, fields);
  }
  // tree
  async listTreeNodes(query, withSubNode) {
    return this.tree.query({ query, withSubNode });
  }
  async updateTreeNodePosition(id, position) {
    return this.tree.set(id, {
      position
    });
  }
  async pinNode(id, isPinned) {
    return this.tree.pin(id, isPinned);
  }
  async toggleNodeFullWidth(id, isFullWidth) {
    return this.tree.set(id, {
      is_full_width: isFullWidth
    });
  }
  async toggleNodeLock(id, isLocked) {
    return this.tree.set(id, {
      is_locked: isLocked
    });
  }
  async updateTreeNodeName(id, name2) {
    const node = await this.tree.get(id);
    if (node?.name === name2) {
      return;
    }
    return this.db.transaction(async () => {
      await this.tree.updateName(id, name2);
      if (node?.parent_id) {
        const parent = await this.tree.get(node.parent_id);
        if (parent && parent.type === "table") {
          const tableRawName = getRawTableNameById(parent.id);
          await this.exec2(
            `UPDATE ${tableRawName} SET title = ? WHERE _id = ?`,
            [name2, extractIdFromShortId(id)]
          );
        }
      }
    });
  }
  async addTreeNode(data) {
    return this.tree.add(data);
  }
  async getOrCreateTreeNode(data) {
    const node = await this.tree.get(data.id);
    const _data = { ...data };
    const parent = data.parent_id && await this.tree.getNode(data.parent_id);
    if (parent && parent.type === "table") {
      const tableRawName = getRawTableNameById(parent.id);
      _data.parent_id = parent.id;
      await this.exec2(
        `INSERT OR IGNORE INTO ${tableRawName} (_id,title) VALUES (?,?);`,
        [extractIdFromShortId(data.id), data.name]
      );
    }
    if (node) {
      return node;
    }
    return this.tree.add(_data);
  }
  async getTreeNode(id) {
    return this.tree.get(id);
  }
  async moveDraftIntoTable(id, tableId, parentId) {
    return this.tree.moveIntoTable(id, tableId, parentId);
  }
  async nodeChangeParent(id, parentId, opts) {
    if (parentId) {
      await this.tree.checkLoop(id, parentId);
    }
    let data = {
      parent_id: parentId
    };
    if (opts) {
      const newPosition = await this.tree.getPosition({
        parentId,
        targetId: opts.targetId,
        targetDirection: opts.targetDirection
      });
      data = {
        ...data,
        position: newPosition
      };
    }
    await this.tree.set(id, data);
    return data;
  }
  async listUiColumns(tableName) {
    return this.column.list({ table_name: tableName });
  }
  /**
   * this will return all ui columns in this space
   * @param tableName
   * @returns
   */
  async listAllUiColumns() {
    return this.exec2(`SELECT * FROM ${ColumnTableName} ;`);
  }
  undo() {
    if (!this.activeUndoManager) {
      throw new Error("undoRedo not active");
    }
    this.undoRedoManager.callUndo();
  }
  redo() {
    if (!this.activeUndoManager) {
      throw new Error("undoRedo not active");
    }
    this.undoRedoManager.callRedo();
  }
  async activeTablesUndoRedo(tables) {
    if (!tables) {
      return;
    }
    this.undoRedoManager.deactivate();
    this.undoRedoManager.activate(tables);
  }
  execute(sql, bind = []) {
    const res = [];
    this.db.exec({
      sql,
      bind,
      callback: (row) => {
        res.push(row);
      }
    });
    return {
      fetchone: () => res[0],
      fetchall: () => res
    };
  }
  exec(sql, bind = []) {
    console.debug(sql, bind);
    this.db.exec({
      sql,
      bind,
      callback: (row) => {
      }
    });
  }
  execSqlWithBind(sql, bind = [], rowMode = "array") {
    const res = [];
    if (this.isServer) {
      return this.db.exec({
        sql,
        bind,
        returnValue: "resultRows",
        rowMode
      });
    }
    try {
      this.db.exec({
        sql,
        bind,
        returnValue: "resultRows",
        rowMode,
        callback: (row) => {
          res.push(row);
        }
      });
    } catch (error) {
      logger.error(error);
      logger.error({ sql, bind });
      this.postMessage?.({
        type: "Error" /* Error */,
        data: {
          message: error.message,
          context: {
            sql,
            bind
          }
        }
      });
      throw error;
    }
    return res;
  }
  /**
   * it's a template string function, to execute sql. safe from sql injection
   * table name and column name need to be Symbol, like Symbol('table_name') or Symbol('column_name')
   *
   * example:
   * const tableName = "books"
   * const id = 42
   * sql`select ${Symbol("title")} from ${Symbol('table_name')} where id = ${id}`.then(logger.info)
   * @param strings
   * @param values
   * @returns
   */
  async sql(strings, ...values) {
    const { sql, bind } = buildSql(strings, ...values);
    const res = this.execSqlWithBind(sql, bind);
    if (!isReadOnlySql(sql)) {
      setTimeout(() => this.undoRedoManager.event(), 0);
    }
    return res;
  }
  async sql4mainThread(sql, bind = [], rowMode = "array") {
    const res = await this.execSqlWithBind(sql, bind, rowMode);
    if (!isReadOnlySql(sql)) {
      setTimeout(() => this.undoRedoManager.event(), 30);
    }
    return res;
  }
  // return object array
  async sql4mainThread2(sql, bind = []) {
    return this.execSqlWithBind(sql, bind, "object");
  }
  onUpdate() {
    this.postMessage?.({
      type: "DataUpdateSignal" /* DataUpdateSignal */,
      data: {
        database: this.dbName
      }
    });
    console.debug("onUpdate");
  }
  notify(msg) {
    this.postMessage?.({
      type: "Notify" /* Notify */,
      data: msg
    });
  }
  blockUIMsg(msg, data) {
    console.log("blockUIMsg", msg, data);
    this.postMessage?.({
      type: "BlockUIMsg" /* BlockUIMsg */,
      data: {
        msg,
        data
      }
    });
  }
  /**
   *  cloudflare worker 
   * worker  api-agent api-agent  currentSpace.email() 
   * @param email 
   */
  email(email) {
  }
  // Add new public methods for FTS functionality
  async createTableFTS(tableName, temporary = false) {
    return await this.tableFullTextSearch.createDynamicFTS(tableName, temporary);
  }
  async searchTableFTS(tableName, query, viewId, page = 1, pageSize = 20) {
    return await this.tableFullTextSearch.search(tableName, query, viewId, page, pageSize);
  }
  async hasTableFTS(tableName) {
    return await this.tableFullTextSearch.hasFTS(tableName);
  }
};
__decorateClass([
  timeit(100)
], DataSpace.prototype, "addRow", 1);
__decorateClass([
  timeit(100)
], DataSpace.prototype, "addDoc", 1);
__decorateClass([
  timeit(100)
], DataSpace.prototype, "createTableViaSchema", 1);
__decorateClass([
  timeit(100)
], DataSpace.prototype, "syncExec2", 1);
__decorateClass([
  timeit(100)
], DataSpace.prototype, "execute", 1);
__decorateClass([
  timeit(100)
], DataSpace.prototype, "exec", 1);
__decorateClass([
  timeit(100)
], DataSpace.prototype, "execSqlWithBind", 1);
__decorateClass([
  timeit(100)
], DataSpace.prototype, "sql4mainThread", 1);

// apps/publish/lib/sqlite-provider/eidos-sqlite-server.ts
var EidosSQLiteServerDatabase = class extends BaseServerDatabase {
  constructor(config) {
    super();
    __publicField(this, "databaseName");
    __publicField(this, "config");
    this.databaseName = config.dbName;
    this.config = config;
  }
  createFunction() {
    throw new Error("Method not implemented.");
  }
  prepare(sql) {
  }
  close() {
  }
  async selectObjects(sql, bind = []) {
    const result = await this.queryDatabase(sql, bind);
    return result;
  }
  async call(sql, bind = [], rowMode = "object") {
    const result = await this.queryDatabase(sql, bind);
    if (rowMode === "object") {
      return result;
    } else {
      return result.map((row) => Object.values(row));
    }
  }
  transaction() {
  }
  async exec(opts) {
    if (typeof opts === "string") {
      const rows = await this.selectObjects(opts);
      return rows;
    } else if (typeof opts === "object") {
      const { sql, bind = [], rowMode = "object" } = opts;
      const rows = await this.call(sql, bind, rowMode);
      return rows;
    }
    throw new Error("Invalid opts");
  }
  async queryDatabase(sql, bind = []) {
    const response = await fetch(this.config.url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ dbName: this.config.dbName, sql, bind })
    });
    if (!response.ok) {
      throw new Error(`query failed: ${response.status} ${response.statusText}`);
    }
    const result = await response.json();
    return result;
  }
};

// apps/publish/lib/sqlite-provider/sqlite-clound.ts
var SQLiteCloudServerDatabase = class extends BaseServerDatabase {
  constructor(config) {
    super();
    __publicField(this, "databaseName");
    __publicField(this, "config");
    this.databaseName = config.dbName;
    this.config = config;
  }
  createFunction() {
    throw new Error("Method not implemented.");
  }
  prepare(sql) {
  }
  close() {
  }
  async selectObjects(sql) {
    return await this.call(sql, []);
  }
  async call(sql, bind, rowMode = "object") {
    const _bind = [...bind];
    const _sql = sql.replace(/\?/g, () => {
      const value2 = _bind.shift();
      if (typeof value2 === "string") {
        return `'${value2}'`;
      } else if (value2 === null || value2 === void 0) {
        return "NULL";
      } else {
        return value2;
      }
    });
    console.log("call", _sql);
    const data = {
      "database": this.config.dbName,
      "sql": _sql
    };
    const res = await fetch(this.config.url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.config.apiKey}`
      },
      body: JSON.stringify(data)
    });
    const json = await res.json();
    if (rowMode === "object") {
      return json.data;
    }
    const res1 = json.data.map((row) => {
      return json.metadata.columns.map((col, index) => {
        return row[col.name];
      });
    });
    return res1;
  }
  transaction() {
  }
  async exec(opts) {
    if (typeof opts === "string") {
      const rows = await this.selectObjects(opts);
      return rows;
    } else if (typeof opts === "object") {
      const { sql, bind, rowMode } = opts;
      const rows = await this.call(sql, bind, rowMode);
      return rows;
    }
    throw new Error("Invalid opts");
  }
};

// node_modules/.pnpm/@libsql+core@0.8.1/node_modules/@libsql/core/lib-esm/api.js
var LibsqlError = class extends Error {
  constructor(message, code, rawCode, cause) {
    if (code !== void 0) {
      message = `${code}: ${message}`;
    }
    super(message, { cause });
    /** Machine-readable error code. */
    __publicField(this, "code");
    /** Raw numeric error code */
    __publicField(this, "rawCode");
    this.code = code;
    this.rawCode = rawCode;
    this.name = "LibsqlError";
  }
};

// node_modules/.pnpm/@libsql+core@0.8.1/node_modules/@libsql/core/lib-esm/uri.js
function parseUri(text) {
  const match = URI_RE.exec(text);
  if (match === null) {
    throw new LibsqlError(`The URL '${text}' is not in a valid format`, "URL_INVALID");
  }
  const groups = match.groups;
  const scheme = groups["scheme"];
  const authority = groups["authority"] !== void 0 ? parseAuthority(groups["authority"]) : void 0;
  const path = percentDecode(groups["path"]);
  const query = groups["query"] !== void 0 ? parseQuery(groups["query"]) : void 0;
  const fragment = groups["fragment"] !== void 0 ? percentDecode(groups["fragment"]) : void 0;
  return { scheme, authority, path, query, fragment };
}
var URI_RE = (() => {
  const SCHEME = "(?<scheme>[A-Za-z][A-Za-z.+-]*)";
  const AUTHORITY = "(?<authority>[^/?#]*)";
  const PATH = "(?<path>[^?#]*)";
  const QUERY = "(?<query>[^#]*)";
  const FRAGMENT = "(?<fragment>.*)";
  return new RegExp(`^${SCHEME}:(//${AUTHORITY})?${PATH}(\\?${QUERY})?(#${FRAGMENT})?$`, "su");
})();
function parseAuthority(text) {
  const match = AUTHORITY_RE.exec(text);
  if (match === null) {
    throw new LibsqlError("The authority part of the URL is not in a valid format", "URL_INVALID");
  }
  const groups = match.groups;
  const host = percentDecode(groups["host_br"] ?? groups["host"]);
  const port = groups["port"] ? parseInt(groups["port"], 10) : void 0;
  const userinfo = groups["username"] !== void 0 ? {
    username: percentDecode(groups["username"]),
    password: groups["password"] !== void 0 ? percentDecode(groups["password"]) : void 0
  } : void 0;
  return { host, port, userinfo };
}
var AUTHORITY_RE = (() => {
  return new RegExp(`^((?<username>[^:]*)(:(?<password>.*))?@)?((?<host>[^:\\[\\]]*)|(\\[(?<host_br>[^\\[\\]]*)\\]))(:(?<port>[0-9]*))?$`, "su");
})();
function parseQuery(text) {
  const sequences = text.split("&");
  const pairs = [];
  for (const sequence of sequences) {
    if (sequence === "") {
      continue;
    }
    let key;
    let value2;
    const splitIdx = sequence.indexOf("=");
    if (splitIdx < 0) {
      key = sequence;
      value2 = "";
    } else {
      key = sequence.substring(0, splitIdx);
      value2 = sequence.substring(splitIdx + 1);
    }
    pairs.push({
      key: percentDecode(key.replaceAll("+", " ")),
      value: percentDecode(value2.replaceAll("+", " "))
    });
  }
  return { pairs };
}
function percentDecode(text) {
  try {
    return decodeURIComponent(text);
  } catch (e) {
    if (e instanceof URIError) {
      throw new LibsqlError(`URL component has invalid percent encoding: ${e}`, "URL_INVALID", void 0, e);
    }
    throw e;
  }
}
function encodeBaseUrl(scheme, authority, path) {
  if (authority === void 0) {
    throw new LibsqlError(`URL with scheme ${JSON.stringify(scheme + ":")} requires authority (the "//" part)`, "URL_INVALID");
  }
  const schemeText = `${scheme}:`;
  const hostText = encodeHost(authority.host);
  const portText = encodePort(authority.port);
  const userinfoText = encodeUserinfo(authority.userinfo);
  const authorityText = `//${userinfoText}${hostText}${portText}`;
  let pathText = path.split("/").map(encodeURIComponent).join("/");
  if (pathText !== "" && !pathText.startsWith("/")) {
    pathText = "/" + pathText;
  }
  return new URL(`${schemeText}${authorityText}${pathText}`);
}
function encodeHost(host) {
  return host.includes(":") ? `[${encodeURI(host)}]` : encodeURI(host);
}
function encodePort(port) {
  return port !== void 0 ? `:${port}` : "";
}
function encodeUserinfo(userinfo) {
  if (userinfo === void 0) {
    return "";
  }
  const usernameText = encodeURIComponent(userinfo.username);
  const passwordText = userinfo.password !== void 0 ? `:${encodeURIComponent(userinfo.password)}` : "";
  return `${usernameText}${passwordText}@`;
}

// node_modules/.pnpm/js-base64@3.7.7/node_modules/js-base64/base64.mjs
var version = "3.7.7";
var VERSION = version;
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a) => {
  let tab2 = {};
  a.forEach((c, i) => tab2[c] = i);
  return tab2;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = typeof btoa === "function" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var cb_utob = (c) => {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = (u) => u.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
var encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
var encodeURI2 = (src) => encode(src, true);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
var btou = (b) => b.replace(re_btou, cb_btou);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
var _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a).split("").map((c) => c.charCodeAt(0)));
var toUint8Array = (a) => _toUint8Array(_unURI(a));
var _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
var decode = (src) => _decode(_unURI(src));
var isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
var _noEnum = (v) => {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
var extendString = function() {
  const _add = (name2, body) => Object.defineProperty(String.prototype, name2, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode(this, true);
  });
  _add("toBase64URL", function() {
    return encode(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
var extendUint8Array = function() {
  const _add = (name2, body) => Object.defineProperty(Uint8Array.prototype, name2, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
var extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
var gBase64 = {
  version,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI: encodeURI2,
  encodeURL: encodeURI2,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};

// node_modules/.pnpm/@libsql+core@0.8.1/node_modules/@libsql/core/lib-esm/util.js
var supportedUrlLink = "https://github.com/libsql/libsql-client-ts#supported-urls";
function transactionModeToBegin(mode) {
  if (mode === "write") {
    return "BEGIN IMMEDIATE";
  } else if (mode === "read") {
    return "BEGIN TRANSACTION READONLY";
  } else if (mode === "deferred") {
    return "BEGIN DEFERRED";
  } else {
    throw RangeError('Unknown transaction mode, supported values are "write", "read" and "deferred"');
  }
}
var ResultSetImpl = class {
  constructor(columns, columnTypes, rows, rowsAffected, lastInsertRowid) {
    __publicField(this, "columns");
    __publicField(this, "columnTypes");
    __publicField(this, "rows");
    __publicField(this, "rowsAffected");
    __publicField(this, "lastInsertRowid");
    this.columns = columns;
    this.columnTypes = columnTypes;
    this.rows = rows;
    this.rowsAffected = rowsAffected;
    this.lastInsertRowid = lastInsertRowid;
  }
  toJSON() {
    return {
      columns: this.columns,
      columnTypes: this.columnTypes,
      rows: this.rows.map(rowToJson),
      rowsAffected: this.rowsAffected,
      lastInsertRowid: this.lastInsertRowid !== void 0 ? "" + this.lastInsertRowid : null
    };
  }
};
function rowToJson(row) {
  return Array.prototype.map.call(row, valueToJson);
}
function valueToJson(value2) {
  if (typeof value2 === "bigint") {
    return "" + value2;
  } else if (value2 instanceof ArrayBuffer) {
    return gBase64.fromUint8Array(new Uint8Array(value2));
  } else {
    return value2;
  }
}

// node_modules/.pnpm/@libsql+core@0.8.1/node_modules/@libsql/core/lib-esm/config.js
var inMemoryMode = ":memory:";
function expandConfig(config, preferHttp) {
  if (typeof config !== "object") {
    throw new TypeError(`Expected client configuration as object, got ${typeof config}`);
  }
  let { url, authToken, tls, intMode, concurrency } = config;
  concurrency = Math.max(0, concurrency || 20);
  intMode ?? (intMode = "number");
  let connectionQueryParams = [];
  if (url === inMemoryMode) {
    url = "file::memory:";
  }
  const uri = parseUri(url);
  const originalUriScheme = uri.scheme.toLowerCase();
  const isInMemoryMode = originalUriScheme === "file" && uri.path === inMemoryMode && uri.authority === void 0;
  let queryParamsDef;
  if (isInMemoryMode) {
    queryParamsDef = {
      cache: {
        values: ["shared", "private"],
        update: (key, value2) => connectionQueryParams.push(`${key}=${value2}`)
      }
    };
  } else {
    queryParamsDef = {
      tls: {
        values: ["0", "1"],
        update: (_, value2) => tls = value2 === "1"
      },
      authToken: {
        update: (_, value2) => authToken = value2
      }
    };
  }
  for (const { key, value: value2 } of uri.query?.pairs ?? []) {
    if (!Object.hasOwn(queryParamsDef, key)) {
      throw new LibsqlError(`Unsupported URL query parameter ${JSON.stringify(key)}`, "URL_PARAM_NOT_SUPPORTED");
    }
    const queryParamDef = queryParamsDef[key];
    if (queryParamDef.values !== void 0 && !queryParamDef.values.includes(value2)) {
      throw new LibsqlError(`Unknown value for the "${key}" query argument: ${JSON.stringify(value2)}. Supported values are: [${queryParamDef.values.map((x) => '"' + x + '"').join(", ")}]`, "URL_INVALID");
    }
    if (queryParamDef.update !== void 0) {
      queryParamDef?.update(key, value2);
    }
  }
  const connectionQueryParamsString = connectionQueryParams.length === 0 ? "" : `?${connectionQueryParams.join("&")}`;
  const path = uri.path + connectionQueryParamsString;
  let scheme;
  if (originalUriScheme === "libsql") {
    if (tls === false) {
      if (uri.authority?.port === void 0) {
        throw new LibsqlError('A "libsql:" URL with ?tls=0 must specify an explicit port', "URL_INVALID");
      }
      scheme = preferHttp ? "http" : "ws";
    } else {
      scheme = preferHttp ? "https" : "wss";
    }
  } else {
    scheme = originalUriScheme;
  }
  if (scheme === "http" || scheme === "ws") {
    tls ?? (tls = false);
  } else {
    tls ?? (tls = true);
  }
  if (scheme !== "http" && scheme !== "ws" && scheme !== "https" && scheme !== "wss" && scheme !== "file") {
    throw new LibsqlError(`The client supports only "libsql:", "wss:", "ws:", "https:", "http:" and "file:" URLs, got ${JSON.stringify(uri.scheme + ":")}. For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
  if (intMode !== "number" && intMode !== "bigint" && intMode !== "string") {
    throw new TypeError(`Invalid value for intMode, expected "number", "bigint" or "string", got ${JSON.stringify(intMode)}`);
  }
  if (uri.fragment !== void 0) {
    throw new LibsqlError(`URL fragments are not supported: ${JSON.stringify("#" + uri.fragment)}`, "URL_INVALID");
  }
  if (isInMemoryMode) {
    return {
      scheme: "file",
      tls: false,
      path,
      intMode,
      concurrency,
      syncUrl: config.syncUrl,
      syncInterval: config.syncInterval,
      fetch: config.fetch,
      authToken: void 0,
      encryptionKey: void 0,
      authority: void 0
    };
  }
  return {
    scheme,
    tls,
    authority: uri.authority,
    path,
    authToken,
    intMode,
    concurrency,
    encryptionKey: config.encryptionKey,
    syncUrl: config.syncUrl,
    syncInterval: config.syncInterval,
    fetch: config.fetch
  };
}

// node_modules/.pnpm/@libsql+isomorphic-ws@0.1.5_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/isomorphic-ws/web.mjs
var _WebSocket;
if (typeof WebSocket !== "undefined") {
  _WebSocket = WebSocket;
} else if (typeof global !== "undefined") {
  _WebSocket = global.WebSocket;
} else if (typeof window !== "undefined") {
  _WebSocket = window.WebSocket;
} else if (typeof self !== "undefined") {
  _WebSocket = self.WebSocket;
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/client.js
var Client = class {
  /** @private */
  constructor() {
    /** Representation of integers returned from the database. See {@link IntMode}.
     *
     * This value is inherited by {@link Stream} objects created with {@link openStream}, but you can
     * override the integer mode for every stream by setting {@link Stream.intMode} on the stream.
     */
    __publicField(this, "intMode");
    this.intMode = "number";
  }
};

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/errors.js
var ClientError = class extends Error {
  /** @private */
  constructor(message) {
    super(message);
    this.name = "ClientError";
  }
};
var ProtoError = class extends ClientError {
  /** @private */
  constructor(message) {
    super(message);
    this.name = "ProtoError";
  }
};
var ResponseError = class extends ClientError {
  /** @private */
  constructor(message, protoError) {
    super(message);
    __publicField(this, "code");
    /** @internal */
    __publicField(this, "proto");
    this.name = "ResponseError";
    this.code = protoError.code;
    this.proto = protoError;
    this.stack = void 0;
  }
};
var ClosedError = class extends ClientError {
  /** @private */
  constructor(message, cause) {
    if (cause !== void 0) {
      super(`${message}: ${cause}`);
      this.cause = cause;
    } else {
      super(message);
    }
    this.name = "ClosedError";
  }
};
var WebSocketUnsupportedError = class extends ClientError {
  /** @private */
  constructor(message) {
    super(message);
    this.name = "WebSocketUnsupportedError";
  }
};
var WebSocketError = class extends ClientError {
  /** @private */
  constructor(message) {
    super(message);
    this.name = "WebSocketError";
  }
};
var HttpServerError = class extends ClientError {
  /** @private */
  constructor(message, status) {
    super(message);
    __publicField(this, "status");
    this.status = status;
    this.name = "HttpServerError";
  }
};
var ProtocolVersionError = class extends ClientError {
  /** @private */
  constructor(message) {
    super(message);
    this.name = "ProtocolVersionError";
  }
};
var InternalError = class extends ClientError {
  /** @private */
  constructor(message) {
    super(message);
    this.name = "InternalError";
  }
};
var MisuseError = class extends ClientError {
  /** @private */
  constructor(message) {
    super(message);
    this.name = "MisuseError";
  }
};

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/encoding/json/decode.js
function string2(value2) {
  if (typeof value2 === "string") {
    return value2;
  }
  throw typeError(value2, "string");
}
function stringOpt(value2) {
  if (value2 === null || value2 === void 0) {
    return void 0;
  } else if (typeof value2 === "string") {
    return value2;
  }
  throw typeError(value2, "string or null");
}
function number(value2) {
  if (typeof value2 === "number") {
    return value2;
  }
  throw typeError(value2, "number");
}
function boolean(value2) {
  if (typeof value2 === "boolean") {
    return value2;
  }
  throw typeError(value2, "boolean");
}
function array(value2) {
  if (Array.isArray(value2)) {
    return value2;
  }
  throw typeError(value2, "array");
}
function object(value2) {
  if (value2 !== null && typeof value2 === "object" && !Array.isArray(value2)) {
    return value2;
  }
  throw typeError(value2, "object");
}
function arrayObjectsMap(value2, fun) {
  return array(value2).map((elemValue) => fun(object(elemValue)));
}
function typeError(value2, expected) {
  if (value2 === void 0) {
    return new ProtoError(`Expected ${expected}, but the property was missing`);
  }
  let received = typeof value2;
  if (value2 === null) {
    received = "null";
  } else if (Array.isArray(value2)) {
    received = "array";
  }
  return new ProtoError(`Expected ${expected}, received ${received}`);
}
function readJsonObject(value2, fun) {
  return fun(object(value2));
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/encoding/json/encode.js
var _output, _isFirst, _ObjectWriter_instances, key_fn;
var ObjectWriter = class {
  constructor(output) {
    __privateAdd(this, _ObjectWriter_instances);
    __privateAdd(this, _output);
    __privateAdd(this, _isFirst);
    __privateSet(this, _output, output);
    __privateSet(this, _isFirst, false);
  }
  begin() {
    __privateGet(this, _output).push("{");
    __privateSet(this, _isFirst, true);
  }
  end() {
    __privateGet(this, _output).push("}");
    __privateSet(this, _isFirst, false);
  }
  string(name2, value2) {
    __privateMethod(this, _ObjectWriter_instances, key_fn).call(this, name2);
    __privateGet(this, _output).push(JSON.stringify(value2));
  }
  stringRaw(name2, value2) {
    __privateMethod(this, _ObjectWriter_instances, key_fn).call(this, name2);
    __privateGet(this, _output).push('"');
    __privateGet(this, _output).push(value2);
    __privateGet(this, _output).push('"');
  }
  number(name2, value2) {
    __privateMethod(this, _ObjectWriter_instances, key_fn).call(this, name2);
    __privateGet(this, _output).push("" + value2);
  }
  boolean(name2, value2) {
    __privateMethod(this, _ObjectWriter_instances, key_fn).call(this, name2);
    __privateGet(this, _output).push(value2 ? "true" : "false");
  }
  object(name2, value2, valueFun) {
    __privateMethod(this, _ObjectWriter_instances, key_fn).call(this, name2);
    this.begin();
    valueFun(this, value2);
    this.end();
  }
  arrayObjects(name2, values, valueFun) {
    __privateMethod(this, _ObjectWriter_instances, key_fn).call(this, name2);
    __privateGet(this, _output).push("[");
    for (let i = 0; i < values.length; ++i) {
      if (i !== 0) {
        __privateGet(this, _output).push(",");
      }
      this.begin();
      valueFun(this, values[i]);
      this.end();
    }
    __privateGet(this, _output).push("]");
  }
};
_output = new WeakMap();
_isFirst = new WeakMap();
_ObjectWriter_instances = new WeakSet();
key_fn = function(name2) {
  if (__privateGet(this, _isFirst)) {
    __privateGet(this, _output).push('"');
    __privateSet(this, _isFirst, false);
  } else {
    __privateGet(this, _output).push(',"');
  }
  __privateGet(this, _output).push(name2);
  __privateGet(this, _output).push('":');
};
function writeJsonObject(value2, fun) {
  const output = [];
  const writer = new ObjectWriter(output);
  writer.begin();
  fun(writer, value2);
  writer.end();
  return output.join("");
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.js
var VARINT = 0;
var FIXED_64 = 1;
var LENGTH_DELIMITED = 2;
var FIXED_32 = 5;

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/decode.js
var _array, _view, _pos;
var MessageReader = class {
  constructor(array2) {
    __privateAdd(this, _array);
    __privateAdd(this, _view);
    __privateAdd(this, _pos);
    __privateSet(this, _array, array2);
    __privateSet(this, _view, new DataView(array2.buffer, array2.byteOffset, array2.byteLength));
    __privateSet(this, _pos, 0);
  }
  varint() {
    let value2 = 0;
    for (let shift = 0; ; shift += 7) {
      const byte = __privateGet(this, _array)[__privateWrapper(this, _pos)._++];
      value2 |= (byte & 127) << shift;
      if (!(byte & 128)) {
        break;
      }
    }
    return value2;
  }
  varintBig() {
    let value2 = 0n;
    for (let shift = 0n; ; shift += 7n) {
      const byte = __privateGet(this, _array)[__privateWrapper(this, _pos)._++];
      value2 |= BigInt(byte & 127) << shift;
      if (!(byte & 128)) {
        break;
      }
    }
    return value2;
  }
  bytes(length) {
    const array2 = new Uint8Array(__privateGet(this, _array).buffer, __privateGet(this, _array).byteOffset + __privateGet(this, _pos), length);
    __privateSet(this, _pos, __privateGet(this, _pos) + length);
    return array2;
  }
  double() {
    const value2 = __privateGet(this, _view).getFloat64(__privateGet(this, _pos), true);
    __privateSet(this, _pos, __privateGet(this, _pos) + 8);
    return value2;
  }
  skipVarint() {
    for (; ; ) {
      const byte = __privateGet(this, _array)[__privateWrapper(this, _pos)._++];
      if (!(byte & 128)) {
        break;
      }
    }
  }
  skip(count) {
    __privateSet(this, _pos, __privateGet(this, _pos) + count);
  }
  eof() {
    return __privateGet(this, _pos) >= __privateGet(this, _array).byteLength;
  }
};
_array = new WeakMap();
_view = new WeakMap();
_pos = new WeakMap();
var _reader, _wireType, _FieldReader_instances, expect_fn;
var FieldReader = class {
  constructor(reader) {
    __privateAdd(this, _FieldReader_instances);
    __privateAdd(this, _reader);
    __privateAdd(this, _wireType);
    __privateSet(this, _reader, reader);
    __privateSet(this, _wireType, -1);
  }
  setup(wireType) {
    __privateSet(this, _wireType, wireType);
  }
  bytes() {
    __privateMethod(this, _FieldReader_instances, expect_fn).call(this, LENGTH_DELIMITED);
    const length = __privateGet(this, _reader).varint();
    return __privateGet(this, _reader).bytes(length);
  }
  string() {
    return new TextDecoder().decode(this.bytes());
  }
  message(def) {
    return readProtobufMessage(this.bytes(), def);
  }
  int32() {
    __privateMethod(this, _FieldReader_instances, expect_fn).call(this, VARINT);
    return __privateGet(this, _reader).varint();
  }
  uint32() {
    return this.int32();
  }
  bool() {
    return this.int32() !== 0;
  }
  uint64() {
    __privateMethod(this, _FieldReader_instances, expect_fn).call(this, VARINT);
    return __privateGet(this, _reader).varintBig();
  }
  sint64() {
    const value2 = this.uint64();
    return value2 >> 1n ^ -(value2 & 1n);
  }
  double() {
    __privateMethod(this, _FieldReader_instances, expect_fn).call(this, FIXED_64);
    return __privateGet(this, _reader).double();
  }
  maybeSkip() {
    if (__privateGet(this, _wireType) < 0) {
      return;
    } else if (__privateGet(this, _wireType) === VARINT) {
      __privateGet(this, _reader).skipVarint();
    } else if (__privateGet(this, _wireType) === FIXED_64) {
      __privateGet(this, _reader).skip(8);
    } else if (__privateGet(this, _wireType) === LENGTH_DELIMITED) {
      const length = __privateGet(this, _reader).varint();
      __privateGet(this, _reader).skip(length);
    } else if (__privateGet(this, _wireType) === FIXED_32) {
      __privateGet(this, _reader).skip(4);
    } else {
      throw new ProtoError(`Unexpected wire type ${__privateGet(this, _wireType)}`);
    }
    __privateSet(this, _wireType, -1);
  }
};
_reader = new WeakMap();
_wireType = new WeakMap();
_FieldReader_instances = new WeakSet();
expect_fn = function(expectedWireType) {
  if (__privateGet(this, _wireType) !== expectedWireType) {
    throw new ProtoError(`Expected wire type ${expectedWireType}, got ${__privateGet(this, _wireType)}`);
  }
  __privateSet(this, _wireType, -1);
};
function readProtobufMessage(data, def) {
  const msgReader = new MessageReader(data);
  const fieldReader = new FieldReader(msgReader);
  let value2 = def.default();
  while (!msgReader.eof()) {
    const key = msgReader.varint();
    const tag = key >> 3;
    const wireType = key & 7;
    fieldReader.setup(wireType);
    const tagFun = def[tag];
    if (tagFun !== void 0) {
      const returnedValue = tagFun(fieldReader, value2);
      if (returnedValue !== void 0) {
        value2 = returnedValue;
      }
    }
    fieldReader.maybeSkip();
  }
  return value2;
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/encode.js
var _buf, _array2, _view2, _pos2, _MessageWriter_instances, ensure_fn, varint_fn, varintBig_fn, tag_fn;
var _MessageWriter = class _MessageWriter {
  constructor() {
    __privateAdd(this, _MessageWriter_instances);
    __privateAdd(this, _buf);
    __privateAdd(this, _array2);
    __privateAdd(this, _view2);
    __privateAdd(this, _pos2);
    __privateSet(this, _buf, new ArrayBuffer(256));
    __privateSet(this, _array2, new Uint8Array(__privateGet(this, _buf)));
    __privateSet(this, _view2, new DataView(__privateGet(this, _buf)));
    __privateSet(this, _pos2, 0);
  }
  bytes(tag, value2) {
    __privateMethod(this, _MessageWriter_instances, tag_fn).call(this, tag, LENGTH_DELIMITED);
    __privateMethod(this, _MessageWriter_instances, varint_fn).call(this, value2.byteLength);
    __privateMethod(this, _MessageWriter_instances, ensure_fn).call(this, value2.byteLength);
    __privateGet(this, _array2).set(value2, __privateGet(this, _pos2));
    __privateSet(this, _pos2, __privateGet(this, _pos2) + value2.byteLength);
  }
  string(tag, value2) {
    this.bytes(tag, new TextEncoder().encode(value2));
  }
  message(tag, value2, fun) {
    const writer = new _MessageWriter();
    fun(writer, value2);
    this.bytes(tag, writer.data());
  }
  int32(tag, value2) {
    __privateMethod(this, _MessageWriter_instances, tag_fn).call(this, tag, VARINT);
    __privateMethod(this, _MessageWriter_instances, varint_fn).call(this, value2);
  }
  uint32(tag, value2) {
    this.int32(tag, value2);
  }
  bool(tag, value2) {
    this.int32(tag, value2 ? 1 : 0);
  }
  sint64(tag, value2) {
    __privateMethod(this, _MessageWriter_instances, tag_fn).call(this, tag, VARINT);
    __privateMethod(this, _MessageWriter_instances, varintBig_fn).call(this, value2 << 1n ^ value2 >> 63n);
  }
  double(tag, value2) {
    __privateMethod(this, _MessageWriter_instances, tag_fn).call(this, tag, FIXED_64);
    __privateMethod(this, _MessageWriter_instances, ensure_fn).call(this, 8);
    __privateGet(this, _view2).setFloat64(__privateGet(this, _pos2), value2, true);
    __privateSet(this, _pos2, __privateGet(this, _pos2) + 8);
  }
  data() {
    return new Uint8Array(__privateGet(this, _buf), 0, __privateGet(this, _pos2));
  }
};
_buf = new WeakMap();
_array2 = new WeakMap();
_view2 = new WeakMap();
_pos2 = new WeakMap();
_MessageWriter_instances = new WeakSet();
ensure_fn = function(extra) {
  if (__privateGet(this, _pos2) + extra <= __privateGet(this, _buf).byteLength) {
    return;
  }
  let newCap = __privateGet(this, _buf).byteLength;
  while (newCap < __privateGet(this, _pos2) + extra) {
    newCap *= 2;
  }
  const newBuf = new ArrayBuffer(newCap);
  const newArray = new Uint8Array(newBuf);
  const newView = new DataView(newBuf);
  newArray.set(new Uint8Array(__privateGet(this, _buf), 0, __privateGet(this, _pos2)));
  __privateSet(this, _buf, newBuf);
  __privateSet(this, _array2, newArray);
  __privateSet(this, _view2, newView);
};
varint_fn = function(value2) {
  __privateMethod(this, _MessageWriter_instances, ensure_fn).call(this, 5);
  value2 = 0 | value2;
  do {
    let byte = value2 & 127;
    value2 >>>= 7;
    byte |= value2 ? 128 : 0;
    __privateGet(this, _array2)[__privateWrapper(this, _pos2)._++] = byte;
  } while (value2);
};
varintBig_fn = function(value2) {
  __privateMethod(this, _MessageWriter_instances, ensure_fn).call(this, 10);
  value2 = value2 & 0xffffffffffffffffn;
  do {
    let byte = Number(value2 & 0x7fn);
    value2 >>= 7n;
    byte |= value2 ? 128 : 0;
    __privateGet(this, _array2)[__privateWrapper(this, _pos2)._++] = byte;
  } while (value2);
};
tag_fn = function(tag, wireType) {
  __privateMethod(this, _MessageWriter_instances, varint_fn).call(this, tag << 3 | wireType);
};
var MessageWriter = _MessageWriter;
function writeProtobufMessage(value2, fun) {
  const w = new MessageWriter();
  fun(w, value2);
  return w.data();
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/id_alloc.js
var _usedIds, _freeIds;
var IdAlloc = class {
  constructor() {
    // Set of all allocated ids
    __privateAdd(this, _usedIds);
    // Set of all free ids lower than `#usedIds.size`
    __privateAdd(this, _freeIds);
    __privateSet(this, _usedIds, /* @__PURE__ */ new Set());
    __privateSet(this, _freeIds, /* @__PURE__ */ new Set());
  }
  // Returns an id that was free, and marks it as used.
  alloc() {
    for (const freeId2 of __privateGet(this, _freeIds)) {
      __privateGet(this, _freeIds).delete(freeId2);
      __privateGet(this, _usedIds).add(freeId2);
      if (!__privateGet(this, _usedIds).has(__privateGet(this, _usedIds).size - 1)) {
        __privateGet(this, _freeIds).add(__privateGet(this, _usedIds).size - 1);
      }
      return freeId2;
    }
    const freeId = __privateGet(this, _usedIds).size;
    __privateGet(this, _usedIds).add(freeId);
    return freeId;
  }
  free(id) {
    if (!__privateGet(this, _usedIds).delete(id)) {
      throw new InternalError("Freeing an id that is not allocated");
    }
    __privateGet(this, _freeIds).delete(__privateGet(this, _usedIds).size);
    if (id < __privateGet(this, _usedIds).size) {
      __privateGet(this, _freeIds).add(id);
    }
  }
};
_usedIds = new WeakMap();
_freeIds = new WeakMap();

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/util.js
function impossible(value2, message) {
  throw new InternalError(message);
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/value.js
function valueToProto(value2) {
  if (value2 === null) {
    return null;
  } else if (typeof value2 === "string") {
    return value2;
  } else if (typeof value2 === "number") {
    if (!Number.isFinite(value2)) {
      throw new RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");
    }
    return value2;
  } else if (typeof value2 === "bigint") {
    if (value2 < minInteger || value2 > maxInteger) {
      throw new RangeError("This bigint value is too large to be represented as a 64-bit integer and passed as argument");
    }
    return value2;
  } else if (typeof value2 === "boolean") {
    return value2 ? 1n : 0n;
  } else if (value2 instanceof ArrayBuffer) {
    return new Uint8Array(value2);
  } else if (value2 instanceof Uint8Array) {
    return value2;
  } else if (value2 instanceof Date) {
    return +value2.valueOf();
  } else if (typeof value2 === "object") {
    return "" + value2.toString();
  } else {
    throw new TypeError("Unsupported type of value");
  }
}
var minInteger = -9223372036854775808n;
var maxInteger = 9223372036854775807n;
function valueFromProto(value2, intMode) {
  if (value2 === null) {
    return null;
  } else if (typeof value2 === "number") {
    return value2;
  } else if (typeof value2 === "string") {
    return value2;
  } else if (typeof value2 === "bigint") {
    if (intMode === "number") {
      const num = Number(value2);
      if (!Number.isSafeInteger(num)) {
        throw new RangeError("Received integer which is too large to be safely represented as a JavaScript number");
      }
      return num;
    } else if (intMode === "bigint") {
      return value2;
    } else if (intMode === "string") {
      return "" + value2;
    } else {
      throw new MisuseError("Invalid value for IntMode");
    }
  } else if (value2 instanceof Uint8Array) {
    return value2.slice().buffer;
  } else if (value2 === void 0) {
    throw new ProtoError("Received unrecognized type of Value");
  } else {
    throw impossible(value2, "Impossible type of Value");
  }
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/result.js
function stmtResultFromProto(result) {
  return {
    affectedRowCount: result.affectedRowCount,
    lastInsertRowid: result.lastInsertRowid,
    columnNames: result.cols.map((col) => col.name),
    columnDecltypes: result.cols.map((col) => col.decltype)
  };
}
function rowsResultFromProto(result, intMode) {
  const stmtResult = stmtResultFromProto(result);
  const rows = result.rows.map((row) => rowFromProto(stmtResult.columnNames, row, intMode));
  return { ...stmtResult, rows };
}
function rowResultFromProto(result, intMode) {
  const stmtResult = stmtResultFromProto(result);
  let row;
  if (result.rows.length > 0) {
    row = rowFromProto(stmtResult.columnNames, result.rows[0], intMode);
  }
  return { ...stmtResult, row };
}
function valueResultFromProto(result, intMode) {
  const stmtResult = stmtResultFromProto(result);
  let value2;
  if (result.rows.length > 0 && stmtResult.columnNames.length > 0) {
    value2 = valueFromProto(result.rows[0][0], intMode);
  }
  return { ...stmtResult, value: value2 };
}
function rowFromProto(colNames, values, intMode) {
  const row = {};
  Object.defineProperty(row, "length", { value: values.length });
  for (let i = 0; i < values.length; ++i) {
    const value2 = valueFromProto(values[i], intMode);
    Object.defineProperty(row, i, { value: value2 });
    const colName = colNames[i];
    if (colName !== void 0 && !Object.hasOwn(row, colName)) {
      Object.defineProperty(row, colName, { value: value2, enumerable: true, configurable: true, writable: true });
    }
  }
  return row;
}
function errorFromProto(error) {
  return new ResponseError(error.message, error);
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/sql.js
var _owner, _sqlId, _closed;
var Sql = class {
  /** @private */
  constructor(owner, sqlId) {
    __privateAdd(this, _owner);
    __privateAdd(this, _sqlId);
    __privateAdd(this, _closed);
    __privateSet(this, _owner, owner);
    __privateSet(this, _sqlId, sqlId);
    __privateSet(this, _closed, void 0);
  }
  /** @private */
  _getSqlId(owner) {
    if (__privateGet(this, _owner) !== owner) {
      throw new MisuseError("Attempted to use SQL text opened with other object");
    } else if (__privateGet(this, _closed) !== void 0) {
      throw new ClosedError("SQL text is closed", __privateGet(this, _closed));
    }
    return __privateGet(this, _sqlId);
  }
  /** Remove the SQL text from the server, releasing resouces. */
  close() {
    this._setClosed(new ClientError("SQL text was manually closed"));
  }
  /** @private */
  _setClosed(error) {
    if (__privateGet(this, _closed) === void 0) {
      __privateSet(this, _closed, error);
      __privateGet(this, _owner)._closeSql(__privateGet(this, _sqlId));
    }
  }
  /** True if the SQL text is closed (removed from the server). */
  get closed() {
    return __privateGet(this, _closed) !== void 0;
  }
};
_owner = new WeakMap();
_sqlId = new WeakMap();
_closed = new WeakMap();
function sqlToProto(owner, sql) {
  if (sql instanceof Sql) {
    return { sqlId: sql._getSqlId(owner) };
  } else {
    return { sql: "" + sql };
  }
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/queue.js
var _pushStack, _shiftStack;
var Queue = class {
  constructor() {
    __privateAdd(this, _pushStack);
    __privateAdd(this, _shiftStack);
    __privateSet(this, _pushStack, []);
    __privateSet(this, _shiftStack, []);
  }
  get length() {
    return __privateGet(this, _pushStack).length + __privateGet(this, _shiftStack).length;
  }
  push(elem) {
    __privateGet(this, _pushStack).push(elem);
  }
  shift() {
    if (__privateGet(this, _shiftStack).length === 0 && __privateGet(this, _pushStack).length > 0) {
      __privateSet(this, _shiftStack, __privateGet(this, _pushStack).reverse());
      __privateSet(this, _pushStack, []);
    }
    return __privateGet(this, _shiftStack).pop();
  }
  first() {
    return __privateGet(this, _shiftStack).length !== 0 ? __privateGet(this, _shiftStack)[__privateGet(this, _shiftStack).length - 1] : __privateGet(this, _pushStack)[0];
  }
};
_pushStack = new WeakMap();
_shiftStack = new WeakMap();

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/stmt.js
var Stmt = class {
  /** Initialize the statement with given SQL text. */
  constructor(sql) {
    /** The SQL statement text. */
    __publicField(this, "sql");
    /** @private */
    __publicField(this, "_args");
    /** @private */
    __publicField(this, "_namedArgs");
    this.sql = sql;
    this._args = [];
    this._namedArgs = /* @__PURE__ */ new Map();
  }
  /** Binds positional parameters from the given `values`. All previous positional bindings are cleared. */
  bindIndexes(values) {
    this._args.length = 0;
    for (const value2 of values) {
      this._args.push(valueToProto(value2));
    }
    return this;
  }
  /** Binds a parameter by a 1-based index. */
  bindIndex(index, value2) {
    if (index !== (index | 0) || index <= 0) {
      throw new RangeError("Index of a positional argument must be positive integer");
    }
    while (this._args.length < index) {
      this._args.push(null);
    }
    this._args[index - 1] = valueToProto(value2);
    return this;
  }
  /** Binds a parameter by name. */
  bindName(name2, value2) {
    this._namedArgs.set(name2, valueToProto(value2));
    return this;
  }
  /** Clears all bindings. */
  unbindAll() {
    this._args.length = 0;
    this._namedArgs.clear();
    return this;
  }
};
function stmtToProto(sqlOwner, stmt, wantRows) {
  let inSql;
  let args = [];
  let namedArgs = [];
  if (stmt instanceof Stmt) {
    inSql = stmt.sql;
    args = stmt._args;
    for (const [name2, value2] of stmt._namedArgs.entries()) {
      namedArgs.push({ name: name2, value: value2 });
    }
  } else if (Array.isArray(stmt)) {
    inSql = stmt[0];
    if (Array.isArray(stmt[1])) {
      args = stmt[1].map((arg) => valueToProto(arg));
    } else {
      namedArgs = Object.entries(stmt[1]).map(([name2, value2]) => {
        return { name: name2, value: valueToProto(value2) };
      });
    }
  } else {
    inSql = stmt;
  }
  const { sql, sqlId } = sqlToProto(sqlOwner, inSql);
  return { sql, sqlId, args, namedArgs, wantRows };
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/batch.js
var _useCursor, _executed;
var Batch = class {
  /** @private */
  constructor(stream, useCursor) {
    /** @private */
    __publicField(this, "_stream");
    __privateAdd(this, _useCursor);
    /** @private */
    __publicField(this, "_steps");
    __privateAdd(this, _executed);
    this._stream = stream;
    __privateSet(this, _useCursor, useCursor);
    this._steps = [];
    __privateSet(this, _executed, false);
  }
  /** Return a builder for adding a step to the batch. */
  step() {
    return new BatchStep(this);
  }
  /** Execute the batch. */
  execute() {
    if (__privateGet(this, _executed)) {
      throw new MisuseError("This batch has already been executed");
    }
    __privateSet(this, _executed, true);
    const batch = {
      steps: this._steps.map((step) => step.proto)
    };
    if (__privateGet(this, _useCursor)) {
      return executeCursor(this._stream, this._steps, batch);
    } else {
      return executeRegular(this._stream, this._steps, batch);
    }
  }
};
_useCursor = new WeakMap();
_executed = new WeakMap();
function executeRegular(stream, steps, batch) {
  return stream._batch(batch).then((result) => {
    for (let step = 0; step < steps.length; ++step) {
      const stepResult = result.stepResults.get(step);
      const stepError = result.stepErrors.get(step);
      steps[step].callback(stepResult, stepError);
    }
  });
}
async function executeCursor(stream, steps, batch) {
  const cursor = await stream._openCursor(batch);
  try {
    let nextStep = 0;
    let beginEntry = void 0;
    let rows = [];
    for (; ; ) {
      const entry = await cursor.next();
      if (entry === void 0) {
        break;
      }
      if (entry.type === "step_begin") {
        if (entry.step < nextStep || entry.step >= steps.length) {
          throw new ProtoError("Server produced StepBeginEntry for unexpected step");
        } else if (beginEntry !== void 0) {
          throw new ProtoError("Server produced StepBeginEntry before terminating previous step");
        }
        for (let step = nextStep; step < entry.step; ++step) {
          steps[step].callback(void 0, void 0);
        }
        nextStep = entry.step + 1;
        beginEntry = entry;
        rows = [];
      } else if (entry.type === "step_end") {
        if (beginEntry === void 0) {
          throw new ProtoError("Server produced StepEndEntry but no step is active");
        }
        const stmtResult = {
          cols: beginEntry.cols,
          rows,
          affectedRowCount: entry.affectedRowCount,
          lastInsertRowid: entry.lastInsertRowid
        };
        steps[beginEntry.step].callback(stmtResult, void 0);
        beginEntry = void 0;
        rows = [];
      } else if (entry.type === "step_error") {
        if (beginEntry === void 0) {
          if (entry.step >= steps.length) {
            throw new ProtoError("Server produced StepErrorEntry for unexpected step");
          }
          for (let step = nextStep; step < entry.step; ++step) {
            steps[step].callback(void 0, void 0);
          }
        } else {
          if (entry.step !== beginEntry.step) {
            throw new ProtoError("Server produced StepErrorEntry for unexpected step");
          }
          beginEntry = void 0;
          rows = [];
        }
        steps[entry.step].callback(void 0, entry.error);
        nextStep = entry.step + 1;
      } else if (entry.type === "row") {
        if (beginEntry === void 0) {
          throw new ProtoError("Server produced RowEntry but no step is active");
        }
        rows.push(entry.row);
      } else if (entry.type === "error") {
        throw errorFromProto(entry.error);
      } else if (entry.type === "none") {
        throw new ProtoError("Server produced unrecognized CursorEntry");
      } else {
        throw impossible(entry, "Impossible CursorEntry");
      }
    }
    if (beginEntry !== void 0) {
      throw new ProtoError("Server closed Cursor before terminating active step");
    }
    for (let step = nextStep; step < steps.length; ++step) {
      steps[step].callback(void 0, void 0);
    }
  } finally {
    cursor.close();
  }
}
var _conds, _BatchStep_instances, add_fn;
var BatchStep = class {
  /** @private */
  constructor(batch) {
    __privateAdd(this, _BatchStep_instances);
    /** @private */
    __publicField(this, "_batch");
    __privateAdd(this, _conds);
    /** @private */
    __publicField(this, "_index");
    this._batch = batch;
    __privateSet(this, _conds, []);
    this._index = void 0;
  }
  /** Add the condition that needs to be satisfied to execute the statement. If you use this method multiple
   * times, we join the conditions with a logical AND. */
  condition(cond) {
    __privateGet(this, _conds).push(cond._proto);
    return this;
  }
  /** Add a statement that returns rows. */
  query(stmt) {
    return __privateMethod(this, _BatchStep_instances, add_fn).call(this, stmt, true, rowsResultFromProto);
  }
  /** Add a statement that returns at most a single row. */
  queryRow(stmt) {
    return __privateMethod(this, _BatchStep_instances, add_fn).call(this, stmt, true, rowResultFromProto);
  }
  /** Add a statement that returns at most a single value. */
  queryValue(stmt) {
    return __privateMethod(this, _BatchStep_instances, add_fn).call(this, stmt, true, valueResultFromProto);
  }
  /** Add a statement without returning rows. */
  run(stmt) {
    return __privateMethod(this, _BatchStep_instances, add_fn).call(this, stmt, false, stmtResultFromProto);
  }
};
_conds = new WeakMap();
_BatchStep_instances = new WeakSet();
add_fn = function(inStmt, wantRows, fromProto) {
  if (this._index !== void 0) {
    throw new MisuseError("This BatchStep has already been added to the batch");
  }
  const stmt = stmtToProto(this._batch._stream._sqlOwner(), inStmt, wantRows);
  let condition;
  if (__privateGet(this, _conds).length === 0) {
    condition = void 0;
  } else if (__privateGet(this, _conds).length === 1) {
    condition = __privateGet(this, _conds)[0];
  } else {
    condition = { type: "and", conds: __privateGet(this, _conds).slice() };
  }
  const proto = { stmt, condition };
  return new Promise((outputCallback, errorCallback) => {
    const callback = (stepResult, stepError) => {
      if (stepResult !== void 0 && stepError !== void 0) {
        errorCallback(new ProtoError("Server returned both result and error"));
      } else if (stepError !== void 0) {
        errorCallback(errorFromProto(stepError));
      } else if (stepResult !== void 0) {
        outputCallback(fromProto(stepResult, this._batch._stream.intMode));
      } else {
        outputCallback(void 0);
      }
    };
    this._index = this._batch._steps.length;
    this._batch._steps.push({ proto, callback });
  });
};
var BatchCond = class _BatchCond {
  /** @private */
  constructor(batch, proto) {
    /** @private */
    __publicField(this, "_batch");
    /** @private */
    __publicField(this, "_proto");
    this._batch = batch;
    this._proto = proto;
  }
  /** Create a condition that evaluates to true when the given step executes successfully.
   *
   * If the given step fails error or is skipped because its condition evaluated to false, this
   * condition evaluates to false.
   */
  static ok(step) {
    return new _BatchCond(step._batch, { type: "ok", step: stepIndex(step) });
  }
  /** Create a condition that evaluates to true when the given step fails.
   *
   * If the given step succeeds or is skipped because its condition evaluated to false, this condition
   * evaluates to false.
   */
  static error(step) {
    return new _BatchCond(step._batch, { type: "error", step: stepIndex(step) });
  }
  /** Create a condition that is a logical negation of another condition.
   */
  static not(cond) {
    return new _BatchCond(cond._batch, { type: "not", cond: cond._proto });
  }
  /** Create a condition that is a logical AND of other conditions.
   */
  static and(batch, conds) {
    for (const cond of conds) {
      checkCondBatch(batch, cond);
    }
    return new _BatchCond(batch, { type: "and", conds: conds.map((e) => e._proto) });
  }
  /** Create a condition that is a logical OR of other conditions.
   */
  static or(batch, conds) {
    for (const cond of conds) {
      checkCondBatch(batch, cond);
    }
    return new _BatchCond(batch, { type: "or", conds: conds.map((e) => e._proto) });
  }
  /** Create a condition that evaluates to true when the SQL connection is in autocommit mode (not inside an
   * explicit transaction). This requires protocol version 3 or higher.
   */
  static isAutocommit(batch) {
    batch._stream.client()._ensureVersion(3, "BatchCond.isAutocommit()");
    return new _BatchCond(batch, { type: "is_autocommit" });
  }
};
function stepIndex(step) {
  if (step._index === void 0) {
    throw new MisuseError("Cannot add a condition referencing a step that has not been added to the batch");
  }
  return step._index;
}
function checkCondBatch(expectedBatch, cond) {
  if (cond._batch !== expectedBatch) {
    throw new MisuseError("Cannot mix BatchCond objects for different Batch objects");
  }
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/describe.js
function describeResultFromProto(result) {
  return {
    paramNames: result.params.map((p) => p.name),
    columns: result.cols,
    isExplain: result.isExplain,
    isReadonly: result.isReadonly
  };
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/stream.js
var _Stream_instances, execute_fn;
var Stream = class {
  /** @private */
  constructor(intMode) {
    __privateAdd(this, _Stream_instances);
    /** Representation of integers returned from the database. See {@link IntMode}.
     *
     * This value affects the results of all operations on this stream.
     */
    __publicField(this, "intMode");
    this.intMode = intMode;
  }
  /** Execute a statement and return rows. */
  query(stmt) {
    return __privateMethod(this, _Stream_instances, execute_fn).call(this, stmt, true, rowsResultFromProto);
  }
  /** Execute a statement and return at most a single row. */
  queryRow(stmt) {
    return __privateMethod(this, _Stream_instances, execute_fn).call(this, stmt, true, rowResultFromProto);
  }
  /** Execute a statement and return at most a single value. */
  queryValue(stmt) {
    return __privateMethod(this, _Stream_instances, execute_fn).call(this, stmt, true, valueResultFromProto);
  }
  /** Execute a statement without returning rows. */
  run(stmt) {
    return __privateMethod(this, _Stream_instances, execute_fn).call(this, stmt, false, stmtResultFromProto);
  }
  /** Return a builder for creating and executing a batch.
   *
   * If `useCursor` is true, the batch will be executed using a Hrana cursor, which will stream results from
   * the server to the client, which consumes less memory on the server. This requires protocol version 3 or
   * higher.
   */
  batch(useCursor = false) {
    return new Batch(this, useCursor);
  }
  /** Parse and analyze a statement. This requires protocol version 2 or higher. */
  describe(inSql) {
    const protoSql = sqlToProto(this._sqlOwner(), inSql);
    return this._describe(protoSql).then(describeResultFromProto);
  }
  /** Execute a sequence of statements separated by semicolons. This requires protocol version 2 or higher.
   * */
  sequence(inSql) {
    const protoSql = sqlToProto(this._sqlOwner(), inSql);
    return this._sequence(protoSql);
  }
};
_Stream_instances = new WeakSet();
execute_fn = function(inStmt, wantRows, fromProto) {
  const stmt = stmtToProto(this._sqlOwner(), inStmt, wantRows);
  return this._execute(stmt).then((r) => fromProto(r, this.intMode));
};

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/cursor.js
var Cursor = class {
};

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/ws/cursor.js
var fetchChunkSize = 1e3;
var fetchQueueSize = 10;
var _client, _stream, _cursorId, _entryQueue, _fetchQueue, _closed2, _done, _WsCursor_instances, fetch_fn;
var WsCursor = class extends Cursor {
  /** @private */
  constructor(client, stream, cursorId) {
    super();
    __privateAdd(this, _WsCursor_instances);
    __privateAdd(this, _client);
    __privateAdd(this, _stream);
    __privateAdd(this, _cursorId);
    __privateAdd(this, _entryQueue);
    __privateAdd(this, _fetchQueue);
    __privateAdd(this, _closed2);
    __privateAdd(this, _done);
    __privateSet(this, _client, client);
    __privateSet(this, _stream, stream);
    __privateSet(this, _cursorId, cursorId);
    __privateSet(this, _entryQueue, new Queue());
    __privateSet(this, _fetchQueue, new Queue());
    __privateSet(this, _closed2, void 0);
    __privateSet(this, _done, false);
  }
  /** Fetch the next entry from the cursor. */
  async next() {
    for (; ; ) {
      if (__privateGet(this, _closed2) !== void 0) {
        throw new ClosedError("Cursor is closed", __privateGet(this, _closed2));
      }
      while (!__privateGet(this, _done) && __privateGet(this, _fetchQueue).length < fetchQueueSize) {
        __privateGet(this, _fetchQueue).push(__privateMethod(this, _WsCursor_instances, fetch_fn).call(this));
      }
      const entry = __privateGet(this, _entryQueue).shift();
      if (__privateGet(this, _done) || entry !== void 0) {
        return entry;
      }
      await __privateGet(this, _fetchQueue).shift().then((response) => {
        if (response === void 0) {
          return;
        }
        for (const entry2 of response.entries) {
          __privateGet(this, _entryQueue).push(entry2);
        }
        __privateGet(this, _done) || __privateSet(this, _done, response.done);
      });
    }
  }
  /** @private */
  _setClosed(error) {
    if (__privateGet(this, _closed2) !== void 0) {
      return;
    }
    __privateSet(this, _closed2, error);
    __privateGet(this, _stream)._sendCursorRequest(this, {
      type: "close_cursor",
      cursorId: __privateGet(this, _cursorId)
    }).catch(() => void 0);
    __privateGet(this, _stream)._cursorClosed(this);
  }
  /** Close the cursor. */
  close() {
    this._setClosed(new ClientError("Cursor was manually closed"));
  }
  /** True if the cursor is closed. */
  get closed() {
    return __privateGet(this, _closed2) !== void 0;
  }
};
_client = new WeakMap();
_stream = new WeakMap();
_cursorId = new WeakMap();
_entryQueue = new WeakMap();
_fetchQueue = new WeakMap();
_closed2 = new WeakMap();
_done = new WeakMap();
_WsCursor_instances = new WeakSet();
fetch_fn = function() {
  return __privateGet(this, _stream)._sendCursorRequest(this, {
    type: "fetch_cursor",
    cursorId: __privateGet(this, _cursorId),
    maxCount: fetchChunkSize
  }).then((resp) => resp, (error) => {
    this._setClosed(error);
    return void 0;
  });
};

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/ws/stream.js
var _client2, _streamId, _queue, _cursor, _closing, _closed3, _WsStream_instances, sendStreamRequest_fn, pushToQueue_fn, flushQueue_fn, setClosed_fn;
var _WsStream = class _WsStream extends Stream {
  /** @private */
  constructor(client, streamId) {
    super(client.intMode);
    __privateAdd(this, _WsStream_instances);
    __privateAdd(this, _client2);
    __privateAdd(this, _streamId);
    __privateAdd(this, _queue);
    __privateAdd(this, _cursor);
    __privateAdd(this, _closing);
    __privateAdd(this, _closed3);
    __privateSet(this, _client2, client);
    __privateSet(this, _streamId, streamId);
    __privateSet(this, _queue, new Queue());
    __privateSet(this, _cursor, void 0);
    __privateSet(this, _closing, false);
    __privateSet(this, _closed3, void 0);
  }
  /** @private */
  static open(client) {
    const streamId = client._streamIdAlloc.alloc();
    const stream = new _WsStream(client, streamId);
    const responseCallback = () => void 0;
    const errorCallback = (e) => {
      var _a;
      return __privateMethod(_a = stream, _WsStream_instances, setClosed_fn).call(_a, e);
    };
    const request = { type: "open_stream", streamId };
    client._sendRequest(request, { responseCallback, errorCallback });
    return stream;
  }
  /** Get the {@link WsClient} object that this stream belongs to. */
  client() {
    return __privateGet(this, _client2);
  }
  /** @private */
  _sqlOwner() {
    return __privateGet(this, _client2);
  }
  /** @private */
  _execute(stmt) {
    return __privateMethod(this, _WsStream_instances, sendStreamRequest_fn).call(this, {
      type: "execute",
      streamId: __privateGet(this, _streamId),
      stmt
    }).then((response) => {
      return response.result;
    });
  }
  /** @private */
  _batch(batch) {
    return __privateMethod(this, _WsStream_instances, sendStreamRequest_fn).call(this, {
      type: "batch",
      streamId: __privateGet(this, _streamId),
      batch
    }).then((response) => {
      return response.result;
    });
  }
  /** @private */
  _describe(protoSql) {
    __privateGet(this, _client2)._ensureVersion(2, "describe()");
    return __privateMethod(this, _WsStream_instances, sendStreamRequest_fn).call(this, {
      type: "describe",
      streamId: __privateGet(this, _streamId),
      sql: protoSql.sql,
      sqlId: protoSql.sqlId
    }).then((response) => {
      return response.result;
    });
  }
  /** @private */
  _sequence(protoSql) {
    __privateGet(this, _client2)._ensureVersion(2, "sequence()");
    return __privateMethod(this, _WsStream_instances, sendStreamRequest_fn).call(this, {
      type: "sequence",
      streamId: __privateGet(this, _streamId),
      sql: protoSql.sql,
      sqlId: protoSql.sqlId
    }).then((_response) => {
      return void 0;
    });
  }
  /** Check whether the SQL connection underlying this stream is in autocommit state (i.e., outside of an
   * explicit transaction). This requires protocol version 3 or higher.
   */
  getAutocommit() {
    __privateGet(this, _client2)._ensureVersion(3, "getAutocommit()");
    return __privateMethod(this, _WsStream_instances, sendStreamRequest_fn).call(this, {
      type: "get_autocommit",
      streamId: __privateGet(this, _streamId)
    }).then((response) => {
      return response.isAutocommit;
    });
  }
  /** @private */
  _openCursor(batch) {
    __privateGet(this, _client2)._ensureVersion(3, "cursor");
    return new Promise((cursorCallback, errorCallback) => {
      __privateMethod(this, _WsStream_instances, pushToQueue_fn).call(this, { type: "cursor", batch, cursorCallback, errorCallback });
    });
  }
  /** @private */
  _sendCursorRequest(cursor, request) {
    if (cursor !== __privateGet(this, _cursor)) {
      throw new InternalError("Cursor not associated with the stream attempted to execute a request");
    }
    return new Promise((responseCallback, errorCallback) => {
      if (__privateGet(this, _closed3) !== void 0) {
        errorCallback(new ClosedError("Stream is closed", __privateGet(this, _closed3)));
      } else {
        __privateGet(this, _client2)._sendRequest(request, { responseCallback, errorCallback });
      }
    });
  }
  /** @private */
  _cursorClosed(cursor) {
    if (cursor !== __privateGet(this, _cursor)) {
      throw new InternalError("Cursor was closed, but it was not associated with the stream");
    }
    __privateSet(this, _cursor, void 0);
    __privateMethod(this, _WsStream_instances, flushQueue_fn).call(this);
  }
  /** Immediately close the stream. */
  close() {
    __privateMethod(this, _WsStream_instances, setClosed_fn).call(this, new ClientError("Stream was manually closed"));
  }
  /** Gracefully close the stream. */
  closeGracefully() {
    __privateSet(this, _closing, true);
    __privateMethod(this, _WsStream_instances, flushQueue_fn).call(this);
  }
  /** True if the stream is closed or closing. */
  get closed() {
    return __privateGet(this, _closed3) !== void 0 || __privateGet(this, _closing);
  }
};
_client2 = new WeakMap();
_streamId = new WeakMap();
_queue = new WeakMap();
_cursor = new WeakMap();
_closing = new WeakMap();
_closed3 = new WeakMap();
_WsStream_instances = new WeakSet();
sendStreamRequest_fn = function(request) {
  return new Promise((responseCallback, errorCallback) => {
    __privateMethod(this, _WsStream_instances, pushToQueue_fn).call(this, { type: "request", request, responseCallback, errorCallback });
  });
};
pushToQueue_fn = function(entry) {
  if (__privateGet(this, _closed3) !== void 0) {
    entry.errorCallback(new ClosedError("Stream is closed", __privateGet(this, _closed3)));
  } else if (__privateGet(this, _closing)) {
    entry.errorCallback(new ClosedError("Stream is closing", void 0));
  } else {
    __privateGet(this, _queue).push(entry);
    __privateMethod(this, _WsStream_instances, flushQueue_fn).call(this);
  }
};
flushQueue_fn = function() {
  for (; ; ) {
    const entry = __privateGet(this, _queue).first();
    if (entry === void 0 && __privateGet(this, _cursor) === void 0 && __privateGet(this, _closing)) {
      __privateMethod(this, _WsStream_instances, setClosed_fn).call(this, new ClientError("Stream was gracefully closed"));
      break;
    } else if (entry?.type === "request" && __privateGet(this, _cursor) === void 0) {
      const { request, responseCallback, errorCallback } = entry;
      __privateGet(this, _queue).shift();
      __privateGet(this, _client2)._sendRequest(request, { responseCallback, errorCallback });
    } else if (entry?.type === "cursor" && __privateGet(this, _cursor) === void 0) {
      const { batch, cursorCallback } = entry;
      __privateGet(this, _queue).shift();
      const cursorId = __privateGet(this, _client2)._cursorIdAlloc.alloc();
      const cursor = new WsCursor(__privateGet(this, _client2), this, cursorId);
      const request = {
        type: "open_cursor",
        streamId: __privateGet(this, _streamId),
        cursorId,
        batch
      };
      const responseCallback = () => void 0;
      const errorCallback = (e) => cursor._setClosed(e);
      __privateGet(this, _client2)._sendRequest(request, { responseCallback, errorCallback });
      __privateSet(this, _cursor, cursor);
      cursorCallback(cursor);
    } else {
      break;
    }
  }
};
setClosed_fn = function(error) {
  if (__privateGet(this, _closed3) !== void 0) {
    return;
  }
  __privateSet(this, _closed3, error);
  if (__privateGet(this, _cursor) !== void 0) {
    __privateGet(this, _cursor)._setClosed(error);
  }
  for (; ; ) {
    const entry = __privateGet(this, _queue).shift();
    if (entry !== void 0) {
      entry.errorCallback(error);
    } else {
      break;
    }
  }
  const request = { type: "close_stream", streamId: __privateGet(this, _streamId) };
  const responseCallback = () => __privateGet(this, _client2)._streamIdAlloc.free(__privateGet(this, _streamId));
  const errorCallback = () => void 0;
  __privateGet(this, _client2)._sendRequest(request, { responseCallback, errorCallback });
};
var WsStream = _WsStream;

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/shared/json_encode.js
function Stmt2(w, msg) {
  if (msg.sql !== void 0) {
    w.string("sql", msg.sql);
  }
  if (msg.sqlId !== void 0) {
    w.number("sql_id", msg.sqlId);
  }
  w.arrayObjects("args", msg.args, Value);
  w.arrayObjects("named_args", msg.namedArgs, NamedArg);
  w.boolean("want_rows", msg.wantRows);
}
function NamedArg(w, msg) {
  w.string("name", msg.name);
  w.object("value", msg.value, Value);
}
function Batch2(w, msg) {
  w.arrayObjects("steps", msg.steps, BatchStep2);
}
function BatchStep2(w, msg) {
  if (msg.condition !== void 0) {
    w.object("condition", msg.condition, BatchCond2);
  }
  w.object("stmt", msg.stmt, Stmt2);
}
function BatchCond2(w, msg) {
  w.stringRaw("type", msg.type);
  if (msg.type === "ok" || msg.type === "error") {
    w.number("step", msg.step);
  } else if (msg.type === "not") {
    w.object("cond", msg.cond, BatchCond2);
  } else if (msg.type === "and" || msg.type === "or") {
    w.arrayObjects("conds", msg.conds, BatchCond2);
  } else if (msg.type === "is_autocommit") {
  } else {
    throw impossible(msg, "Impossible type of BatchCond");
  }
}
function Value(w, msg) {
  if (msg === null) {
    w.stringRaw("type", "null");
  } else if (typeof msg === "bigint") {
    w.stringRaw("type", "integer");
    w.stringRaw("value", "" + msg);
  } else if (typeof msg === "number") {
    w.stringRaw("type", "float");
    w.number("value", msg);
  } else if (typeof msg === "string") {
    w.stringRaw("type", "text");
    w.string("value", msg);
  } else if (msg instanceof Uint8Array) {
    w.stringRaw("type", "blob");
    w.stringRaw("base64", gBase64.fromUint8Array(msg));
  } else if (msg === void 0) {
  } else {
    throw impossible(msg, "Impossible type of Value");
  }
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/ws/json_encode.js
function ClientMsg(w, msg) {
  w.stringRaw("type", msg.type);
  if (msg.type === "hello") {
    if (msg.jwt !== void 0) {
      w.string("jwt", msg.jwt);
    }
  } else if (msg.type === "request") {
    w.number("request_id", msg.requestId);
    w.object("request", msg.request, Request2);
  } else {
    throw impossible(msg, "Impossible type of ClientMsg");
  }
}
function Request2(w, msg) {
  w.stringRaw("type", msg.type);
  if (msg.type === "open_stream") {
    w.number("stream_id", msg.streamId);
  } else if (msg.type === "close_stream") {
    w.number("stream_id", msg.streamId);
  } else if (msg.type === "execute") {
    w.number("stream_id", msg.streamId);
    w.object("stmt", msg.stmt, Stmt2);
  } else if (msg.type === "batch") {
    w.number("stream_id", msg.streamId);
    w.object("batch", msg.batch, Batch2);
  } else if (msg.type === "open_cursor") {
    w.number("stream_id", msg.streamId);
    w.number("cursor_id", msg.cursorId);
    w.object("batch", msg.batch, Batch2);
  } else if (msg.type === "close_cursor") {
    w.number("cursor_id", msg.cursorId);
  } else if (msg.type === "fetch_cursor") {
    w.number("cursor_id", msg.cursorId);
    w.number("max_count", msg.maxCount);
  } else if (msg.type === "sequence") {
    w.number("stream_id", msg.streamId);
    if (msg.sql !== void 0) {
      w.string("sql", msg.sql);
    }
    if (msg.sqlId !== void 0) {
      w.number("sql_id", msg.sqlId);
    }
  } else if (msg.type === "describe") {
    w.number("stream_id", msg.streamId);
    if (msg.sql !== void 0) {
      w.string("sql", msg.sql);
    }
    if (msg.sqlId !== void 0) {
      w.number("sql_id", msg.sqlId);
    }
  } else if (msg.type === "store_sql") {
    w.number("sql_id", msg.sqlId);
    w.string("sql", msg.sql);
  } else if (msg.type === "close_sql") {
    w.number("sql_id", msg.sqlId);
  } else if (msg.type === "get_autocommit") {
    w.number("stream_id", msg.streamId);
  } else {
    throw impossible(msg, "Impossible type of Request");
  }
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/shared/protobuf_encode.js
function Stmt3(w, msg) {
  if (msg.sql !== void 0) {
    w.string(1, msg.sql);
  }
  if (msg.sqlId !== void 0) {
    w.int32(2, msg.sqlId);
  }
  for (const arg of msg.args) {
    w.message(3, arg, Value2);
  }
  for (const arg of msg.namedArgs) {
    w.message(4, arg, NamedArg2);
  }
  w.bool(5, msg.wantRows);
}
function NamedArg2(w, msg) {
  w.string(1, msg.name);
  w.message(2, msg.value, Value2);
}
function Batch3(w, msg) {
  for (const step of msg.steps) {
    w.message(1, step, BatchStep3);
  }
}
function BatchStep3(w, msg) {
  if (msg.condition !== void 0) {
    w.message(1, msg.condition, BatchCond3);
  }
  w.message(2, msg.stmt, Stmt3);
}
function BatchCond3(w, msg) {
  if (msg.type === "ok") {
    w.uint32(1, msg.step);
  } else if (msg.type === "error") {
    w.uint32(2, msg.step);
  } else if (msg.type === "not") {
    w.message(3, msg.cond, BatchCond3);
  } else if (msg.type === "and") {
    w.message(4, msg.conds, BatchCondList);
  } else if (msg.type === "or") {
    w.message(5, msg.conds, BatchCondList);
  } else if (msg.type === "is_autocommit") {
    w.message(6, void 0, Empty);
  } else {
    throw impossible(msg, "Impossible type of BatchCond");
  }
}
function BatchCondList(w, msg) {
  for (const cond of msg) {
    w.message(1, cond, BatchCond3);
  }
}
function Value2(w, msg) {
  if (msg === null) {
    w.message(1, void 0, Empty);
  } else if (typeof msg === "bigint") {
    w.sint64(2, msg);
  } else if (typeof msg === "number") {
    w.double(3, msg);
  } else if (typeof msg === "string") {
    w.string(4, msg);
  } else if (msg instanceof Uint8Array) {
    w.bytes(5, msg);
  } else if (msg === void 0) {
  } else {
    throw impossible(msg, "Impossible type of Value");
  }
}
function Empty(_w, _msg) {
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/ws/protobuf_encode.js
function ClientMsg2(w, msg) {
  if (msg.type === "hello") {
    w.message(1, msg, HelloMsg);
  } else if (msg.type === "request") {
    w.message(2, msg, RequestMsg);
  } else {
    throw impossible(msg, "Impossible type of ClientMsg");
  }
}
function HelloMsg(w, msg) {
  if (msg.jwt !== void 0) {
    w.string(1, msg.jwt);
  }
}
function RequestMsg(w, msg) {
  w.int32(1, msg.requestId);
  const request = msg.request;
  if (request.type === "open_stream") {
    w.message(2, request, OpenStreamReq);
  } else if (request.type === "close_stream") {
    w.message(3, request, CloseStreamReq);
  } else if (request.type === "execute") {
    w.message(4, request, ExecuteReq);
  } else if (request.type === "batch") {
    w.message(5, request, BatchReq);
  } else if (request.type === "open_cursor") {
    w.message(6, request, OpenCursorReq);
  } else if (request.type === "close_cursor") {
    w.message(7, request, CloseCursorReq);
  } else if (request.type === "fetch_cursor") {
    w.message(8, request, FetchCursorReq);
  } else if (request.type === "sequence") {
    w.message(9, request, SequenceReq);
  } else if (request.type === "describe") {
    w.message(10, request, DescribeReq);
  } else if (request.type === "store_sql") {
    w.message(11, request, StoreSqlReq);
  } else if (request.type === "close_sql") {
    w.message(12, request, CloseSqlReq);
  } else if (request.type === "get_autocommit") {
    w.message(13, request, GetAutocommitReq);
  } else {
    throw impossible(request, "Impossible type of Request");
  }
}
function OpenStreamReq(w, msg) {
  w.int32(1, msg.streamId);
}
function CloseStreamReq(w, msg) {
  w.int32(1, msg.streamId);
}
function ExecuteReq(w, msg) {
  w.int32(1, msg.streamId);
  w.message(2, msg.stmt, Stmt3);
}
function BatchReq(w, msg) {
  w.int32(1, msg.streamId);
  w.message(2, msg.batch, Batch3);
}
function OpenCursorReq(w, msg) {
  w.int32(1, msg.streamId);
  w.int32(2, msg.cursorId);
  w.message(3, msg.batch, Batch3);
}
function CloseCursorReq(w, msg) {
  w.int32(1, msg.cursorId);
}
function FetchCursorReq(w, msg) {
  w.int32(1, msg.cursorId);
  w.uint32(2, msg.maxCount);
}
function SequenceReq(w, msg) {
  w.int32(1, msg.streamId);
  if (msg.sql !== void 0) {
    w.string(2, msg.sql);
  }
  if (msg.sqlId !== void 0) {
    w.int32(3, msg.sqlId);
  }
}
function DescribeReq(w, msg) {
  w.int32(1, msg.streamId);
  if (msg.sql !== void 0) {
    w.string(2, msg.sql);
  }
  if (msg.sqlId !== void 0) {
    w.int32(3, msg.sqlId);
  }
}
function StoreSqlReq(w, msg) {
  w.int32(1, msg.sqlId);
  w.string(2, msg.sql);
}
function CloseSqlReq(w, msg) {
  w.int32(1, msg.sqlId);
}
function GetAutocommitReq(w, msg) {
  w.int32(1, msg.streamId);
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/shared/json_decode.js
function Error2(obj) {
  const message = string2(obj["message"]);
  const code = stringOpt(obj["code"]);
  return { message, code };
}
function StmtResult(obj) {
  const cols = arrayObjectsMap(obj["cols"], Col);
  const rows = array(obj["rows"]).map((rowObj) => arrayObjectsMap(rowObj, Value3));
  const affectedRowCount = number(obj["affected_row_count"]);
  const lastInsertRowidStr = stringOpt(obj["last_insert_rowid"]);
  const lastInsertRowid = lastInsertRowidStr !== void 0 ? BigInt(lastInsertRowidStr) : void 0;
  return { cols, rows, affectedRowCount, lastInsertRowid };
}
function Col(obj) {
  const name2 = stringOpt(obj["name"]);
  const decltype = stringOpt(obj["decltype"]);
  return { name: name2, decltype };
}
function BatchResult(obj) {
  const stepResults = /* @__PURE__ */ new Map();
  array(obj["step_results"]).forEach((value2, i) => {
    if (value2 !== null) {
      stepResults.set(i, StmtResult(object(value2)));
    }
  });
  const stepErrors = /* @__PURE__ */ new Map();
  array(obj["step_errors"]).forEach((value2, i) => {
    if (value2 !== null) {
      stepErrors.set(i, Error2(object(value2)));
    }
  });
  return { stepResults, stepErrors };
}
function CursorEntry(obj) {
  const type = string2(obj["type"]);
  if (type === "step_begin") {
    const step = number(obj["step"]);
    const cols = arrayObjectsMap(obj["cols"], Col);
    return { type: "step_begin", step, cols };
  } else if (type === "step_end") {
    const affectedRowCount = number(obj["affected_row_count"]);
    const lastInsertRowidStr = stringOpt(obj["last_insert_rowid"]);
    const lastInsertRowid = lastInsertRowidStr !== void 0 ? BigInt(lastInsertRowidStr) : void 0;
    return { type: "step_end", affectedRowCount, lastInsertRowid };
  } else if (type === "step_error") {
    const step = number(obj["step"]);
    const error = Error2(object(obj["error"]));
    return { type: "step_error", step, error };
  } else if (type === "row") {
    const row = arrayObjectsMap(obj["row"], Value3);
    return { type: "row", row };
  } else if (type === "error") {
    const error = Error2(object(obj["error"]));
    return { type: "error", error };
  } else {
    throw new ProtoError("Unexpected type of CursorEntry");
  }
}
function DescribeResult(obj) {
  const params = arrayObjectsMap(obj["params"], DescribeParam);
  const cols = arrayObjectsMap(obj["cols"], DescribeCol);
  const isExplain = boolean(obj["is_explain"]);
  const isReadonly = boolean(obj["is_readonly"]);
  return { params, cols, isExplain, isReadonly };
}
function DescribeParam(obj) {
  const name2 = stringOpt(obj["name"]);
  return { name: name2 };
}
function DescribeCol(obj) {
  const name2 = string2(obj["name"]);
  const decltype = stringOpt(obj["decltype"]);
  return { name: name2, decltype };
}
function Value3(obj) {
  const type = string2(obj["type"]);
  if (type === "null") {
    return null;
  } else if (type === "integer") {
    const value2 = string2(obj["value"]);
    return BigInt(value2);
  } else if (type === "float") {
    return number(obj["value"]);
  } else if (type === "text") {
    return string2(obj["value"]);
  } else if (type === "blob") {
    return gBase64.toUint8Array(string2(obj["base64"]));
  } else {
    throw new ProtoError("Unexpected type of Value");
  }
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/ws/json_decode.js
function ServerMsg(obj) {
  const type = string2(obj["type"]);
  if (type === "hello_ok") {
    return { type: "hello_ok" };
  } else if (type === "hello_error") {
    const error = Error2(object(obj["error"]));
    return { type: "hello_error", error };
  } else if (type === "response_ok") {
    const requestId = number(obj["request_id"]);
    const response = Response2(object(obj["response"]));
    return { type: "response_ok", requestId, response };
  } else if (type === "response_error") {
    const requestId = number(obj["request_id"]);
    const error = Error2(object(obj["error"]));
    return { type: "response_error", requestId, error };
  } else {
    throw new ProtoError("Unexpected type of ServerMsg");
  }
}
function Response2(obj) {
  const type = string2(obj["type"]);
  if (type === "open_stream") {
    return { type: "open_stream" };
  } else if (type === "close_stream") {
    return { type: "close_stream" };
  } else if (type === "execute") {
    const result = StmtResult(object(obj["result"]));
    return { type: "execute", result };
  } else if (type === "batch") {
    const result = BatchResult(object(obj["result"]));
    return { type: "batch", result };
  } else if (type === "open_cursor") {
    return { type: "open_cursor" };
  } else if (type === "close_cursor") {
    return { type: "close_cursor" };
  } else if (type === "fetch_cursor") {
    const entries = arrayObjectsMap(obj["entries"], CursorEntry);
    const done = boolean(obj["done"]);
    return { type: "fetch_cursor", entries, done };
  } else if (type === "sequence") {
    return { type: "sequence" };
  } else if (type === "describe") {
    const result = DescribeResult(object(obj["result"]));
    return { type: "describe", result };
  } else if (type === "store_sql") {
    return { type: "store_sql" };
  } else if (type === "close_sql") {
    return { type: "close_sql" };
  } else if (type === "get_autocommit") {
    const isAutocommit = boolean(obj["is_autocommit"]);
    return { type: "get_autocommit", isAutocommit };
  } else {
    throw new ProtoError("Unexpected type of Response");
  }
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/shared/protobuf_decode.js
var Error3 = {
  default() {
    return { message: "", code: void 0 };
  },
  1(r, msg) {
    msg.message = r.string();
  },
  2(r, msg) {
    msg.code = r.string();
  }
};
var StmtResult2 = {
  default() {
    return {
      cols: [],
      rows: [],
      affectedRowCount: 0,
      lastInsertRowid: void 0
    };
  },
  1(r, msg) {
    msg.cols.push(r.message(Col2));
  },
  2(r, msg) {
    msg.rows.push(r.message(Row));
  },
  3(r, msg) {
    msg.affectedRowCount = Number(r.uint64());
  },
  4(r, msg) {
    msg.lastInsertRowid = r.sint64();
  }
};
var Col2 = {
  default() {
    return { name: void 0, decltype: void 0 };
  },
  1(r, msg) {
    msg.name = r.string();
  },
  2(r, msg) {
    msg.decltype = r.string();
  }
};
var Row = {
  default() {
    return [];
  },
  1(r, msg) {
    msg.push(r.message(Value4));
  }
};
var BatchResult2 = {
  default() {
    return { stepResults: /* @__PURE__ */ new Map(), stepErrors: /* @__PURE__ */ new Map() };
  },
  1(r, msg) {
    const [key, value2] = r.message(BatchResultStepResult);
    msg.stepResults.set(key, value2);
  },
  2(r, msg) {
    const [key, value2] = r.message(BatchResultStepError);
    msg.stepErrors.set(key, value2);
  }
};
var BatchResultStepResult = {
  default() {
    return [0, StmtResult2.default()];
  },
  1(r, msg) {
    msg[0] = r.uint32();
  },
  2(r, msg) {
    msg[1] = r.message(StmtResult2);
  }
};
var BatchResultStepError = {
  default() {
    return [0, Error3.default()];
  },
  1(r, msg) {
    msg[0] = r.uint32();
  },
  2(r, msg) {
    msg[1] = r.message(Error3);
  }
};
var CursorEntry2 = {
  default() {
    return { type: "none" };
  },
  1(r) {
    return r.message(StepBeginEntry);
  },
  2(r) {
    return r.message(StepEndEntry);
  },
  3(r) {
    return r.message(StepErrorEntry);
  },
  4(r) {
    return { type: "row", row: r.message(Row) };
  },
  5(r) {
    return { type: "error", error: r.message(Error3) };
  }
};
var StepBeginEntry = {
  default() {
    return { type: "step_begin", step: 0, cols: [] };
  },
  1(r, msg) {
    msg.step = r.uint32();
  },
  2(r, msg) {
    msg.cols.push(r.message(Col2));
  }
};
var StepEndEntry = {
  default() {
    return {
      type: "step_end",
      affectedRowCount: 0,
      lastInsertRowid: void 0
    };
  },
  1(r, msg) {
    msg.affectedRowCount = r.uint32();
  },
  2(r, msg) {
    msg.lastInsertRowid = r.uint64();
  }
};
var StepErrorEntry = {
  default() {
    return {
      type: "step_error",
      step: 0,
      error: Error3.default()
    };
  },
  1(r, msg) {
    msg.step = r.uint32();
  },
  2(r, msg) {
    msg.error = r.message(Error3);
  }
};
var DescribeResult2 = {
  default() {
    return {
      params: [],
      cols: [],
      isExplain: false,
      isReadonly: false
    };
  },
  1(r, msg) {
    msg.params.push(r.message(DescribeParam2));
  },
  2(r, msg) {
    msg.cols.push(r.message(DescribeCol2));
  },
  3(r, msg) {
    msg.isExplain = r.bool();
  },
  4(r, msg) {
    msg.isReadonly = r.bool();
  }
};
var DescribeParam2 = {
  default() {
    return { name: void 0 };
  },
  1(r, msg) {
    msg.name = r.string();
  }
};
var DescribeCol2 = {
  default() {
    return { name: "", decltype: void 0 };
  },
  1(r, msg) {
    msg.name = r.string();
  },
  2(r, msg) {
    msg.decltype = r.string();
  }
};
var Value4 = {
  default() {
    return void 0;
  },
  1(r) {
    return null;
  },
  2(r) {
    return r.sint64();
  },
  3(r) {
    return r.double();
  },
  4(r) {
    return r.string();
  },
  5(r) {
    return r.bytes();
  }
};

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/ws/protobuf_decode.js
var ServerMsg2 = {
  default() {
    return { type: "none" };
  },
  1(r) {
    return { type: "hello_ok" };
  },
  2(r) {
    return r.message(HelloErrorMsg);
  },
  3(r) {
    return r.message(ResponseOkMsg);
  },
  4(r) {
    return r.message(ResponseErrorMsg);
  }
};
var HelloErrorMsg = {
  default() {
    return { type: "hello_error", error: Error3.default() };
  },
  1(r, msg) {
    msg.error = r.message(Error3);
  }
};
var ResponseErrorMsg = {
  default() {
    return { type: "response_error", requestId: 0, error: Error3.default() };
  },
  1(r, msg) {
    msg.requestId = r.int32();
  },
  2(r, msg) {
    msg.error = r.message(Error3);
  }
};
var ResponseOkMsg = {
  default() {
    return {
      type: "response_ok",
      requestId: 0,
      response: { type: "none" }
    };
  },
  1(r, msg) {
    msg.requestId = r.int32();
  },
  2(r, msg) {
    msg.response = { type: "open_stream" };
  },
  3(r, msg) {
    msg.response = { type: "close_stream" };
  },
  4(r, msg) {
    msg.response = r.message(ExecuteResp);
  },
  5(r, msg) {
    msg.response = r.message(BatchResp);
  },
  6(r, msg) {
    msg.response = { type: "open_cursor" };
  },
  7(r, msg) {
    msg.response = { type: "close_cursor" };
  },
  8(r, msg) {
    msg.response = r.message(FetchCursorResp);
  },
  9(r, msg) {
    msg.response = { type: "sequence" };
  },
  10(r, msg) {
    msg.response = r.message(DescribeResp);
  },
  11(r, msg) {
    msg.response = { type: "store_sql" };
  },
  12(r, msg) {
    msg.response = { type: "close_sql" };
  },
  13(r, msg) {
    msg.response = r.message(GetAutocommitResp);
  }
};
var ExecuteResp = {
  default() {
    return { type: "execute", result: StmtResult2.default() };
  },
  1(r, msg) {
    msg.result = r.message(StmtResult2);
  }
};
var BatchResp = {
  default() {
    return { type: "batch", result: BatchResult2.default() };
  },
  1(r, msg) {
    msg.result = r.message(BatchResult2);
  }
};
var FetchCursorResp = {
  default() {
    return { type: "fetch_cursor", entries: [], done: false };
  },
  1(r, msg) {
    msg.entries.push(r.message(CursorEntry2));
  },
  2(r, msg) {
    msg.done = r.bool();
  }
};
var DescribeResp = {
  default() {
    return { type: "describe", result: DescribeResult2.default() };
  },
  1(r, msg) {
    msg.result = r.message(DescribeResult2);
  }
};
var GetAutocommitResp = {
  default() {
    return { type: "get_autocommit", isAutocommit: false };
  },
  1(r, msg) {
    msg.isAutocommit = r.bool();
  }
};

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/ws/client.js
var subprotocolsV2 = /* @__PURE__ */ new Map([
  ["hrana2", { version: 2, encoding: "json" }],
  ["hrana1", { version: 1, encoding: "json" }]
]);
var subprotocolsV3 = /* @__PURE__ */ new Map([
  ["hrana3-protobuf", { version: 3, encoding: "protobuf" }],
  ["hrana3", { version: 3, encoding: "json" }],
  ["hrana2", { version: 2, encoding: "json" }],
  ["hrana1", { version: 1, encoding: "json" }]
]);
var _socket, _openCallbacks, _opened, _closed4, _recvdHello, _subprotocol, _getVersionCalled, _responseMap, _requestIdAlloc, _sqlIdAlloc, _WsClient_instances, send_fn, onSocketOpen_fn, sendToSocket_fn, onSocketError_fn, onSocketClose_fn, setClosed_fn2, onSocketMessage_fn, handleMsg_fn;
var WsClient = class extends Client {
  /** @private */
  constructor(socket, jwt) {
    super();
    __privateAdd(this, _WsClient_instances);
    __privateAdd(this, _socket);
    // List of callbacks that we queue until the socket transitions from the CONNECTING to the OPEN state.
    __privateAdd(this, _openCallbacks);
    // Have we already transitioned from CONNECTING to OPEN and fired the callbacks in #openCallbacks?
    __privateAdd(this, _opened);
    // Stores the error that caused us to close the client (and the socket). If we are not closed, this is
    // `undefined`.
    __privateAdd(this, _closed4);
    // Have we received a response to our "hello" from the server?
    __privateAdd(this, _recvdHello);
    // Subprotocol negotiated with the server. It is only available after the socket transitions to the OPEN
    // state.
    __privateAdd(this, _subprotocol);
    // Has the `getVersion()` function been called? This is only used to validate that the API is used
    // correctly.
    __privateAdd(this, _getVersionCalled);
    // A map from request id to the responses that we expect to receive from the server.
    __privateAdd(this, _responseMap);
    // An allocator of request ids.
    __privateAdd(this, _requestIdAlloc);
    // An allocator of stream ids.
    /** @private */
    __publicField(this, "_streamIdAlloc");
    // An allocator of cursor ids.
    /** @private */
    __publicField(this, "_cursorIdAlloc");
    // An allocator of SQL text ids.
    __privateAdd(this, _sqlIdAlloc);
    __privateSet(this, _socket, socket);
    __privateSet(this, _openCallbacks, []);
    __privateSet(this, _opened, false);
    __privateSet(this, _closed4, void 0);
    __privateSet(this, _recvdHello, false);
    __privateSet(this, _subprotocol, void 0);
    __privateSet(this, _getVersionCalled, false);
    __privateSet(this, _responseMap, /* @__PURE__ */ new Map());
    __privateSet(this, _requestIdAlloc, new IdAlloc());
    this._streamIdAlloc = new IdAlloc();
    this._cursorIdAlloc = new IdAlloc();
    __privateSet(this, _sqlIdAlloc, new IdAlloc());
    __privateGet(this, _socket).binaryType = "arraybuffer";
    __privateGet(this, _socket).addEventListener("open", () => __privateMethod(this, _WsClient_instances, onSocketOpen_fn).call(this));
    __privateGet(this, _socket).addEventListener("close", (event) => __privateMethod(this, _WsClient_instances, onSocketClose_fn).call(this, event));
    __privateGet(this, _socket).addEventListener("error", (event) => __privateMethod(this, _WsClient_instances, onSocketError_fn).call(this, event));
    __privateGet(this, _socket).addEventListener("message", (event) => __privateMethod(this, _WsClient_instances, onSocketMessage_fn).call(this, event));
    __privateMethod(this, _WsClient_instances, send_fn).call(this, { type: "hello", jwt });
  }
  /** Get the protocol version negotiated with the server, possibly waiting until the socket is open. */
  getVersion() {
    return new Promise((versionCallback, errorCallback) => {
      __privateSet(this, _getVersionCalled, true);
      if (__privateGet(this, _closed4) !== void 0) {
        errorCallback(__privateGet(this, _closed4));
      } else if (!__privateGet(this, _opened)) {
        const openCallback = () => versionCallback(__privateGet(this, _subprotocol).version);
        __privateGet(this, _openCallbacks).push({ openCallback, errorCallback });
      } else {
        versionCallback(__privateGet(this, _subprotocol).version);
      }
    });
  }
  // Make sure that the negotiated version is at least `minVersion`.
  /** @private */
  _ensureVersion(minVersion, feature) {
    if (__privateGet(this, _subprotocol) === void 0 || !__privateGet(this, _getVersionCalled)) {
      throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, but the version supported by the WebSocket server is not yet known. Use Client.getVersion() to wait until the version is available.`);
    } else if (__privateGet(this, _subprotocol).version < minVersion) {
      throw new ProtocolVersionError(`${feature} is supported on protocol version ${minVersion} and higher, but the WebSocket server only supports version ${__privateGet(this, _subprotocol).version}`);
    }
  }
  // Send a request to the server and invoke a callback when we get the response.
  /** @private */
  _sendRequest(request, callbacks) {
    if (__privateGet(this, _closed4) !== void 0) {
      callbacks.errorCallback(new ClosedError("Client is closed", __privateGet(this, _closed4)));
      return;
    }
    const requestId = __privateGet(this, _requestIdAlloc).alloc();
    __privateGet(this, _responseMap).set(requestId, { ...callbacks, type: request.type });
    __privateMethod(this, _WsClient_instances, send_fn).call(this, { type: "request", requestId, request });
  }
  /** Open a {@link WsStream}, a stream for executing SQL statements. */
  openStream() {
    return WsStream.open(this);
  }
  /** Cache a SQL text on the server. This requires protocol version 2 or higher. */
  storeSql(sql) {
    this._ensureVersion(2, "storeSql()");
    const sqlId = __privateGet(this, _sqlIdAlloc).alloc();
    const sqlObj = new Sql(this, sqlId);
    const responseCallback = () => void 0;
    const errorCallback = (e) => sqlObj._setClosed(e);
    const request = { type: "store_sql", sqlId, sql };
    this._sendRequest(request, { responseCallback, errorCallback });
    return sqlObj;
  }
  /** @private */
  _closeSql(sqlId) {
    if (__privateGet(this, _closed4) !== void 0) {
      return;
    }
    const responseCallback = () => __privateGet(this, _sqlIdAlloc).free(sqlId);
    const errorCallback = (e) => __privateMethod(this, _WsClient_instances, setClosed_fn2).call(this, e);
    const request = { type: "close_sql", sqlId };
    this._sendRequest(request, { responseCallback, errorCallback });
  }
  /** Close the client and the WebSocket. */
  close() {
    __privateMethod(this, _WsClient_instances, setClosed_fn2).call(this, new ClientError("Client was manually closed"));
  }
  /** True if the client is closed. */
  get closed() {
    return __privateGet(this, _closed4) !== void 0;
  }
};
_socket = new WeakMap();
_openCallbacks = new WeakMap();
_opened = new WeakMap();
_closed4 = new WeakMap();
_recvdHello = new WeakMap();
_subprotocol = new WeakMap();
_getVersionCalled = new WeakMap();
_responseMap = new WeakMap();
_requestIdAlloc = new WeakMap();
_sqlIdAlloc = new WeakMap();
_WsClient_instances = new WeakSet();
// Send (or enqueue to send) a message to the server.
send_fn = function(msg) {
  if (__privateGet(this, _closed4) !== void 0) {
    throw new InternalError("Trying to send a message on a closed client");
  }
  if (__privateGet(this, _opened)) {
    __privateMethod(this, _WsClient_instances, sendToSocket_fn).call(this, msg);
  } else {
    const openCallback = () => __privateMethod(this, _WsClient_instances, sendToSocket_fn).call(this, msg);
    const errorCallback = () => void 0;
    __privateGet(this, _openCallbacks).push({ openCallback, errorCallback });
  }
};
// The socket transitioned from CONNECTING to OPEN
onSocketOpen_fn = function() {
  const protocol = __privateGet(this, _socket).protocol;
  if (protocol === void 0) {
    __privateMethod(this, _WsClient_instances, setClosed_fn2).call(this, new ClientError("The `WebSocket.protocol` property is undefined. This most likely means that the WebSocket implementation provided by the environment is broken. If you are using Miniflare 2, please update to Miniflare 3, which fixes this problem."));
    return;
  } else if (protocol === "") {
    __privateSet(this, _subprotocol, { version: 1, encoding: "json" });
  } else {
    __privateSet(this, _subprotocol, subprotocolsV3.get(protocol));
    if (__privateGet(this, _subprotocol) === void 0) {
      __privateMethod(this, _WsClient_instances, setClosed_fn2).call(this, new ProtoError(`Unrecognized WebSocket subprotocol: ${JSON.stringify(protocol)}`));
      return;
    }
  }
  for (const callbacks of __privateGet(this, _openCallbacks)) {
    callbacks.openCallback();
  }
  __privateGet(this, _openCallbacks).length = 0;
  __privateSet(this, _opened, true);
};
sendToSocket_fn = function(msg) {
  const encoding = __privateGet(this, _subprotocol).encoding;
  if (encoding === "json") {
    const jsonMsg = writeJsonObject(msg, ClientMsg);
    __privateGet(this, _socket).send(jsonMsg);
  } else if (encoding === "protobuf") {
    const protobufMsg = writeProtobufMessage(msg, ClientMsg2);
    __privateGet(this, _socket).send(protobufMsg);
  } else {
    throw impossible(encoding, "Impossible encoding");
  }
};
// The socket encountered an error.
onSocketError_fn = function(event) {
  const eventMessage = event.message;
  const message = eventMessage ?? "WebSocket was closed due to an error";
  __privateMethod(this, _WsClient_instances, setClosed_fn2).call(this, new WebSocketError(message));
};
// The socket was closed.
onSocketClose_fn = function(event) {
  let message = `WebSocket was closed with code ${event.code}`;
  if (event.reason) {
    message += `: ${event.reason}`;
  }
  __privateMethod(this, _WsClient_instances, setClosed_fn2).call(this, new WebSocketError(message));
};
// Close the client with the given error.
setClosed_fn2 = function(error) {
  if (__privateGet(this, _closed4) !== void 0) {
    return;
  }
  __privateSet(this, _closed4, error);
  for (const callbacks of __privateGet(this, _openCallbacks)) {
    callbacks.errorCallback(error);
  }
  __privateGet(this, _openCallbacks).length = 0;
  for (const [requestId, responseState] of __privateGet(this, _responseMap).entries()) {
    responseState.errorCallback(error);
    __privateGet(this, _requestIdAlloc).free(requestId);
  }
  __privateGet(this, _responseMap).clear();
  __privateGet(this, _socket).close();
};
// We received a message from the socket.
onSocketMessage_fn = function(event) {
  if (__privateGet(this, _closed4) !== void 0) {
    return;
  }
  try {
    let msg;
    const encoding = __privateGet(this, _subprotocol).encoding;
    if (encoding === "json") {
      if (typeof event.data !== "string") {
        __privateGet(this, _socket).close(3003, "Only text messages are accepted with JSON encoding");
        __privateMethod(this, _WsClient_instances, setClosed_fn2).call(this, new ProtoError("Received non-text message from server with JSON encoding"));
        return;
      }
      msg = readJsonObject(JSON.parse(event.data), ServerMsg);
    } else if (encoding === "protobuf") {
      if (!(event.data instanceof ArrayBuffer)) {
        __privateGet(this, _socket).close(3003, "Only binary messages are accepted with Protobuf encoding");
        __privateMethod(this, _WsClient_instances, setClosed_fn2).call(this, new ProtoError("Received non-binary message from server with Protobuf encoding"));
        return;
      }
      msg = readProtobufMessage(new Uint8Array(event.data), ServerMsg2);
    } else {
      throw impossible(encoding, "Impossible encoding");
    }
    __privateMethod(this, _WsClient_instances, handleMsg_fn).call(this, msg);
  } catch (e) {
    __privateGet(this, _socket).close(3007, "Could not handle message");
    __privateMethod(this, _WsClient_instances, setClosed_fn2).call(this, e);
  }
};
// Handle a message from the server.
handleMsg_fn = function(msg) {
  if (msg.type === "none") {
    throw new ProtoError("Received an unrecognized ServerMsg");
  } else if (msg.type === "hello_ok" || msg.type === "hello_error") {
    if (__privateGet(this, _recvdHello)) {
      throw new ProtoError("Received a duplicated hello response");
    }
    __privateSet(this, _recvdHello, true);
    if (msg.type === "hello_error") {
      throw errorFromProto(msg.error);
    }
    return;
  } else if (!__privateGet(this, _recvdHello)) {
    throw new ProtoError("Received a non-hello message before a hello response");
  }
  if (msg.type === "response_ok") {
    const requestId = msg.requestId;
    const responseState = __privateGet(this, _responseMap).get(requestId);
    __privateGet(this, _responseMap).delete(requestId);
    if (responseState === void 0) {
      throw new ProtoError("Received unexpected OK response");
    }
    __privateGet(this, _requestIdAlloc).free(requestId);
    try {
      if (responseState.type !== msg.response.type) {
        console.dir({ responseState, msg });
        throw new ProtoError("Received unexpected type of response");
      }
      responseState.responseCallback(msg.response);
    } catch (e) {
      responseState.errorCallback(e);
      throw e;
    }
  } else if (msg.type === "response_error") {
    const requestId = msg.requestId;
    const responseState = __privateGet(this, _responseMap).get(requestId);
    __privateGet(this, _responseMap).delete(requestId);
    if (responseState === void 0) {
      throw new ProtoError("Received unexpected error response");
    }
    __privateGet(this, _requestIdAlloc).free(requestId);
    responseState.errorCallback(errorFromProto(msg.error));
  } else {
    throw impossible(msg, "Impossible ServerMsg type");
  }
};

// node_modules/.pnpm/@libsql+isomorphic-fetch@0.2.1/node_modules/@libsql/isomorphic-fetch/web.js
var _fetch = fetch;
var _Request = Request;
var _Headers = Headers;

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/queue_microtask.js
var _queueMicrotask;
if (typeof queueMicrotask !== "undefined") {
  _queueMicrotask = queueMicrotask;
} else {
  const resolved = Promise.resolve();
  _queueMicrotask = (callback) => {
    resolved.then(callback);
  };
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/byte_queue.js
var _array3, _shiftPos, _pushPos, _ByteQueue_instances, ensurePush_fn;
var ByteQueue = class {
  constructor(initialCap) {
    __privateAdd(this, _ByteQueue_instances);
    __privateAdd(this, _array3);
    __privateAdd(this, _shiftPos);
    __privateAdd(this, _pushPos);
    __privateSet(this, _array3, new Uint8Array(new ArrayBuffer(initialCap)));
    __privateSet(this, _shiftPos, 0);
    __privateSet(this, _pushPos, 0);
  }
  get length() {
    return __privateGet(this, _pushPos) - __privateGet(this, _shiftPos);
  }
  data() {
    return __privateGet(this, _array3).slice(__privateGet(this, _shiftPos), __privateGet(this, _pushPos));
  }
  push(chunk) {
    __privateMethod(this, _ByteQueue_instances, ensurePush_fn).call(this, chunk.byteLength);
    __privateGet(this, _array3).set(chunk, __privateGet(this, _pushPos));
    __privateSet(this, _pushPos, __privateGet(this, _pushPos) + chunk.byteLength);
  }
  shift(length) {
    __privateSet(this, _shiftPos, __privateGet(this, _shiftPos) + length);
  }
};
_array3 = new WeakMap();
_shiftPos = new WeakMap();
_pushPos = new WeakMap();
_ByteQueue_instances = new WeakSet();
ensurePush_fn = function(pushLength) {
  if (__privateGet(this, _pushPos) + pushLength <= __privateGet(this, _array3).byteLength) {
    return;
  }
  const filledLength = __privateGet(this, _pushPos) - __privateGet(this, _shiftPos);
  if (filledLength + pushLength <= __privateGet(this, _array3).byteLength && 2 * __privateGet(this, _pushPos) >= __privateGet(this, _array3).byteLength) {
    __privateGet(this, _array3).copyWithin(0, __privateGet(this, _shiftPos), __privateGet(this, _pushPos));
  } else {
    let newCap = __privateGet(this, _array3).byteLength;
    do {
      newCap *= 2;
    } while (filledLength + pushLength > newCap);
    const newArray = new Uint8Array(new ArrayBuffer(newCap));
    newArray.set(__privateGet(this, _array3).slice(__privateGet(this, _shiftPos), __privateGet(this, _pushPos)), 0);
    __privateSet(this, _array3, newArray);
  }
  __privateSet(this, _pushPos, filledLength);
  __privateSet(this, _shiftPos, 0);
};

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/http/json_decode.js
function PipelineRespBody(obj) {
  const baton = stringOpt(obj["baton"]);
  const baseUrl = stringOpt(obj["base_url"]);
  const results = arrayObjectsMap(obj["results"], StreamResult);
  return { baton, baseUrl, results };
}
function StreamResult(obj) {
  const type = string2(obj["type"]);
  if (type === "ok") {
    const response = StreamResponse(object(obj["response"]));
    return { type: "ok", response };
  } else if (type === "error") {
    const error = Error2(object(obj["error"]));
    return { type: "error", error };
  } else {
    throw new ProtoError("Unexpected type of StreamResult");
  }
}
function StreamResponse(obj) {
  const type = string2(obj["type"]);
  if (type === "close") {
    return { type: "close" };
  } else if (type === "execute") {
    const result = StmtResult(object(obj["result"]));
    return { type: "execute", result };
  } else if (type === "batch") {
    const result = BatchResult(object(obj["result"]));
    return { type: "batch", result };
  } else if (type === "sequence") {
    return { type: "sequence" };
  } else if (type === "describe") {
    const result = DescribeResult(object(obj["result"]));
    return { type: "describe", result };
  } else if (type === "store_sql") {
    return { type: "store_sql" };
  } else if (type === "close_sql") {
    return { type: "close_sql" };
  } else if (type === "get_autocommit") {
    const isAutocommit = boolean(obj["is_autocommit"]);
    return { type: "get_autocommit", isAutocommit };
  } else {
    throw new ProtoError("Unexpected type of StreamResponse");
  }
}
function CursorRespBody(obj) {
  const baton = stringOpt(obj["baton"]);
  const baseUrl = stringOpt(obj["base_url"]);
  return { baton, baseUrl };
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/http/protobuf_decode.js
var PipelineRespBody2 = {
  default() {
    return { baton: void 0, baseUrl: void 0, results: [] };
  },
  1(r, msg) {
    msg.baton = r.string();
  },
  2(r, msg) {
    msg.baseUrl = r.string();
  },
  3(r, msg) {
    msg.results.push(r.message(StreamResult2));
  }
};
var StreamResult2 = {
  default() {
    return { type: "none" };
  },
  1(r) {
    return { type: "ok", response: r.message(StreamResponse2) };
  },
  2(r) {
    return { type: "error", error: r.message(Error3) };
  }
};
var StreamResponse2 = {
  default() {
    return { type: "none" };
  },
  1(r) {
    return { type: "close" };
  },
  2(r) {
    return r.message(ExecuteStreamResp);
  },
  3(r) {
    return r.message(BatchStreamResp);
  },
  4(r) {
    return { type: "sequence" };
  },
  5(r) {
    return r.message(DescribeStreamResp);
  },
  6(r) {
    return { type: "store_sql" };
  },
  7(r) {
    return { type: "close_sql" };
  },
  8(r) {
    return r.message(GetAutocommitStreamResp);
  }
};
var ExecuteStreamResp = {
  default() {
    return { type: "execute", result: StmtResult2.default() };
  },
  1(r, msg) {
    msg.result = r.message(StmtResult2);
  }
};
var BatchStreamResp = {
  default() {
    return { type: "batch", result: BatchResult2.default() };
  },
  1(r, msg) {
    msg.result = r.message(BatchResult2);
  }
};
var DescribeStreamResp = {
  default() {
    return { type: "describe", result: DescribeResult2.default() };
  },
  1(r, msg) {
    msg.result = r.message(DescribeResult2);
  }
};
var GetAutocommitStreamResp = {
  default() {
    return { type: "get_autocommit", isAutocommit: false };
  },
  1(r, msg) {
    msg.isAutocommit = r.bool();
  }
};
var CursorRespBody2 = {
  default() {
    return { baton: void 0, baseUrl: void 0 };
  },
  1(r, msg) {
    msg.baton = r.string();
  },
  2(r, msg) {
    msg.baseUrl = r.string();
  }
};

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/http/cursor.js
var _stream2, _encoding, _reader2, _queue2, _closed5, _done2, _HttpCursor_instances, nextItem_fn, parseItemJson_fn, parseItemProtobuf_fn;
var HttpCursor = class extends Cursor {
  /** @private */
  constructor(stream, encoding) {
    super();
    __privateAdd(this, _HttpCursor_instances);
    __privateAdd(this, _stream2);
    __privateAdd(this, _encoding);
    __privateAdd(this, _reader2);
    __privateAdd(this, _queue2);
    __privateAdd(this, _closed5);
    __privateAdd(this, _done2);
    __privateSet(this, _stream2, stream);
    __privateSet(this, _encoding, encoding);
    __privateSet(this, _reader2, void 0);
    __privateSet(this, _queue2, new ByteQueue(16 * 1024));
    __privateSet(this, _closed5, void 0);
    __privateSet(this, _done2, false);
  }
  async open(response) {
    if (response.body === null) {
      throw new ProtoError("No response body for cursor request");
    }
    __privateSet(this, _reader2, response.body.getReader());
    const respBody = await __privateMethod(this, _HttpCursor_instances, nextItem_fn).call(this, CursorRespBody, CursorRespBody2);
    if (respBody === void 0) {
      throw new ProtoError("Empty response to cursor request");
    }
    return respBody;
  }
  /** Fetch the next entry from the cursor. */
  next() {
    return __privateMethod(this, _HttpCursor_instances, nextItem_fn).call(this, CursorEntry, CursorEntry2);
  }
  /** Close the cursor. */
  close() {
    this._setClosed(new ClientError("Cursor was manually closed"));
  }
  /** @private */
  _setClosed(error) {
    if (__privateGet(this, _closed5) !== void 0) {
      return;
    }
    __privateSet(this, _closed5, error);
    __privateGet(this, _stream2)._cursorClosed(this);
    if (__privateGet(this, _reader2) !== void 0) {
      __privateGet(this, _reader2).cancel();
    }
  }
  /** True if the cursor is closed. */
  get closed() {
    return __privateGet(this, _closed5) !== void 0;
  }
};
_stream2 = new WeakMap();
_encoding = new WeakMap();
_reader2 = new WeakMap();
_queue2 = new WeakMap();
_closed5 = new WeakMap();
_done2 = new WeakMap();
_HttpCursor_instances = new WeakSet();
nextItem_fn = async function(jsonFun, protobufDef) {
  for (; ; ) {
    if (__privateGet(this, _done2)) {
      return void 0;
    } else if (__privateGet(this, _closed5) !== void 0) {
      throw new ClosedError("Cursor is closed", __privateGet(this, _closed5));
    }
    if (__privateGet(this, _encoding) === "json") {
      const jsonData = __privateMethod(this, _HttpCursor_instances, parseItemJson_fn).call(this);
      if (jsonData !== void 0) {
        const jsonText = new TextDecoder().decode(jsonData);
        const jsonValue = JSON.parse(jsonText);
        return readJsonObject(jsonValue, jsonFun);
      }
    } else if (__privateGet(this, _encoding) === "protobuf") {
      const protobufData = __privateMethod(this, _HttpCursor_instances, parseItemProtobuf_fn).call(this);
      if (protobufData !== void 0) {
        return readProtobufMessage(protobufData, protobufDef);
      }
    } else {
      throw impossible(__privateGet(this, _encoding), "Impossible encoding");
    }
    if (__privateGet(this, _reader2) === void 0) {
      throw new InternalError("Attempted to read from HTTP cursor before it was opened");
    }
    const { value: value2, done } = await __privateGet(this, _reader2).read();
    if (done && __privateGet(this, _queue2).length === 0) {
      __privateSet(this, _done2, true);
    } else if (done) {
      throw new ProtoError("Unexpected end of cursor stream");
    } else {
      __privateGet(this, _queue2).push(value2);
    }
  }
};
parseItemJson_fn = function() {
  const data = __privateGet(this, _queue2).data();
  const newlineByte = 10;
  const newlinePos = data.indexOf(newlineByte);
  if (newlinePos < 0) {
    return void 0;
  }
  const jsonData = data.slice(0, newlinePos);
  __privateGet(this, _queue2).shift(newlinePos + 1);
  return jsonData;
};
parseItemProtobuf_fn = function() {
  const data = __privateGet(this, _queue2).data();
  let varintValue = 0;
  let varintLength = 0;
  for (; ; ) {
    if (varintLength >= data.byteLength) {
      return void 0;
    }
    const byte = data[varintLength];
    varintValue |= (byte & 127) << 7 * varintLength;
    varintLength += 1;
    if (!(byte & 128)) {
      break;
    }
  }
  if (data.byteLength < varintLength + varintValue) {
    return void 0;
  }
  const protobufData = data.slice(varintLength, varintLength + varintValue);
  __privateGet(this, _queue2).shift(varintLength + varintValue);
  return protobufData;
};

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/http/json_encode.js
function PipelineReqBody(w, msg) {
  if (msg.baton !== void 0) {
    w.string("baton", msg.baton);
  }
  w.arrayObjects("requests", msg.requests, StreamRequest);
}
function StreamRequest(w, msg) {
  w.stringRaw("type", msg.type);
  if (msg.type === "close") {
  } else if (msg.type === "execute") {
    w.object("stmt", msg.stmt, Stmt2);
  } else if (msg.type === "batch") {
    w.object("batch", msg.batch, Batch2);
  } else if (msg.type === "sequence") {
    if (msg.sql !== void 0) {
      w.string("sql", msg.sql);
    }
    if (msg.sqlId !== void 0) {
      w.number("sql_id", msg.sqlId);
    }
  } else if (msg.type === "describe") {
    if (msg.sql !== void 0) {
      w.string("sql", msg.sql);
    }
    if (msg.sqlId !== void 0) {
      w.number("sql_id", msg.sqlId);
    }
  } else if (msg.type === "store_sql") {
    w.number("sql_id", msg.sqlId);
    w.string("sql", msg.sql);
  } else if (msg.type === "close_sql") {
    w.number("sql_id", msg.sqlId);
  } else if (msg.type === "get_autocommit") {
  } else {
    throw impossible(msg, "Impossible type of StreamRequest");
  }
}
function CursorReqBody(w, msg) {
  if (msg.baton !== void 0) {
    w.string("baton", msg.baton);
  }
  w.object("batch", msg.batch, Batch2);
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/http/protobuf_encode.js
function PipelineReqBody2(w, msg) {
  if (msg.baton !== void 0) {
    w.string(1, msg.baton);
  }
  for (const req of msg.requests) {
    w.message(2, req, StreamRequest2);
  }
}
function StreamRequest2(w, msg) {
  if (msg.type === "close") {
    w.message(1, msg, CloseStreamReq2);
  } else if (msg.type === "execute") {
    w.message(2, msg, ExecuteStreamReq);
  } else if (msg.type === "batch") {
    w.message(3, msg, BatchStreamReq);
  } else if (msg.type === "sequence") {
    w.message(4, msg, SequenceStreamReq);
  } else if (msg.type === "describe") {
    w.message(5, msg, DescribeStreamReq);
  } else if (msg.type === "store_sql") {
    w.message(6, msg, StoreSqlStreamReq);
  } else if (msg.type === "close_sql") {
    w.message(7, msg, CloseSqlStreamReq);
  } else if (msg.type === "get_autocommit") {
    w.message(8, msg, GetAutocommitStreamReq);
  } else {
    throw impossible(msg, "Impossible type of StreamRequest");
  }
}
function CloseStreamReq2(_w, _msg) {
}
function ExecuteStreamReq(w, msg) {
  w.message(1, msg.stmt, Stmt3);
}
function BatchStreamReq(w, msg) {
  w.message(1, msg.batch, Batch3);
}
function SequenceStreamReq(w, msg) {
  if (msg.sql !== void 0) {
    w.string(1, msg.sql);
  }
  if (msg.sqlId !== void 0) {
    w.int32(2, msg.sqlId);
  }
}
function DescribeStreamReq(w, msg) {
  if (msg.sql !== void 0) {
    w.string(1, msg.sql);
  }
  if (msg.sqlId !== void 0) {
    w.int32(2, msg.sqlId);
  }
}
function StoreSqlStreamReq(w, msg) {
  w.int32(1, msg.sqlId);
  w.string(2, msg.sql);
}
function CloseSqlStreamReq(w, msg) {
  w.int32(1, msg.sqlId);
}
function GetAutocommitStreamReq(_w, _msg) {
}
function CursorReqBody2(w, msg) {
  if (msg.baton !== void 0) {
    w.string(1, msg.baton);
  }
  w.message(2, msg.batch, Batch3);
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/http/stream.js
var _client3, _baseUrl, _jwt, _fetch2, _baton, _queue3, _flushing, _cursor2, _closing2, _closeQueued, _closed6, _sqlIdAlloc2, _HttpStream_instances, sendStreamRequest_fn2, pushToQueue_fn2, flushQueue_fn2, flushPipeline_fn, flushCursor_fn, flush_fn, createPipelineRequest_fn, createCursorRequest_fn, createRequest_fn;
var HttpStream = class extends Stream {
  /** @private */
  constructor(client, baseUrl, jwt, customFetch) {
    super(client.intMode);
    __privateAdd(this, _HttpStream_instances);
    __privateAdd(this, _client3);
    __privateAdd(this, _baseUrl);
    __privateAdd(this, _jwt);
    __privateAdd(this, _fetch2);
    __privateAdd(this, _baton);
    __privateAdd(this, _queue3);
    __privateAdd(this, _flushing);
    __privateAdd(this, _cursor2);
    __privateAdd(this, _closing2);
    __privateAdd(this, _closeQueued);
    __privateAdd(this, _closed6);
    __privateAdd(this, _sqlIdAlloc2);
    __privateSet(this, _client3, client);
    __privateSet(this, _baseUrl, baseUrl.toString());
    __privateSet(this, _jwt, jwt);
    __privateSet(this, _fetch2, customFetch);
    __privateSet(this, _baton, void 0);
    __privateSet(this, _queue3, new Queue());
    __privateSet(this, _flushing, false);
    __privateSet(this, _closing2, false);
    __privateSet(this, _closeQueued, false);
    __privateSet(this, _closed6, void 0);
    __privateSet(this, _sqlIdAlloc2, new IdAlloc());
  }
  /** Get the {@link HttpClient} object that this stream belongs to. */
  client() {
    return __privateGet(this, _client3);
  }
  /** @private */
  _sqlOwner() {
    return this;
  }
  /** Cache a SQL text on the server. */
  storeSql(sql) {
    const sqlId = __privateGet(this, _sqlIdAlloc2).alloc();
    __privateMethod(this, _HttpStream_instances, sendStreamRequest_fn2).call(this, { type: "store_sql", sqlId, sql }).then(() => void 0, (error) => this._setClosed(error));
    return new Sql(this, sqlId);
  }
  /** @private */
  _closeSql(sqlId) {
    if (__privateGet(this, _closed6) !== void 0) {
      return;
    }
    __privateMethod(this, _HttpStream_instances, sendStreamRequest_fn2).call(this, { type: "close_sql", sqlId }).then(() => __privateGet(this, _sqlIdAlloc2).free(sqlId), (error) => this._setClosed(error));
  }
  /** @private */
  _execute(stmt) {
    return __privateMethod(this, _HttpStream_instances, sendStreamRequest_fn2).call(this, { type: "execute", stmt }).then((response) => {
      return response.result;
    });
  }
  /** @private */
  _batch(batch) {
    return __privateMethod(this, _HttpStream_instances, sendStreamRequest_fn2).call(this, { type: "batch", batch }).then((response) => {
      return response.result;
    });
  }
  /** @private */
  _describe(protoSql) {
    return __privateMethod(this, _HttpStream_instances, sendStreamRequest_fn2).call(this, {
      type: "describe",
      sql: protoSql.sql,
      sqlId: protoSql.sqlId
    }).then((response) => {
      return response.result;
    });
  }
  /** @private */
  _sequence(protoSql) {
    return __privateMethod(this, _HttpStream_instances, sendStreamRequest_fn2).call(this, {
      type: "sequence",
      sql: protoSql.sql,
      sqlId: protoSql.sqlId
    }).then((_response) => {
      return void 0;
    });
  }
  /** Check whether the SQL connection underlying this stream is in autocommit state (i.e., outside of an
   * explicit transaction). This requires protocol version 3 or higher.
   */
  getAutocommit() {
    __privateGet(this, _client3)._ensureVersion(3, "getAutocommit()");
    return __privateMethod(this, _HttpStream_instances, sendStreamRequest_fn2).call(this, {
      type: "get_autocommit"
    }).then((response) => {
      return response.isAutocommit;
    });
  }
  /** @private */
  _openCursor(batch) {
    return new Promise((cursorCallback, errorCallback) => {
      __privateMethod(this, _HttpStream_instances, pushToQueue_fn2).call(this, { type: "cursor", batch, cursorCallback, errorCallback });
    });
  }
  /** @private */
  _cursorClosed(cursor) {
    if (cursor !== __privateGet(this, _cursor2)) {
      throw new InternalError("Cursor was closed, but it was not associated with the stream");
    }
    __privateSet(this, _cursor2, void 0);
    _queueMicrotask(() => __privateMethod(this, _HttpStream_instances, flushQueue_fn2).call(this));
  }
  /** Immediately close the stream. */
  close() {
    this._setClosed(new ClientError("Stream was manually closed"));
  }
  /** Gracefully close the stream. */
  closeGracefully() {
    __privateSet(this, _closing2, true);
    _queueMicrotask(() => __privateMethod(this, _HttpStream_instances, flushQueue_fn2).call(this));
  }
  /** True if the stream is closed. */
  get closed() {
    return __privateGet(this, _closed6) !== void 0 || __privateGet(this, _closing2);
  }
  /** @private */
  _setClosed(error) {
    if (__privateGet(this, _closed6) !== void 0) {
      return;
    }
    __privateSet(this, _closed6, error);
    if (__privateGet(this, _cursor2) !== void 0) {
      __privateGet(this, _cursor2)._setClosed(error);
    }
    __privateGet(this, _client3)._streamClosed(this);
    for (; ; ) {
      const entry = __privateGet(this, _queue3).shift();
      if (entry !== void 0) {
        entry.errorCallback(error);
      } else {
        break;
      }
    }
    if ((__privateGet(this, _baton) !== void 0 || __privateGet(this, _flushing)) && !__privateGet(this, _closeQueued)) {
      __privateGet(this, _queue3).push({
        type: "pipeline",
        request: { type: "close" },
        responseCallback: () => void 0,
        errorCallback: () => void 0
      });
      __privateSet(this, _closeQueued, true);
      _queueMicrotask(() => __privateMethod(this, _HttpStream_instances, flushQueue_fn2).call(this));
    }
  }
};
_client3 = new WeakMap();
_baseUrl = new WeakMap();
_jwt = new WeakMap();
_fetch2 = new WeakMap();
_baton = new WeakMap();
_queue3 = new WeakMap();
_flushing = new WeakMap();
_cursor2 = new WeakMap();
_closing2 = new WeakMap();
_closeQueued = new WeakMap();
_closed6 = new WeakMap();
_sqlIdAlloc2 = new WeakMap();
_HttpStream_instances = new WeakSet();
sendStreamRequest_fn2 = function(request) {
  return new Promise((responseCallback, errorCallback) => {
    __privateMethod(this, _HttpStream_instances, pushToQueue_fn2).call(this, { type: "pipeline", request, responseCallback, errorCallback });
  });
};
pushToQueue_fn2 = function(entry) {
  if (__privateGet(this, _closed6) !== void 0) {
    throw new ClosedError("Stream is closed", __privateGet(this, _closed6));
  } else if (__privateGet(this, _closing2)) {
    throw new ClosedError("Stream is closing", void 0);
  } else {
    __privateGet(this, _queue3).push(entry);
    _queueMicrotask(() => __privateMethod(this, _HttpStream_instances, flushQueue_fn2).call(this));
  }
};
flushQueue_fn2 = function() {
  if (__privateGet(this, _flushing) || __privateGet(this, _cursor2) !== void 0) {
    return;
  }
  if (__privateGet(this, _closing2) && __privateGet(this, _queue3).length === 0) {
    this._setClosed(new ClientError("Stream was gracefully closed"));
    return;
  }
  const endpoint = __privateGet(this, _client3)._endpoint;
  if (endpoint === void 0) {
    __privateGet(this, _client3)._endpointPromise.then(() => __privateMethod(this, _HttpStream_instances, flushQueue_fn2).call(this), (error) => this._setClosed(error));
    return;
  }
  const firstEntry = __privateGet(this, _queue3).shift();
  if (firstEntry === void 0) {
    return;
  } else if (firstEntry.type === "pipeline") {
    const pipeline = [firstEntry];
    for (; ; ) {
      const entry = __privateGet(this, _queue3).first();
      if (entry !== void 0 && entry.type === "pipeline") {
        pipeline.push(entry);
        __privateGet(this, _queue3).shift();
      } else if (entry === void 0 && __privateGet(this, _closing2) && !__privateGet(this, _closeQueued)) {
        pipeline.push({
          type: "pipeline",
          request: { type: "close" },
          responseCallback: () => void 0,
          errorCallback: () => void 0
        });
        __privateSet(this, _closeQueued, true);
        break;
      } else {
        break;
      }
    }
    __privateMethod(this, _HttpStream_instances, flushPipeline_fn).call(this, endpoint, pipeline);
  } else if (firstEntry.type === "cursor") {
    __privateMethod(this, _HttpStream_instances, flushCursor_fn).call(this, endpoint, firstEntry);
  } else {
    throw impossible(firstEntry, "Impossible type of QueueEntry");
  }
};
flushPipeline_fn = function(endpoint, pipeline) {
  __privateMethod(this, _HttpStream_instances, flush_fn).call(this, () => __privateMethod(this, _HttpStream_instances, createPipelineRequest_fn).call(this, pipeline, endpoint), (resp) => decodePipelineResponse(resp, endpoint.encoding), (respBody) => respBody.baton, (respBody) => respBody.baseUrl, (respBody) => handlePipelineResponse(pipeline, respBody), (error) => pipeline.forEach((entry) => entry.errorCallback(error)));
};
flushCursor_fn = function(endpoint, entry) {
  const cursor = new HttpCursor(this, endpoint.encoding);
  __privateSet(this, _cursor2, cursor);
  __privateMethod(this, _HttpStream_instances, flush_fn).call(this, () => __privateMethod(this, _HttpStream_instances, createCursorRequest_fn).call(this, entry, endpoint), (resp) => cursor.open(resp), (respBody) => respBody.baton, (respBody) => respBody.baseUrl, (_respBody) => entry.cursorCallback(cursor), (error) => entry.errorCallback(error));
};
flush_fn = function(createRequest, decodeResponse, getBaton, getBaseUrl, handleResponse, handleError) {
  let promise;
  try {
    const request = createRequest();
    const fetch2 = __privateGet(this, _fetch2);
    promise = fetch2(request);
  } catch (error) {
    promise = Promise.reject(error);
  }
  __privateSet(this, _flushing, true);
  promise.then((resp) => {
    if (!resp.ok) {
      return errorFromResponse(resp).then((error) => {
        throw error;
      });
    }
    return decodeResponse(resp);
  }).then((r) => {
    __privateSet(this, _baton, getBaton(r));
    __privateSet(this, _baseUrl, getBaseUrl(r) ?? __privateGet(this, _baseUrl));
    handleResponse(r);
  }).catch((error) => {
    this._setClosed(error);
    handleError(error);
  }).finally(() => {
    __privateSet(this, _flushing, false);
    __privateMethod(this, _HttpStream_instances, flushQueue_fn2).call(this);
  });
};
createPipelineRequest_fn = function(pipeline, endpoint) {
  return __privateMethod(this, _HttpStream_instances, createRequest_fn).call(this, new URL(endpoint.pipelinePath, __privateGet(this, _baseUrl)), {
    baton: __privateGet(this, _baton),
    requests: pipeline.map((entry) => entry.request)
  }, endpoint.encoding, PipelineReqBody, PipelineReqBody2);
};
createCursorRequest_fn = function(entry, endpoint) {
  if (endpoint.cursorPath === void 0) {
    throw new ProtocolVersionError(`Cursors are supported only on protocol version 3 and higher, but the HTTP server only supports version ${endpoint.version}.`);
  }
  return __privateMethod(this, _HttpStream_instances, createRequest_fn).call(this, new URL(endpoint.cursorPath, __privateGet(this, _baseUrl)), {
    baton: __privateGet(this, _baton),
    batch: entry.batch
  }, endpoint.encoding, CursorReqBody, CursorReqBody2);
};
createRequest_fn = function(url, reqBody, encoding, jsonFun, protobufFun) {
  let bodyData;
  let contentType;
  if (encoding === "json") {
    bodyData = writeJsonObject(reqBody, jsonFun);
    contentType = "application/json";
  } else if (encoding === "protobuf") {
    bodyData = writeProtobufMessage(reqBody, protobufFun);
    contentType = "application/x-protobuf";
  } else {
    throw impossible(encoding, "Impossible encoding");
  }
  const headers = new _Headers();
  headers.set("content-type", contentType);
  if (__privateGet(this, _jwt) !== void 0) {
    headers.set("authorization", `Bearer ${__privateGet(this, _jwt)}`);
  }
  return new _Request(url.toString(), { method: "POST", headers, body: bodyData });
};
function handlePipelineResponse(pipeline, respBody) {
  if (respBody.results.length !== pipeline.length) {
    throw new ProtoError("Server returned unexpected number of pipeline results");
  }
  for (let i = 0; i < pipeline.length; ++i) {
    const result = respBody.results[i];
    const entry = pipeline[i];
    if (result.type === "ok") {
      if (result.response.type !== entry.request.type) {
        throw new ProtoError("Received unexpected type of response");
      }
      entry.responseCallback(result.response);
    } else if (result.type === "error") {
      entry.errorCallback(errorFromProto(result.error));
    } else if (result.type === "none") {
      throw new ProtoError("Received unrecognized type of StreamResult");
    } else {
      throw impossible(result, "Received impossible type of StreamResult");
    }
  }
}
async function decodePipelineResponse(resp, encoding) {
  if (encoding === "json") {
    const respJson = await resp.json();
    return readJsonObject(respJson, PipelineRespBody);
  } else if (encoding === "protobuf") {
    const respData = await resp.arrayBuffer();
    return readProtobufMessage(new Uint8Array(respData), PipelineRespBody2);
  } else {
    throw impossible(encoding, "Impossible encoding");
  }
}
async function errorFromResponse(resp) {
  const respType = resp.headers.get("content-type") ?? "text/plain";
  if (respType === "application/json") {
    const respBody = await resp.json();
    if ("message" in respBody) {
      return errorFromProto(respBody);
    }
  }
  let message = `Server returned HTTP status ${resp.status}`;
  if (respType === "text/plain") {
    const respBody = (await resp.text()).trim();
    if (respBody !== "") {
      message += `: ${respBody}`;
    }
  }
  return new HttpServerError(message, resp.status);
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/http/client.js
var checkEndpoints = [
  {
    versionPath: "v3-protobuf",
    pipelinePath: "v3-protobuf/pipeline",
    cursorPath: "v3-protobuf/cursor",
    version: 3,
    encoding: "protobuf"
  }
  /*
  {
      versionPath: "v3",
      pipelinePath: "v3/pipeline",
      cursorPath: "v3/cursor",
      version: 3,
      encoding: "json",
  },
  */
];
var fallbackEndpoint = {
  versionPath: "v2",
  pipelinePath: "v2/pipeline",
  cursorPath: void 0,
  version: 2,
  encoding: "json"
};
var _url, _jwt2, _fetch3, _closed7, _streams, _HttpClient_instances, setClosed_fn3;
var HttpClient = class extends Client {
  /** @private */
  constructor(url, jwt, customFetch, protocolVersion = 2) {
    super();
    __privateAdd(this, _HttpClient_instances);
    __privateAdd(this, _url);
    __privateAdd(this, _jwt2);
    __privateAdd(this, _fetch3);
    __privateAdd(this, _closed7);
    __privateAdd(this, _streams);
    /** @private */
    __publicField(this, "_endpointPromise");
    /** @private */
    __publicField(this, "_endpoint");
    __privateSet(this, _url, url);
    __privateSet(this, _jwt2, jwt);
    __privateSet(this, _fetch3, customFetch ?? _fetch);
    __privateSet(this, _closed7, void 0);
    __privateSet(this, _streams, /* @__PURE__ */ new Set());
    if (protocolVersion == 3) {
      this._endpointPromise = findEndpoint(__privateGet(this, _fetch3), __privateGet(this, _url));
      this._endpointPromise.then((endpoint) => this._endpoint = endpoint, (error) => __privateMethod(this, _HttpClient_instances, setClosed_fn3).call(this, error));
    } else {
      this._endpointPromise = Promise.resolve(fallbackEndpoint);
      this._endpointPromise.then((endpoint) => this._endpoint = endpoint, (error) => __privateMethod(this, _HttpClient_instances, setClosed_fn3).call(this, error));
    }
  }
  /** Get the protocol version supported by the server. */
  async getVersion() {
    if (this._endpoint !== void 0) {
      return this._endpoint.version;
    }
    return (await this._endpointPromise).version;
  }
  // Make sure that the negotiated version is at least `minVersion`.
  /** @private */
  _ensureVersion(minVersion, feature) {
    if (minVersion <= fallbackEndpoint.version) {
      return;
    } else if (this._endpoint === void 0) {
      throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, but the version supported by the HTTP server is not yet known. Use Client.getVersion() to wait until the version is available.`);
    } else if (this._endpoint.version < minVersion) {
      throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, but the HTTP server only supports version ${this._endpoint.version}.`);
    }
  }
  /** Open a {@link HttpStream}, a stream for executing SQL statements. */
  openStream() {
    if (__privateGet(this, _closed7) !== void 0) {
      throw new ClosedError("Client is closed", __privateGet(this, _closed7));
    }
    const stream = new HttpStream(this, __privateGet(this, _url), __privateGet(this, _jwt2), __privateGet(this, _fetch3));
    __privateGet(this, _streams).add(stream);
    return stream;
  }
  /** @private */
  _streamClosed(stream) {
    __privateGet(this, _streams).delete(stream);
  }
  /** Close the client and all its streams. */
  close() {
    __privateMethod(this, _HttpClient_instances, setClosed_fn3).call(this, new ClientError("Client was manually closed"));
  }
  /** True if the client is closed. */
  get closed() {
    return __privateGet(this, _closed7) !== void 0;
  }
};
_url = new WeakMap();
_jwt2 = new WeakMap();
_fetch3 = new WeakMap();
_closed7 = new WeakMap();
_streams = new WeakMap();
_HttpClient_instances = new WeakSet();
setClosed_fn3 = function(error) {
  if (__privateGet(this, _closed7) !== void 0) {
    return;
  }
  __privateSet(this, _closed7, error);
  for (const stream of Array.from(__privateGet(this, _streams))) {
    stream._setClosed(new ClosedError("Client was closed", error));
  }
};
async function findEndpoint(customFetch, clientUrl) {
  const fetch2 = customFetch;
  for (const endpoint of checkEndpoints) {
    const url = new URL(endpoint.versionPath, clientUrl);
    const request = new _Request(url.toString(), { method: "GET" });
    const response = await fetch2(request);
    await response.arrayBuffer();
    if (response.ok) {
      return endpoint;
    }
  }
  return fallbackEndpoint;
}

// node_modules/.pnpm/@libsql+hrana-client@0.6.2_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/hrana-client/lib-esm/index.js
function openWs(url, jwt, protocolVersion = 2) {
  if (typeof _WebSocket === "undefined") {
    throw new WebSocketUnsupportedError("WebSockets are not supported in this environment");
  }
  var subprotocols = void 0;
  if (protocolVersion == 3) {
    subprotocols = Array.from(subprotocolsV3.keys());
  } else {
    subprotocols = Array.from(subprotocolsV2.keys());
  }
  const socket = new _WebSocket(url, subprotocols);
  return new WsClient(socket, jwt);
}
function openHttp(url, jwt, customFetch, protocolVersion = 2) {
  return new HttpClient(url instanceof URL ? url : new URL(url), jwt, customFetch, protocolVersion);
}

// node_modules/.pnpm/@libsql+client@0.8.1_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/client/lib-esm/hrana.js
var _mode, _version, _started;
var HranaTransaction = class {
  /** @private */
  constructor(mode, version2) {
    __privateAdd(this, _mode);
    __privateAdd(this, _version);
    // Promise that is resolved when the BEGIN statement completes, or `undefined` if we haven't executed the
    // BEGIN statement yet.
    __privateAdd(this, _started);
    __privateSet(this, _mode, mode);
    __privateSet(this, _version, version2);
    __privateSet(this, _started, void 0);
  }
  execute(stmt) {
    return this.batch([stmt]).then((results) => results[0]);
  }
  async batch(stmts) {
    const stream = this._getStream();
    if (stream.closed) {
      throw new LibsqlError("Cannot execute statements because the transaction is closed", "TRANSACTION_CLOSED");
    }
    try {
      const hranaStmts = stmts.map(stmtToHrana);
      let rowsPromises;
      if (__privateGet(this, _started) === void 0) {
        this._getSqlCache().apply(hranaStmts);
        const batch = stream.batch(__privateGet(this, _version) >= 3);
        const beginStep = batch.step();
        const beginPromise = beginStep.run(transactionModeToBegin(__privateGet(this, _mode)));
        let lastStep = beginStep;
        rowsPromises = hranaStmts.map((hranaStmt) => {
          const stmtStep = batch.step().condition(BatchCond.ok(lastStep));
          if (__privateGet(this, _version) >= 3) {
            stmtStep.condition(BatchCond.not(BatchCond.isAutocommit(batch)));
          }
          const rowsPromise = stmtStep.query(hranaStmt);
          rowsPromise.catch(() => void 0);
          lastStep = stmtStep;
          return rowsPromise;
        });
        __privateSet(this, _started, batch.execute().then(() => beginPromise).then(() => void 0));
        try {
          await __privateGet(this, _started);
        } catch (e) {
          this.close();
          throw e;
        }
      } else {
        if (__privateGet(this, _version) < 3) {
          await __privateGet(this, _started);
        } else {
        }
        this._getSqlCache().apply(hranaStmts);
        const batch = stream.batch(__privateGet(this, _version) >= 3);
        let lastStep = void 0;
        rowsPromises = hranaStmts.map((hranaStmt) => {
          const stmtStep = batch.step();
          if (lastStep !== void 0) {
            stmtStep.condition(BatchCond.ok(lastStep));
          }
          if (__privateGet(this, _version) >= 3) {
            stmtStep.condition(BatchCond.not(BatchCond.isAutocommit(batch)));
          }
          const rowsPromise = stmtStep.query(hranaStmt);
          rowsPromise.catch(() => void 0);
          lastStep = stmtStep;
          return rowsPromise;
        });
        await batch.execute();
      }
      const resultSets = [];
      for (const rowsPromise of rowsPromises) {
        const rows = await rowsPromise;
        if (rows === void 0) {
          throw new LibsqlError("Statement in a transaction was not executed, probably because the transaction has been rolled back", "TRANSACTION_CLOSED");
        }
        resultSets.push(resultSetFromHrana(rows));
      }
      return resultSets;
    } catch (e) {
      throw mapHranaError(e);
    }
  }
  async executeMultiple(sql) {
    const stream = this._getStream();
    if (stream.closed) {
      throw new LibsqlError("Cannot execute statements because the transaction is closed", "TRANSACTION_CLOSED");
    }
    try {
      if (__privateGet(this, _started) === void 0) {
        __privateSet(this, _started, stream.run(transactionModeToBegin(__privateGet(this, _mode))).then(() => void 0));
        try {
          await __privateGet(this, _started);
        } catch (e) {
          this.close();
          throw e;
        }
      } else {
        await __privateGet(this, _started);
      }
      await stream.sequence(sql);
    } catch (e) {
      throw mapHranaError(e);
    }
  }
  async rollback() {
    try {
      const stream = this._getStream();
      if (stream.closed) {
        return;
      }
      if (__privateGet(this, _started) !== void 0) {
      } else {
        return;
      }
      const promise = stream.run("ROLLBACK").catch((e) => {
        throw mapHranaError(e);
      });
      stream.closeGracefully();
      await promise;
    } catch (e) {
      throw mapHranaError(e);
    } finally {
      this.close();
    }
  }
  async commit() {
    try {
      const stream = this._getStream();
      if (stream.closed) {
        throw new LibsqlError("Cannot commit the transaction because it is already closed", "TRANSACTION_CLOSED");
      }
      if (__privateGet(this, _started) !== void 0) {
        await __privateGet(this, _started);
      } else {
        return;
      }
      const promise = stream.run("COMMIT").catch((e) => {
        throw mapHranaError(e);
      });
      stream.closeGracefully();
      await promise;
    } catch (e) {
      throw mapHranaError(e);
    } finally {
      this.close();
    }
  }
};
_mode = new WeakMap();
_version = new WeakMap();
_started = new WeakMap();
async function executeHranaBatch(mode, version2, batch, hranaStmts) {
  const beginStep = batch.step();
  const beginPromise = beginStep.run(transactionModeToBegin(mode));
  let lastStep = beginStep;
  const stmtPromises = hranaStmts.map((hranaStmt) => {
    const stmtStep = batch.step().condition(BatchCond.ok(lastStep));
    if (version2 >= 3) {
      stmtStep.condition(BatchCond.not(BatchCond.isAutocommit(batch)));
    }
    const stmtPromise = stmtStep.query(hranaStmt);
    lastStep = stmtStep;
    return stmtPromise;
  });
  const commitStep = batch.step().condition(BatchCond.ok(lastStep));
  if (version2 >= 3) {
    commitStep.condition(BatchCond.not(BatchCond.isAutocommit(batch)));
  }
  const commitPromise = commitStep.run("COMMIT");
  const rollbackStep = batch.step().condition(BatchCond.not(BatchCond.ok(commitStep)));
  rollbackStep.run("ROLLBACK").catch((_) => void 0);
  await batch.execute();
  const resultSets = [];
  await beginPromise;
  for (const stmtPromise of stmtPromises) {
    const hranaRows = await stmtPromise;
    if (hranaRows === void 0) {
      throw new LibsqlError("Statement in a batch was not executed, probably because the transaction has been rolled back", "TRANSACTION_CLOSED");
    }
    resultSets.push(resultSetFromHrana(hranaRows));
  }
  await commitPromise;
  return resultSets;
}
function stmtToHrana(stmt) {
  if (typeof stmt === "string") {
    return new Stmt(stmt);
  }
  const hranaStmt = new Stmt(stmt.sql);
  if (Array.isArray(stmt.args)) {
    hranaStmt.bindIndexes(stmt.args);
  } else {
    for (const [key, value2] of Object.entries(stmt.args)) {
      hranaStmt.bindName(key, value2);
    }
  }
  return hranaStmt;
}
function resultSetFromHrana(hranaRows) {
  const columns = hranaRows.columnNames.map((c) => c ?? "");
  const columnTypes = hranaRows.columnDecltypes.map((c) => c ?? "");
  const rows = hranaRows.rows;
  const rowsAffected = hranaRows.affectedRowCount;
  const lastInsertRowid = hranaRows.lastInsertRowid !== void 0 ? hranaRows.lastInsertRowid : void 0;
  return new ResultSetImpl(columns, columnTypes, rows, rowsAffected, lastInsertRowid);
}
function mapHranaError(e) {
  if (e instanceof ClientError) {
    const code = mapHranaErrorCode(e);
    return new LibsqlError(e.message, code, void 0, e);
  }
  return e;
}
function mapHranaErrorCode(e) {
  if (e instanceof ResponseError && e.code !== void 0) {
    return e.code;
  } else if (e instanceof ProtoError) {
    return "HRANA_PROTO_ERROR";
  } else if (e instanceof ClosedError) {
    return e.cause instanceof ClientError ? mapHranaErrorCode(e.cause) : "HRANA_CLOSED_ERROR";
  } else if (e instanceof WebSocketError) {
    return "HRANA_WEBSOCKET_ERROR";
  } else if (e instanceof HttpServerError) {
    return "SERVER_ERROR";
  } else if (e instanceof ProtocolVersionError) {
    return "PROTOCOL_VERSION_ERROR";
  } else if (e instanceof InternalError) {
    return "INTERNAL_ERROR";
  } else {
    return "UNKNOWN";
  }
}

// node_modules/.pnpm/@libsql+client@0.8.1_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/client/lib-esm/sql_cache.js
var _owner2, _sqls;
var SqlCache = class {
  constructor(owner, capacity) {
    __privateAdd(this, _owner2);
    __privateAdd(this, _sqls);
    __publicField(this, "capacity");
    __privateSet(this, _owner2, owner);
    __privateSet(this, _sqls, new Lru());
    this.capacity = capacity;
  }
  // Replaces SQL strings with cached `hrana.Sql` objects in the statements in `hranaStmts`. After this
  // function returns, we guarantee that all `hranaStmts` refer to valid (not closed) `hrana.Sql` objects,
  // but _we may invalidate any other `hrana.Sql` objects_ (by closing them, thus removing them from the
  // server).
  //
  // In practice, this means that after calling this function, you can use the statements only up to the
  // first `await`, because concurrent code may also use the cache and invalidate those statements.
  apply(hranaStmts) {
    if (this.capacity <= 0) {
      return;
    }
    const usedSqlObjs = /* @__PURE__ */ new Set();
    for (const hranaStmt of hranaStmts) {
      if (typeof hranaStmt.sql !== "string") {
        continue;
      }
      const sqlText = hranaStmt.sql;
      if (sqlText.length >= 5e3) {
        continue;
      }
      let sqlObj = __privateGet(this, _sqls).get(sqlText);
      if (sqlObj === void 0) {
        while (__privateGet(this, _sqls).size + 1 > this.capacity) {
          const [evictSqlText, evictSqlObj] = __privateGet(this, _sqls).peekLru();
          if (usedSqlObjs.has(evictSqlObj)) {
            break;
          }
          evictSqlObj.close();
          __privateGet(this, _sqls).delete(evictSqlText);
        }
        if (__privateGet(this, _sqls).size + 1 <= this.capacity) {
          sqlObj = __privateGet(this, _owner2).storeSql(sqlText);
          __privateGet(this, _sqls).set(sqlText, sqlObj);
        }
      }
      if (sqlObj !== void 0) {
        hranaStmt.sql = sqlObj;
        usedSqlObjs.add(sqlObj);
      }
    }
  }
};
_owner2 = new WeakMap();
_sqls = new WeakMap();
var _cache;
var Lru = class {
  constructor() {
    // This maps keys to the cache values. The entries are ordered by their last use (entires that were used
    // most recently are at the end).
    __privateAdd(this, _cache);
    __privateSet(this, _cache, /* @__PURE__ */ new Map());
  }
  get(key) {
    const value2 = __privateGet(this, _cache).get(key);
    if (value2 !== void 0) {
      __privateGet(this, _cache).delete(key);
      __privateGet(this, _cache).set(key, value2);
    }
    return value2;
  }
  set(key, value2) {
    __privateGet(this, _cache).set(key, value2);
  }
  peekLru() {
    for (const entry of __privateGet(this, _cache).entries()) {
      return entry;
    }
    return void 0;
  }
  delete(key) {
    __privateGet(this, _cache).delete(key);
  }
  get size() {
    return __privateGet(this, _cache).size;
  }
};
_cache = new WeakMap();

// node_modules/.pnpm/@libsql+client@0.8.1_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/client/lib-esm/ws.js
var import_promise_limit = __toESM(require_promise_limit(), 1);
function _createClient(config) {
  if (config.scheme !== "wss" && config.scheme !== "ws") {
    throw new LibsqlError(`The WebSocket client supports only "libsql:", "wss:" and "ws:" URLs, got ${JSON.stringify(config.scheme + ":")}. For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
  if (config.encryptionKey !== void 0) {
    throw new LibsqlError("Encryption key is not supported by the remote client.", "ENCRYPTION_KEY_NOT_SUPPORTED");
  }
  if (config.scheme === "ws" && config.tls) {
    throw new LibsqlError(`A "ws:" URL cannot opt into TLS by using ?tls=1`, "URL_INVALID");
  } else if (config.scheme === "wss" && !config.tls) {
    throw new LibsqlError(`A "wss:" URL cannot opt out of TLS by using ?tls=0`, "URL_INVALID");
  }
  const url = encodeBaseUrl(config.scheme, config.authority, config.path);
  let client;
  try {
    client = openWs(url, config.authToken);
  } catch (e) {
    if (e instanceof WebSocketUnsupportedError) {
      const suggestedScheme = config.scheme === "wss" ? "https" : "http";
      const suggestedUrl = encodeBaseUrl(suggestedScheme, config.authority, config.path);
      throw new LibsqlError(`This environment does not support WebSockets, please switch to the HTTP client by using a "${suggestedScheme}:" URL (${JSON.stringify(suggestedUrl)}). For more information, please read ${supportedUrlLink}`, "WEBSOCKETS_NOT_SUPPORTED");
    }
    throw mapHranaError(e);
  }
  return new WsClient2(client, url, config.authToken, config.intMode, config.concurrency);
}
var maxConnAgeMillis = 60 * 1e3;
var sqlCacheCapacity = 100;
var _url2, _authToken, _intMode, _connState, _futureConnState, _isSchemaDatabase, _promiseLimitFunction, _WsClient_instances2, openStream_fn, openConn_fn;
var WsClient2 = class {
  /** @private */
  constructor(client, url, authToken, intMode, concurrency) {
    __privateAdd(this, _WsClient_instances2);
    __privateAdd(this, _url2);
    __privateAdd(this, _authToken);
    __privateAdd(this, _intMode);
    // State of the current connection. The `hrana.WsClient` inside may be closed at any moment due to an
    // asynchronous error.
    __privateAdd(this, _connState);
    // If defined, this is a connection that will be used in the future, once it is ready.
    __privateAdd(this, _futureConnState);
    __publicField(this, "closed");
    __publicField(this, "protocol");
    __privateAdd(this, _isSchemaDatabase);
    __privateAdd(this, _promiseLimitFunction);
    __privateSet(this, _url2, url);
    __privateSet(this, _authToken, authToken);
    __privateSet(this, _intMode, intMode);
    __privateSet(this, _connState, __privateMethod(this, _WsClient_instances2, openConn_fn).call(this, client));
    __privateSet(this, _futureConnState, void 0);
    this.closed = false;
    this.protocol = "ws";
    __privateSet(this, _promiseLimitFunction, (0, import_promise_limit.default)(concurrency));
  }
  async limit(fn) {
    return __privateGet(this, _promiseLimitFunction).call(this, fn);
  }
  async execute(stmtOrSql, args) {
    let stmt;
    if (typeof stmtOrSql === "string") {
      stmt = {
        sql: stmtOrSql,
        args: args || []
      };
    } else {
      stmt = stmtOrSql;
    }
    return this.limit(async () => {
      const streamState = await __privateMethod(this, _WsClient_instances2, openStream_fn).call(this);
      try {
        const hranaStmt = stmtToHrana(stmt);
        streamState.conn.sqlCache.apply([hranaStmt]);
        const hranaRowsPromise = streamState.stream.query(hranaStmt);
        streamState.stream.closeGracefully();
        const hranaRowsResult = await hranaRowsPromise;
        return resultSetFromHrana(hranaRowsResult);
      } catch (e) {
        throw mapHranaError(e);
      } finally {
        this._closeStream(streamState);
      }
    });
  }
  async batch(stmts, mode = "deferred") {
    return this.limit(async () => {
      const streamState = await __privateMethod(this, _WsClient_instances2, openStream_fn).call(this);
      try {
        const hranaStmts = stmts.map(stmtToHrana);
        const version2 = await streamState.conn.client.getVersion();
        streamState.conn.sqlCache.apply(hranaStmts);
        const batch = streamState.stream.batch(version2 >= 3);
        const resultsPromise = executeHranaBatch(mode, version2, batch, hranaStmts);
        const results = await resultsPromise;
        return results;
      } catch (e) {
        throw mapHranaError(e);
      } finally {
        this._closeStream(streamState);
      }
    });
  }
  async transaction(mode = "write") {
    return this.limit(async () => {
      const streamState = await __privateMethod(this, _WsClient_instances2, openStream_fn).call(this);
      try {
        const version2 = await streamState.conn.client.getVersion();
        return new WsTransaction(this, streamState, mode, version2);
      } catch (e) {
        this._closeStream(streamState);
        throw mapHranaError(e);
      }
    });
  }
  async executeMultiple(sql) {
    return this.limit(async () => {
      const streamState = await __privateMethod(this, _WsClient_instances2, openStream_fn).call(this);
      try {
        const promise = streamState.stream.sequence(sql);
        streamState.stream.closeGracefully();
        await promise;
      } catch (e) {
        throw mapHranaError(e);
      } finally {
        this._closeStream(streamState);
      }
    });
  }
  sync() {
    return Promise.resolve();
  }
  _closeStream(streamState) {
    streamState.stream.close();
    const connState = streamState.conn;
    connState.streamStates.delete(streamState);
    if (connState.streamStates.size === 0 && connState !== __privateGet(this, _connState)) {
      connState.client.close();
    }
  }
  close() {
    __privateGet(this, _connState).client.close();
    this.closed = true;
  }
};
_url2 = new WeakMap();
_authToken = new WeakMap();
_intMode = new WeakMap();
_connState = new WeakMap();
_futureConnState = new WeakMap();
_isSchemaDatabase = new WeakMap();
_promiseLimitFunction = new WeakMap();
_WsClient_instances2 = new WeakSet();
openStream_fn = async function() {
  if (this.closed) {
    throw new LibsqlError("The client is closed", "CLIENT_CLOSED");
  }
  const now = /* @__PURE__ */ new Date();
  const ageMillis = now.valueOf() - __privateGet(this, _connState).openTime.valueOf();
  if (ageMillis > maxConnAgeMillis && __privateGet(this, _futureConnState) === void 0) {
    const futureConnState = __privateMethod(this, _WsClient_instances2, openConn_fn).call(this);
    __privateSet(this, _futureConnState, futureConnState);
    futureConnState.client.getVersion().then((_version2) => {
      if (__privateGet(this, _connState) !== futureConnState) {
        if (__privateGet(this, _connState).streamStates.size === 0) {
          __privateGet(this, _connState).client.close();
        } else {
        }
      }
      __privateSet(this, _connState, futureConnState);
      __privateSet(this, _futureConnState, void 0);
    }, (_e) => {
      __privateSet(this, _futureConnState, void 0);
    });
  }
  if (__privateGet(this, _connState).client.closed) {
    try {
      if (__privateGet(this, _futureConnState) !== void 0) {
        __privateSet(this, _connState, __privateGet(this, _futureConnState));
      } else {
        __privateSet(this, _connState, __privateMethod(this, _WsClient_instances2, openConn_fn).call(this));
      }
    } catch (e) {
      throw mapHranaError(e);
    }
  }
  const connState = __privateGet(this, _connState);
  try {
    if (connState.useSqlCache === void 0) {
      connState.useSqlCache = await connState.client.getVersion() >= 2;
      if (connState.useSqlCache) {
        connState.sqlCache.capacity = sqlCacheCapacity;
      }
    }
    const stream = connState.client.openStream();
    stream.intMode = __privateGet(this, _intMode);
    const streamState = { conn: connState, stream };
    connState.streamStates.add(streamState);
    return streamState;
  } catch (e) {
    throw mapHranaError(e);
  }
};
openConn_fn = function(client) {
  try {
    client ?? (client = openWs(__privateGet(this, _url2), __privateGet(this, _authToken)));
    return {
      client,
      useSqlCache: void 0,
      sqlCache: new SqlCache(client, 0),
      openTime: /* @__PURE__ */ new Date(),
      streamStates: /* @__PURE__ */ new Set()
    };
  } catch (e) {
    throw mapHranaError(e);
  }
};
var _client4, _streamState;
var WsTransaction = class extends HranaTransaction {
  /** @private */
  constructor(client, state, mode, version2) {
    super(mode, version2);
    __privateAdd(this, _client4);
    __privateAdd(this, _streamState);
    __privateSet(this, _client4, client);
    __privateSet(this, _streamState, state);
  }
  /** @private */
  _getStream() {
    return __privateGet(this, _streamState).stream;
  }
  /** @private */
  _getSqlCache() {
    return __privateGet(this, _streamState).conn.sqlCache;
  }
  close() {
    __privateGet(this, _client4)._closeStream(__privateGet(this, _streamState));
  }
  get closed() {
    return __privateGet(this, _streamState).stream.closed;
  }
};
_client4 = new WeakMap();
_streamState = new WeakMap();

// node_modules/.pnpm/@libsql+client@0.8.1_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/client/lib-esm/http.js
var import_promise_limit2 = __toESM(require_promise_limit(), 1);
function _createClient2(config) {
  if (config.scheme !== "https" && config.scheme !== "http") {
    throw new LibsqlError(`The HTTP client supports only "libsql:", "https:" and "http:" URLs, got ${JSON.stringify(config.scheme + ":")}. For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
  if (config.encryptionKey !== void 0) {
    throw new LibsqlError("Encryption key is not supported by the remote client.", "ENCRYPTION_KEY_NOT_SUPPORTED");
  }
  if (config.scheme === "http" && config.tls) {
    throw new LibsqlError(`A "http:" URL cannot opt into TLS by using ?tls=1`, "URL_INVALID");
  } else if (config.scheme === "https" && !config.tls) {
    throw new LibsqlError(`A "https:" URL cannot opt out of TLS by using ?tls=0`, "URL_INVALID");
  }
  const url = encodeBaseUrl(config.scheme, config.authority, config.path);
  return new HttpClient2(url, config.authToken, config.intMode, config.fetch, config.concurrency);
}
var sqlCacheCapacity2 = 30;
var _client5, _authToken2, _promiseLimitFunction2;
var HttpClient2 = class {
  /** @private */
  constructor(url, authToken, intMode, customFetch, concurrency) {
    __privateAdd(this, _client5);
    __publicField(this, "protocol");
    __privateAdd(this, _authToken2);
    __privateAdd(this, _promiseLimitFunction2);
    __privateSet(this, _client5, openHttp(url, authToken, customFetch));
    __privateGet(this, _client5).intMode = intMode;
    this.protocol = "http";
    __privateSet(this, _authToken2, authToken);
    __privateSet(this, _promiseLimitFunction2, (0, import_promise_limit2.default)(concurrency));
  }
  async limit(fn) {
    return __privateGet(this, _promiseLimitFunction2).call(this, fn);
  }
  async execute(stmtOrSql, args) {
    let stmt;
    if (typeof stmtOrSql === "string") {
      stmt = {
        sql: stmtOrSql,
        args: args || []
      };
    } else {
      stmt = stmtOrSql;
    }
    return this.limit(async () => {
      try {
        const hranaStmt = stmtToHrana(stmt);
        let rowsPromise;
        const stream = __privateGet(this, _client5).openStream();
        try {
          rowsPromise = stream.query(hranaStmt);
        } finally {
          stream.closeGracefully();
        }
        const rowsResult = await rowsPromise;
        return resultSetFromHrana(rowsResult);
      } catch (e) {
        throw mapHranaError(e);
      }
    });
  }
  async batch(stmts, mode = "deferred") {
    return this.limit(async () => {
      try {
        const hranaStmts = stmts.map(stmtToHrana);
        const version2 = await __privateGet(this, _client5).getVersion();
        let resultsPromise;
        const stream = __privateGet(this, _client5).openStream();
        try {
          const sqlCache = new SqlCache(stream, sqlCacheCapacity2);
          sqlCache.apply(hranaStmts);
          const batch = stream.batch(false);
          resultsPromise = executeHranaBatch(mode, version2, batch, hranaStmts);
        } finally {
          stream.closeGracefully();
        }
        const results = await resultsPromise;
        return results;
      } catch (e) {
        throw mapHranaError(e);
      }
    });
  }
  async transaction(mode = "write") {
    return this.limit(async () => {
      try {
        const version2 = await __privateGet(this, _client5).getVersion();
        return new HttpTransaction(__privateGet(this, _client5).openStream(), mode, version2);
      } catch (e) {
        throw mapHranaError(e);
      }
    });
  }
  async executeMultiple(sql) {
    return this.limit(async () => {
      try {
        let promise;
        const stream = __privateGet(this, _client5).openStream();
        try {
          promise = stream.sequence(sql);
        } finally {
          stream.closeGracefully();
        }
        await promise;
      } catch (e) {
        throw mapHranaError(e);
      }
    });
  }
  sync() {
    throw new LibsqlError("sync not supported in http mode", "SYNC_NOT_SUPPORTED");
  }
  close() {
    __privateGet(this, _client5).close();
  }
  get closed() {
    return __privateGet(this, _client5).closed;
  }
};
_client5 = new WeakMap();
_authToken2 = new WeakMap();
_promiseLimitFunction2 = new WeakMap();
var _stream3, _sqlCache;
var HttpTransaction = class extends HranaTransaction {
  /** @private */
  constructor(stream, mode, version2) {
    super(mode, version2);
    __privateAdd(this, _stream3);
    __privateAdd(this, _sqlCache);
    __privateSet(this, _stream3, stream);
    __privateSet(this, _sqlCache, new SqlCache(stream, sqlCacheCapacity2));
  }
  /** @private */
  _getStream() {
    return __privateGet(this, _stream3);
  }
  /** @private */
  _getSqlCache() {
    return __privateGet(this, _sqlCache);
  }
  close() {
    __privateGet(this, _stream3).close();
  }
  get closed() {
    return __privateGet(this, _stream3).closed;
  }
};
_stream3 = new WeakMap();
_sqlCache = new WeakMap();

// node_modules/.pnpm/@libsql+client@0.8.1_bufferutil@4.0.7_utf-8-validate@6.0.3/node_modules/@libsql/client/lib-esm/web.js
function createClient(config) {
  return _createClient3(expandConfig(config, true));
}
function _createClient3(config) {
  if (config.scheme === "ws" || config.scheme === "wss") {
    return _createClient(config);
  } else if (config.scheme === "http" || config.scheme === "https") {
    return _createClient2(config);
  } else {
    throw new LibsqlError(`The client that uses Web standard APIs supports only "libsql:", "wss:", "ws:", "https:" and "http:" URLs, got ${JSON.stringify(config.scheme + ":")}. For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
}

// apps/publish/lib/sqlite-provider/turso.ts
var TursoServerDatabase = class extends BaseServerDatabase {
  constructor(config) {
    super();
    __publicField(this, "db");
    __publicField(this, "filename");
    const { url, readToken } = config;
    this.db = createClient({
      url,
      authToken: readToken
    });
    this.filename = "demo";
  }
  prepare() {
  }
  close() {
    this.db.close();
  }
  async selectObjects(sql) {
    const { rows } = await this.db.execute(sql);
    return rows;
  }
  transaction() {
  }
  async exec(opts) {
    if (typeof opts === "string") {
      const { rows } = await this.db.execute(opts);
      return rows;
    } else if (typeof opts === "object") {
      const { sql, bind, rowMode } = opts;
      if (rowMode === "object") {
        const { rows } = await this.db.execute({
          sql,
          args: bind
        });
        return rows;
      }
      if (rowMode === "array") {
        const { rows, columns } = await this.db.execute({
          sql,
          args: bind
        });
        return rows.map((row) => {
          return columns.map((col, index) => {
            return row[index];
          });
        });
      }
    }
    return [];
  }
  createFunction() {
  }
};

// lib/rpc.ts
var handleFunctionCall = async (data, dataSpace) => {
  if (!dataSpace) {
    throw new Error("DataSpace is null");
  }
  const { method, params = [] } = data;
  workerStore.currentCallUserId = data.userId;
  let callMethod = () => {
  };
  if (method.includes(".")) {
    let obj = dataSpace;
    const properties = method.split(".");
    for (const property of properties.slice(0, -1)) {
      if (property.includes("(") && property.includes(")")) {
        const [funcName, funcParams] = property.split("(");
        const func = obj[funcName].bind(obj);
        const params2 = funcParams.slice(0, -1).split(",");
        obj = await func(...params2);
      } else {
        obj = obj[property];
      }
    }
    callMethod = obj[properties[properties.length - 1]].bind(obj);
  } else {
    callMethod = dataSpace[method].bind(
      dataSpace
    );
  }
  const res = await callMethod(...params);
  return res;
};

// apps/publish/lib/DataSpaceObject.ts
var DataSpaceObject = class {
  constructor(state, env) {
    this.state = state;
    this.env = env;
    __publicField(this, "dataSpace", null);
    __publicField(this, "domainDbInfo", null);
  }
  async initialize(subdomain) {
    if (!this.domainDbInfo) {
      this.domainDbInfo = await this.env.DOMAIN_DB_INFO.get(subdomain, {
        type: "json"
      });
      if (!this.domainDbInfo) {
        throw new Error("Domain not found");
      }
    }
    if (!this.dataSpace) {
      let serverDb;
      switch (this.domainDbInfo.type) {
        case "turso":
          serverDb = new TursoServerDatabase(this.domainDbInfo.config);
          break;
        case "sqlitecloud":
          serverDb = new SQLiteCloudServerDatabase(this.domainDbInfo.config);
          break;
        case "eidosSqliteServer":
          serverDb = new EidosSQLiteServerDatabase(this.domainDbInfo.config);
          break;
        default:
          throw new Error("Unsupported database type");
      }
      this.dataSpace = new DataSpace({
        db: serverDb,
        activeUndoManager: false,
        dbName: "read",
        context: {
          setInterval: void 0
        }
      });
    }
  }
  getCacheKey(req) {
    const { id, type, data: { userId, ...rest } } = req;
    const key = JSON.stringify({ type, data: rest });
    return `https://cache-key/${encodeURIComponent(key)}`;
  }
  async fetch(request) {
    const url = new URL(request.url);
    const subdomain = url.hostname.split(".")[0];
    await this.initialize(subdomain);
    if (!this.dataSpace || !this.domainDbInfo) {
      return new Response("Internal Server Error", { status: 500 });
    }
    const req = await request.json();
    const dbInfo = await this.env.DOMAIN_DB_INFO.get(subdomain, {
      type: "json"
    });
    const cacheKey = this.getCacheKey(req);
    const cacheName = `${subdomain}-${dbInfo.config.version || "default"}`;
    const cache = await caches.open(cacheName);
    let response = await cache.match(cacheKey);
    if (!response) {
      try {
        const res = await handleFunctionCall(req.data, this.dataSpace);
        response = new Response(JSON.stringify({
          status: "success",
          result: res
        }), {
          headers: {
            "content-type": "application/json",
            "Cache-Control": "max-age=3600"
            // Cache for 1 hour
          }
        });
        await cache.put(cacheKey, response.clone());
      } catch (error) {
        response = new Response(JSON.stringify({
          status: "error",
          result: error instanceof Error ? error.message : "Unknown error"
        }), {
          headers: {
            "content-type": "application/json"
          }
        });
      }
    }
    return response;
  }
};

// apps/publish/_worker.ts
function objectNotFound(objectName) {
  return new Response(`<html><body>R2 object "<b>${objectName}</b>" not found</body></html>`, {
    status: 404,
    headers: {
      "content-type": "text/html; charset=UTF-8"
    }
  });
}
var worker_default = {
  async fetch(request, env) {
    const url = new URL(request.url);
    const subdomain = url.hostname.split(".")[0];
    const pathnameRegex = /^\/([^\/]+)\/files\/(.*)$/;
    if (pathnameRegex.test(url.pathname)) {
      const newPathname = "/files" + url.pathname.split("/files")[1];
      const objectName = `${subdomain}${newPathname}`;
      if (request.method === "GET") {
        const object3 = await env.FILES.get(objectName, {
          range: request.headers,
          onlyIf: request.headers
        });
        if (object3 === null) {
          return objectNotFound(objectName);
        }
        const headers2 = new Headers();
        object3.writeHttpMetadata(headers2);
        headers2.set("etag", object3.httpEtag);
        if (object3.range) {
          headers2.set("content-range", `bytes ${object3.range.offset}-${object3.range.end ?? object3.size - 1}/${object3.size}`);
        }
        const status = object3.body ? request.headers.get("range") !== null ? 206 : 200 : 304;
        return new Response(object3.body, {
          headers: headers2,
          status
        });
      }
      const object2 = await env.FILES.head(objectName);
      if (object2 === null) {
        return objectNotFound(objectName);
      }
      const headers = new Headers();
      object2.writeHttpMetadata(headers);
      headers.set("etag", object2.httpEtag);
      return new Response(null, {
        headers
      });
    }
    if (url.pathname.startsWith("/server/api")) {
      const id = env.DATA_SPACE.idFromName(subdomain);
      const dataSpaceObject = env.DATA_SPACE.get(id);
      return dataSpaceObject.fetch(request);
    }
    return env.ASSETS.fetch(request);
  }
};
export {
  DataSpaceObject,
  worker_default as default
};
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

uuidv7/dist/index.js:
  (**
   * uuidv7: A JavaScript implementation of UUID version 7
   *
   * @license Apache-2.0
   * @copyright 2021-2024 LiosK
   * @packageDocumentation
   *)
*/
//# sourceMappingURL=_worker.js.map
